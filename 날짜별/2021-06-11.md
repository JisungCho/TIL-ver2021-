# 2021-06-11

## 코딩테스트  - DFS , BFS

### 12. 토마토

- 거리를 저장할 수 있는 배열을 만듬

```java
package sec08;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Sol12 {
	//방향설정
	static int[] dx = { -1, 0, 1, 0 };
	static int[] dy = { 0, 1, 0, -1 };
	static int[][] graph, dis;
	static int answer, n, m;
	static Queue<Point> Q = new LinkedList<Point>();

	public static void BFS() {
		while (!Q.isEmpty()) {
			Point tmp = Q.poll();
			for (int i = 0; i < 4; i++) { // 4방향
				int nx = tmp.x + dx[i];
				int ny = tmp.y + dy[i];
				if (nx >= 0 && nx < n && ny >= 0 && ny < m && graph[nx][ny] == 0) { //경계선 안 && 안 익은 토마토가 있으면
					graph[nx][ny] = 1;
					Q.offer(new Point(nx, ny));
					dis[nx][ny] = dis[tmp.x][tmp.y]+1;
				}
			}
		}

	}

	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);

		m = kb.nextInt(); // (열)
		n = kb.nextInt(); // (행)
		graph = new int[n][m]; // 토마토판
		dis = new int[n][m]; // 날짜판
		for (int i = 0; i < n; i++) { // 토마토 값 입력
			for (int j = 0; j < m; j++) {
				graph[i][j] = kb.nextInt();
				if (graph[i][j] == 1) { // 익은 토마토 좌표를 미리 Q에 넣어줌
					Q.offer(new Point(i, j));
				}
			}
		}
		BFS();
		boolean flag = true;
		int answer = Integer.MIN_VALUE;
		
		for (int i = 0; i < n; i++) { 
			for (int j = 0; j < m; j++) {
				if (graph[i][j] == 0) { //안익은 토마토가 있으면
					flag = false;
				}
			}
		}
		
		if(flag) { 
			for (int i = 0; i < n; i++) { 
				for (int j = 0; j < m; j++) {
					answer = Math.max(answer, dis[i][j]);
				}
			}
			System.out.println(answer);
		}else { //안 익은 토마토가 있다
			System.out.println(-1);
		}
		
	}
}

```

### 13. 섬나라 아일랜드

- 조사한섬은 0으로 바꿔줌
- 배열을 돌면서 1인 부분에서 조사시작

```java
package sec08;

import java.util.*;

public class Ex13 {
	//8방향
	static int[] dx={-1, -1, 0, 1, 1, 1, 0, -1};
	static int[] dy={0, 1, 1, 1, 0, -1, -1, -1};
	static int[][] board;
	static int answer=0, n;

	public static void DFS(int x, int y) {
		for (int i = 0; i < 8; i++) { // 8방향 조사
			int nx = x + dx[i];
			int ny = y + dy[i];
			if (nx >= 0 && nx < n && ny >= 0 && ny < n && board[nx][ny] == 1) { //경계선 안 && 섬(1)이면
				board[nx][ny] = 0;
				DFS(nx, ny);
			}
		}
	}

	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);

		n = kb.nextInt(); //지도크기
		board = new int[n][n];
		
		for (int i = 0; i < n; i++) { // 섬 입력
			for (int j = 0; j < n; j++) {
				board[i][j] = kb.nextInt();
			}
		}
		
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (board[i][j] == 1) { // 섬(1)인 좌표를 찾으면
					answer++; // 섬의 갯수 하나 증가
					board[i][j] = 0; // 해당 좌표를 0으로 바꿔줌(조사완료)
					DFS(i, j);
				}
			}
		}
		System.out.println(answer);
	}
}

```

### 14. 피자 배달 거리

- 조합의 원리를 생각
- 도시의 피자 배달거리 = 각집의 피자배달거리(최소거리)의 합

```java
package sec08;

import java.util.ArrayList;
import java.util.Scanner;

/*
 * 도시의 피자 배달거리 = 각집의 피자배달거리(최소거리)의 합
 */
public class Sol14 {
	static int n,m,len,answer = Integer.MAX_VALUE;
	static int[] combi; //조합 저장 , 피자집 arraylist 인덱스번호가 들어곰
	static ArrayList<Point> pz,hs; //피자집 좌표 ,  집 좌표

	public  static void DFS(int L, int s) {
		if(L == m) { //조합이 완성
			int sum = 0; //도시의 피자배달거리
			for(Point h : hs) { //집의 좌표가져옴
				int dis = Integer.MAX_VALUE;
				for(int i : combi) {
					//각 집의 피자배달거리
					//가장 작은 거리
					dis = Math.min(dis, Math.abs(h.x-pz.get(i).x)+Math.abs(h.y-pz.get(i).y));
				}
				sum += dis; //도시의 피자 배달거리 = 각집의 피자배달거리의 합
			}
			answer = Math.min(answer, sum); 
		}else {
			for(int i=s; i<len;i++) { // 0부터 5까지
				combi[L] = i;
				DFS(L+1, i+1);
			}
		}
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		n = kb.nextInt(); // 지도 크기
		m = kb.nextInt(); // 살릴 피자집의 수
		pz = new ArrayList<>(); // 0 ,1 ,2 , 3 ,4 ,5
		hs = new ArrayList<>();
		for(int i=0;i<n;i++) {
			for(int j=0;j<n;j++) {
				int tmp = kb.nextInt();
				if(tmp == 1) { // 집이면
					hs.add(new Point(i, j));
				}else if(tmp == 2) { // 피자집이면
					pz.add(new Point(i, j));
				}
			}
		}
		len = pz.size(); // 피자집의 갯수
		combi = new int[m]; // len C m
		DFS(0, 0);
		System.out.println(answer);
	}
}

```

## 스프링프로젝트

- 할 일
  - 로그인 후 글 작성기능
- 한 일
  -  글 작성 후 DB가 달라지면서 INSERT안되는 문제가 발생해결
- 과제
  - 로그아웃 후 다시 로그인할 때 문제 발생

## SQL200제 49번부터 55번

### 49. ROW를 COLUMN으로 출력하기 (UNPIVOT)

```SQL
drop  table order2;

create table order2
( ename  varchar2(10),
  bicycle  number(10),
  camera   number(10),
  notebook  number(10) );

insert  into  order2  values('SMITH', 2,3,1);
insert  into  order2  values('ALLEN',1,2,3 );
insert  into  order2  values('KING',3,2,2 );

commit;


/*
'건수'는 가로로 저장되어 있는 데이터를 세로로 unpivot시킬 출력 열 이름
'아이템'은 가로로 되어있는 order2 테이블의 칼럼명을 unpivot 시켜 세로로 출력할 열 이름
*/
SELECT *
    FROM order2
    UNPIVOT (건수 for 아이템 in (BICYCLE,CAMERA,NOTEBOOK));

SELECT *
    FROM order2
    UNPIVOT (건수 for 아이템 in (BICYCLE as 'B',CAMERA AS 'C',NOTEBOOK AS 'N'));
    
--테이블의 데이터에 null이 포함되어 있다면 unpivot 된 결과에서 출력이 되지 않는다.
UPDATE order2 SET notebook = null WHERE ENAME = 'SMITH';
SELECT *
    FROM order2
    UNPIVOT (건수 for 아이템 in (BICYCLE as 'B',CAMERA AS 'C',NOTEBOOK AS 'N'));
    
--NULL값도 보이도록 출력
SELECT *
    FROM order2
    UNPIVOT INCLUDE NULLS (건수 for 아이템 in (BICYCLE as 'B',CAMERA AS 'C',NOTEBOOK AS 'N'));
```

### 50. 데이터 분석 함수로 누적 데이터 출력하기 (SUM OVER)

```SQL
--OVER 다음의 괄호 안에는 값을 누적할 윈도우 지정
SELECT empno ,ename , sal , SUM(sal) OVER (
                                            ORDER BY empno --사원 번호를 오름차순으로 정렬하고 정렬된 것을 기준으로 월급의 누적치를 출력 
                                            ROWS
                                            -- UNBOUNDED PRECEDING : 맨 첫번째 행
                                            -- CURRENT ROW : 현재 행
                                            -- 제일 첫 번째 행부터 현재 행까지의 값
                                            BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW 
                                          )AS 누적치
    FROM emp
    WHERE job IN ('ANALYST','MANAGER');
```

### 51. 데이터 분석 함수로 비율 출력하기(RATIO_TO_REPORT)

- **OVER함수는 ORDER BY, GROUP BY 서브쿼리를 개선하기 위해 나온 함수라고 할 수 있습니다.**

```SQL
--20번 부서 번호 내에서 자신의 월급비율
SELECT empno , ename , sal , RATIO_TO_REPORT(sal) OVER () AS 비율
    FROM emp
    WHERE deptno = 20;

--두개가 서로 같다.
SELECT empno , ename , sal , RATIO_TO_REPORT(sal) OVER () AS 비율 , SAL/SUM(sal) OVER() AS 비교비율
    FROM emp
    WHERE deptno = 20;
```

### 52. 데이터 분석 함수로 집계 결과 출력하기(ROLLUP)

```SQL
--ROLLUP을 통해 직업과 직업별 토탈 월급을 출력하고 맨 아래쪽에 전체 토탈 월급을 추가적으로 출력 , 오름차순
SELECT job ,sum(sal)
    FROM emp
    GROUP BY ROLLUP(job);

--부서번호별 직업별 토탈월급 , 부서번호별 토탈월급
SELECT deptno , job , sum(sal)
    FROM emp
    GROUP BY ROLLUP(deptno , job);
```

### 53. 데이터 분석 함수로 집계 결과 출력하기(CUBE)

```SQL
--맨 위쪽에 전체 토탈 월급이 추가가 되었고 부서 번호도 오름차순으로 정렬
SELECT deptno , SUM(sal)
    FROM emp
    GROUP BY CUBE(deptno);
    
--전체 토탈월급 , 부선번호별 직업별 토탈월급 , 부서번호별 토탈월급 , 직업별 토탈월급
SELECT deptno ,job , SUM(sal)
    FROM emp
    GROUP BY CUBE(deptno,job);
```

### 54. 데이터 분석 함수로 집계 결과 출력하기(GROUPING SETS)

```sql
SELECT deptno , job , SUM(sal)
    FROM emp
                    --부서별토탈월급,직업별토탈월급,전체토탈월급
    GROUP BY GROUPING SETS((deptno),(job),())
```

### 55. 데이터 분석 함수로 출력 결과 넘버링(ROW_NUMBER)

```SQL
-- ROW_NUMBER()는 출력되는 결과에 번호를 순서대로 부여해서 출력
-- ROW_NUMBER() 함수는 OVER 다음 괄호안에 반드시 ORDER BY 절을 기술
SELECT empno , ename , sal , RANK() OVER(ORDER BY sal DESC) RANK,
                            DENSE_RANK() OVER (ORDER BY sal DESC) DENSE_RANK,
                            ROW_NUMBER() OVER (ORDER BY sal DESC) 번호
    FROM emp
    WHERE deptno = 20;
    

SELECT empno , ename , sal ,  ROW_NUMBER() OVER (PARTITION BY deptno ORDER BY sal DESC) 번호
    FROM emp
    WHERE deptno IN (10,20);
```

