# 2021-05-26

## 코딩테스트 - Recursive, Tree, Graph(DFS, BFS 기초)

### 5. 이진트리순회(DFS : Depth-First Search)

- 이진트리

  ![img](https://blog.kakaocdn.net/dn/bvY5Al/btqECubzp7R/IwtGi62qkgfUuQeLLKQ3CK/img.png)

- 순회

  - 전위순회 : 부모->왼쪽자식 -> 오른쪽자식
  - 중위순회 : 왼쪽자식 -> 부모 -> 오른쪽자식
  - 후위순회 : 왼쪽자식 -> 오른쪽자식 -> 부모

  ![https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F236A5537570E432F2E](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F236A5537570E432F2E)

```java
package sec07;

class Node{
	int data;
	Node lt , rt; // 왼쪽 자식 , 오른쪽 자식  객체 주소
	public Node(int val) {
		data = val;
		lt = rt = null;
	}
}

public class Sol05 {
	static Node root;
	
	public static void DFS(Node root) { // root노드가 들어옴
		if(root == null) return;
		else { //가지 뻗기
			//System.out.print(root.data + " "); //전위순회
			DFS(root.lt);
			//System.out.print(root.data + " "); // 중위순회
			DFS(root.rt);
			System.out.print(root.data + " "); // 후위순회
		}
	}
	
	public static void main(String[] args) {
		root = new Node(1);
		root.lt = new Node(2);
		root.rt = new Node(3);
		root.lt.lt = new Node(4);
		root.lt.rt = new Node(5);
		root.rt.lt = new Node(6);
		root.rt.rt = new Node(7);
		DFS(root);
	}
}

```

### 6. 부분집합 구하기(DFS)

- 원소를 사용한다 안한다로 이진트리를 만듬

```java
package sec07;

public class Sol06 {
	static int n; //집합의 원소의 갯수
	static int[] ch; // 체크배열
	public static void DFS(int L) {
		if(L == n+1 ) { //종착점
			 String tmp = "";
			 for(int i=1;i<=n;i++) {
				 if(ch[i] == 1) { //체크된거면
					 tmp += (i+" ");
				 }
			 }
			 if(tmp.length() >0) {
				 System.out.println(tmp);
			 }
		}else {
			//두 갈래 뻗기
			ch[L] = 1; //사용한다
			DFS(L+1); //왼쪽
			ch[L] = 0; //사용하지 않는다.
			DFS(L+1); //오른쪽
		}
	}
	public static void main(String[] args) {
		n = 3;
		ch = new int[n+1]; // 체크배열의 인덱스 번호를 1부터 사용하려고
		DFS(1); //1이라는 원소를 사용한다 안한다.
	}
}

```

### 7. 이진트리 레벨탐색(BFS : Breadth-First Search)

![내가 정리하는 자료구조 05 - 트리(Tree) | DataLatte's IT Blog](https://heung-bae-lee.github.io/image/level_traversal.png)

```java
package sec07;

import java.util.LinkedList;
import java.util.Queue;

class Node{
	int data;
	Node lt , rt; // 왼쪽 자식 , 오른쪽 자식  객체 주소
	public Node(int val) {
		data = val;
		lt = rt = null;
	}
}

public class Sol07 {
	static Node root;
	
	public static void BFS(Node root) { // root노드가 들어옴
		Queue<Node> Q = new LinkedList<>();
		Q.offer(root);
		int L = 0; //레벨은 처음에 0
		
		while(!Q.isEmpty()) {
			int len = Q.size();
			System.out.print(L+" : ");
			for(int i=0;i<len;i++) {
				Node cur = Q.poll();
				System.out.print(cur.data+" ");
				//연결된 자식노드를 q에 넣어줌
				if(cur.lt != null) { //현재노드의 왼쪽자식이 있니?
					Q.offer(cur.lt);
				}
				if(cur.rt != null) {//현재노드의 오른쪽 자식 있니?
					Q.offer(cur.rt);
				}
			}
			//레벨 끝
			L++; //레벨증가
			System.out.println();//줄바꿈
		}
		
		
	}
	
	public static void main(String[] args) {
		root = new Node(1);
		root.lt = new Node(2);
		root.rt = new Node(3);
		root.lt.lt = new Node(4);
		root.lt.rt = new Node(5);
		root.rt.lt = new Node(6);
		root.rt.rt = new Node(7);
		BFS(root);
	}
}

```

### 8. 송아지 찾기 1(BFS : 상태트리탐색)

- 이미 나온 좌표는 버림
- level값이 점핑 횟수

```java
package sec07;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;
public class Ex08 {
	static int answer = 0;
	static int[]  dis = {1,-1,5};
	static int[] ch; //체크 배열
	static Queue<Integer> Q = new LinkedList<Integer>();
	
	public static int BFS(int s,int e) { 
		ch = new int[10001];
		ch[s] = 1;
		Q.offer(s);
		int L= 0;
		while(!Q.isEmpty()) {
			int len = Q.size(); //레벨에 있는 원소의 갯수 
			for(int i=0;i<len;i++) { //레벨의 원소의 갯수만큼 반복
				int x = Q.poll(); //레벨에 있는 원소를 하나 뽑음
				for(int j=0;j<3;j++) { // 1 , -1  , 5 만큼 거리를 이동
					int nx = x+dis[j];
					if(nx == e) { // 자식의 노드가 송아지의 좌표와 같으면
						return answer = L+1; 
					}
					if(nx >= 1 && nx<=10000 && ch[nx] ==0) { //1과 10000사이 값이고 아직 방문안한 값
						ch[nx] = 1;
						Q.offer(nx);
					}
				}
			}
			L++;
		}
		return 0;
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		int s = kb.nextInt(); // 현수위치
		int e = kb.nextInt();// 송아지위치
		System.out.println(BFS(s, e));
	}
}

```

## SQL - 24번부터 31번

### 24. 숫자를 버리고 출력하기 (TRUNC)

```sql
/*876.567을 소수 점 두번째 자리부터 버림*/
SELECT 876.567 as 숫자 , TRUNC(876.567,1)
    FROM dual;

/*소수점 이전의 첫번째 자리부터 버림*/
SELECT 876.567 as 숫자 , TRUNC(876.567,-1)
    FROM dual;    
    
/*소수점 자리부터 버림*/
SELECT TRUNC(876.567,0),TRUNC(876.567)
    FROM dual;    
```

### 25. 나눈 나머지 값 출력하기 (MOD)

```SQL
/*10을 3으로 나눈 나머지*/
SELECT MOD(10,3)
    FROM DUAL;

/*empno를 홀수와 짝수로 구분*/
SELECT empno , MOD(empno,2)
    FROM emp;
    
/*사원번호가 짝수인 사원의 사원번호와 이름*/    
SELECT empno , ename
    FROM emp
    WHERE MOD(empno,2) = 0;

/*몫을 출력*/
SELECT FLOOR(10/3)
    FROM dual;
```

### 26.날짜 간 개월 수 출력하기(MONTHS_BETWEEN)

- SYSDATE : 오늘 날짜를 확인하는 함수
- MONTHS_BETWEEN : 개월 수를 리턴
- MONTHS_BETWEEN(최신날짜,예전 날짜)
- 함수를 사용하지않고 개월수를 구하려면 31이나 30으로 나눠야하는데 정확하지않으므로 MONTHS_BETWEEN사용

```SQL
/*사이 일수 출력*/
SELECT ename ,MONTHS_BETWEEN(SYSDATE,hiredate)
    FROM emp;

/*함수 사용하지 않고 총 일수 출력*/
SELECT TO_DATE('2019-06-01', 'RRRR-MM-DD') - TO_DATE('2018-10-01','RRRR-MM-DD')
    FROM dual;
    
/*주(week)출력*/
SELECT ROUND((TO_DATE('2019-06-01', 'RRRR-MM-DD') - TO_DATE('2018-10-01','RRRR-MM-DD'))/ 7) FROM DUAL;

```

### 27.개월 수 더한 날짜 출력하기(ADD_MONTHS)

```SQL
/*100달 뒤 날짜*/
SELECT ADD_MONTHS(TO_DATE('2019-05-01', 'RRRR-MM-DD'),100)
    FROM dual;

/*100일 후*/
SELECT TO_DATE('2019-05-01', 'RRRR-MM-DD')+100
    FROM dual;
    
/*INTERVAL사용*/
SELECT TO_DATE('2019-05-01', 'RRRR-MM-DD') + INTERVAL '100' month 
    FROM dual;
    
/*연도가 3자리인 경우 year(3)*/
SELECT TO_DATE('2019-05-01', 'RRRR-MM-DD') + INTERVAL '123' year(3) 
    FROM dual;    
    
SELECT TO_DATE('2019-05-01', 'RRRR-MM-DD') + INTERVAL '3' year 
    FROM dual;
    
/*3년 5개월 후의 날짜*/
SELECT TO_DATE('2019-05-01', 'RRRR-MM-DD') + TO_YMINTERVAL('3-5')
    FROM dual;
```

### 28. 특정 날짜 뒤에 오는 요일 날짜 출력하기(NEXT_DAY)

```SQL
--2019/05/22에서 돌아오는 월요일의 날짜
SELECT '2019/05/22' AS 날짜 , NEXT_DAY('2019/05/22','월요일')
     FROM DUAL;
     
--  오늘 날짜 출력
SELECT SYSDATE AS "오늘 날짜"
    FROM DUAL;

--오늘로부터 돌아오는 화요일
SELECT NEXT_DAY(SYSDATE, '화요일') as "다음 날짜"
    FROM dual;

--오늘부터 100달뒤에 돌아오는 월요일의 날짜
SELECT NEXT_DAY(ADD_MONTHS(SYSDATE,100),'월요일')
    FROM DUAL;
```

### 29. 특정 날짜가 있는 달의 마지막 날짜 출력하기(LAST_DAY)

```SQL
--해당 달의 마지막 날짜
SELECT '2019/05/22' AS 날짜 , LAST_DAY('2019/05/22') AS "마지막 날짜"
     FROM DUAL;
--현재 날짜의 달의 마지막 날 - 현재날짜 남은 일수
SELECT LAST_DAY(SYSDATE) - SYSDATE AS "남은 날짜"
    FROM DUAL;
    
SELECT ename, hiredate , LAST_DAY(hiredate)
    FROM emp
    WHERE ename = 'KING';
```

### 30. 문자형으로 데이터 유형 변환하기(TO_CHAR)

```SQL
--입사일을 요일로 출력 , 천단위로 표시
SELECT ename , TO_CHAR(hiredate,'DAY') as 요일 , TO_CHAR(sal,'999,999') as 월급
    FROM emp
    WHERE ename = 'SCOTT';
    
SELECT hiredate , TO_CHAR(hiredate,'RRRR') AS 연도 , TO_CHAR(hiredate,'MM') AS 월 ,TO_CHAR(hiredate,'DD') AS 일, TO_CHAR(hiredate,'DAY') AS 요일
    FROM emp
    WHERE ename = 'KING';

SELECT ename, hiredate
    FROM emp
    WHERE TO_CHAR(hiredate,'RRRR') = '1981';

--연도/월/일/시간/분/초를 추출하기 위해 EXTRACT 함수 사용
SELECT ename as 이름 , EXTRACT(year from hiredate) as 연도 ,EXTRACT(month from hiredate) as 달 ,EXTRACT(day from hiredate) as 일
    FROM emp;

/*천단위 표시*/
SELECT ename as 이름 , TO_CHAR(sal,'999,999') as 월급
    FROM emp;
    
--백만단위 표시
SELECT ename as 이름 , TO_CHAR(sal*200,'999,999,999') as 월급
    FROM emp;

--원화를 붙여 출력
SELECT ename as 이름 , TO_CHAR(sal*200,'L999,999,999') as 월급
    FROM emp;

```

### 31. 날짜형으로 데이터 유형 변환하기 (TO_DATE)

```SQL
SELECT ename , hiredate
    FROM emp
    WHERE hiredate = TO_DATE('81/11/17','RR/MM/DD');
    
-- 11이 MM, 17이 DD , 81이 RR이라고 설정해놨기 때문에 날짜를 찾을 수 있음
SELECT ename , hiredate
    FROM emp
    WHERE hiredate = TO_DATE('11/17/81','MM/DD/RR');    

/*날짜의 형식*/
SELECT *
    FROM nls_session_parameters
    WHERE parameter = 'NLS_DATE_FORMAT';
    
SELECT ename , hiredate
    FROM emp
    WHERE hiredate = '81/11/17';

```

## 스프링 입문을 위한 자바 객체지향의 원리와 이해

## 다형성 : 사용편의성

### 오버라이딩?오버로딩?

![Screenshot](https://sehun-kim.github.io/sehun/assets/images/033.png)

- 오버라이딩
  - 친구가 내 미니 오토바이 올라타(ride)있다. 오토바이는 안보인다.
  - 같은 메서드 이름, 같은 인자 목록으로 상위클래스의 메서드를 재정의
- 오버로딩
  - 내가 짐을 적재(load)한다. 옆으로 저재한다.
  - 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의

```java
package polymorphism01;

public class Animal {
	 public String name;
	 
	 public void showName() {
		 System.out.printf("안녕 나는 %s야 반가워\n",name);
	 }
}

```

```java
package polymorphism01;

public class Penguin extends Animal{
	public String habitat;
	
	public void showHabitat() {
		System.out.printf("%s는 %s에 살아\n",name,habitat);
	}

	//오버라이딩 :같은 메서드 이름, 같은 인자 목록으로 상위클래스의 메서드를 재정의
	@Override
	public void showName() {
		System.out.println("내이름은 알아서 뭐하게요?");
	}
	
	//오버로딩 : 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의
	public void showName(String yourName) {
		System.out.printf("%s 안녕 , 나는 %s라고 해\n",yourName,name);
	}
	
}

```

```java
package polymorphism01;

public class Driver {
	public static void main(String[] args) {
		Penguin pororo = new Penguin();
		
		pororo.name = "뽀로로";
		pororo.habitat = "남극";
		
		pororo.showName();
		pororo.showName("초보람보");
		pororo.showHabitat();
		
		Animal pingu = new Penguin();
		pingu.name = "핑구";
		pingu.showName();
	}
}

```

### 다형성과 T메모리

![Screenshot](https://sehun-kim.github.io/sehun/assets/images/poly1.PNG)

- 10번째 줄
  - pororo.showName()을  실행하면 Animal 객체에 있는 showName()메서드는 Penguin객체에 있는 showName() 메서드에 의해 재정의 , 즉 가려졌기에 Penguin 객체에서 재정의한 showName()메서드가 호출
- 12번째 줄
  - pingu는 Animal타입인 객체 참조 변수지만 그럼에도 Animal객체의 showName()은 Penguin객체의 showName()에 의해 가져려 있기 때문에 Penguin객체에 의해 재정의된 showName()이 실행
- **상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩한 메서드가 호출**

### 다형성이 지원되지 않는 언어

- 다형성이 지원되지 않는 언어에서는 모든 자료형의 조합의 함수를 만들어야한다
  - add(int , int)
  - addIntDouble(int,double)
  - addDoubleInt(double,int)
- 하지만 자바에서는 **오버로딩**이 가능하기 때문에 함수명 하나를 가지고 인자 목록만 달라지게하면 된다.
  - add(int , int)
  - add(int,double)
  - add(double,int)
- **오버라이딩**의 경우에도 하위 클래스가 재정의한 메서드를 알아서 호출해 줌으로써 형변환이나 instanceof 연산자를 써서 하위 클래스가 무엇인지 신경쓰지 않아도된다.

**따라서 오버라이딩을 통한 메서드 재정의 , 오버로딩을 통한 메서드 중복 정의를 통해  다형성을 제공**

## 캡슐화: 정보은닉

접근 제어자가 인스턴스 멤버에 쓰일 때와 정적 멤버와 함께 쓰일 때를 비교

### 객체 멤버의 접근 제어자

#### Case 1. 멤버 변수, 같은 패키지

![img](https://media.vlpt.us/images/liv660/post/5e165a4a-f498-4080-9dde-e1956c7812d1/case01.jpg)

#### Case 2. 멤버 변수, 다른 패키지

![img](https://media.vlpt.us/images/liv660/post/1eca5898-6df2-4064-923e-e012ff19c348/case02.jpg)

#### Case 3. 정적 변수, 같은 패키지

![img](https://media.vlpt.us/images/liv660/post/7e70b0f4-8f10-4f8b-aaa8-6dc3271a97ea/case03.jpg)

#### Case 4. 정적 변수, 다른 패키지

![img](https://media.vlpt.us/images/liv660/post/4c90c88f-b723-487c-923a-1fac243c7334/case04.jpg)