# 2021-06-22

## 코딩테스트 복습 String 11,12번 Array 1,2,3번

### 11. 문자열 압축

1. 빈문자 추가

2. 빈문자 전까지 반복

3. i번째와 i+1번째를 비교해서 같은문자이면 count++;

   같은 문자가 아니면 answer에 저장 , count가 2이상이면 count도 answer에 저장

```java
package sec01;

import java.util.Scanner;

public class Sol11 {
	public static String solution(String str) {
		String answer="";
		str += " ";
		int count = 1;
		for(int i=0;i<str.length()-1;i++) { //같은경우
			if(str.charAt(i) == str.charAt(i+1)) {
				count ++;
			}else { //다른경우
					answer += str.charAt(i);
					if(count > 1) {
						answer += String.valueOf(count);
					}
					count = 1;	
				}
		}
		return answer;
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		String str = kb.next();
		System.out.println(solution(str));
	}
}

```

### 12. 암호

1. subString 이용해서 문자열 추출
2. 추출한 문자열을 1과 0으로 바꿔줌
3. Integer.parseInt()를 이용해서 2진코드로 되어있는 문자열을 int형으로 만듬
4. 변환된 부분은 빼고 다시 문자열로 만들어줌

```java
package sec01;

import java.util.Scanner;

public class Ex12 {
	public static String solution(String s,int n) {
		String answer ="";
		for(int i=0;i<n;i++) {
			String  str = s.substring(0, 7).replace("#", "1").replace("*", "0");
			int num = Integer.parseInt(str, 2);
			answer += (char)num;
			s = s.substring(7);
		}
		return answer;
	}
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		int n =kb.nextInt();
		String s = kb.next();
		System.out.println(solution(s, n));
	}
}

```

### 1. 큰 수 출력하기

1. num이라는 변수는 초기값에 MIN_VALUE를 넣어놓고 배열의 값을 조회 할때마다 배열값을 넣어줌 결국 배열의 이전값이 들어감
2. num과 배열의 값을 비교해서 배열의 값이 크면 answer에다가 저장

```java
package sec02;

import java.util.ArrayList;
import java.util.Scanner;

public class Ex01 {
	public static ArrayList<Integer> solution(int[] arr) {
		int num = Integer.MIN_VALUE;
		ArrayList<Integer> answer = new ArrayList<>();
		for(int n : arr) {
			if(num < n) {
				answer.add(n);
			}
			num = n;
		}
		return answer;
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt();
		int[] arr = new int[n];
		for(int i=0;i<n;i++) {
			arr[i] = kb.nextInt();
		}
		
		for(int i : solution(arr)) {
			System.out.print(i+" ");
		}
	}
}

```

### 2. 보이는 학생

- 현재까지 최고 키보다 큰 학생이 들어오면 숫자를 증가시켜주고 작은 학생이면 아무것도 안함

```java
package sec02;

import java.util.ArrayList;
import java.util.Scanner;

public class Ex02 {
	public static int solution(int[] arr) {
		int answer = 0;
		int max = Integer.MIN_VALUE;
		for(int n : arr) {
			if(n>max) {
				max = n;
				answer++;
			}
		}
		return answer;
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt();
		int[] arr = new int[n];
		for(int i=0;i<n;i++) {
			arr[i] = kb.nextInt();
		}
		
		System.out.println(solution(arr));
	}
}

```

### 3. 가위바위보

- 한 사람 기준으로 설정

```java
package sec02;

import java.util.ArrayList;
import java.util.Scanner;

public class Ex03 {
	public static ArrayList<Character> solution(int[] a,int[] b,int n) {
		ArrayList<Character> answer = new ArrayList<>();
		
		for(int i=0;i<n;i++) {
			if(a[i] == 1 && b[i] == 3) {
				answer.add('A');
			}else if(a[i] == 2 && b[i] == 1) {
				answer.add('A');
			}else if(a[i] == 3 && b[i] == 2) {
				answer.add('A');
			}else if(a[i] == b[i]) {
				answer.add('D');
			}else {
				answer.add('B');
			}
		}
		return answer;
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt();
		int[] a = new int[n];
		int[] b = new int[n];
		for(int i=0;i<n;i++) {
			a[i] = kb.nextInt();
		}
		for(int i=0;i<n;i++) {
			b[i] = kb.nextInt();
		}
		for(char c : solution(a, b, n)) {
			System.out.println(c);
		}
	}
}

```

## 예제로 배우는 스프링부트 - JdbcTemplate

#### JdbcTemplate 사용하기

##### JdbcTemplate

JDBC를 직접 이용하면 드라이버 로드, 접속 , 쿼리 실행, 종료 등 반복적인 작업과 커넥션 풀 관리 등의 작업을 개발자가 매번 해야한다

-> JdbTemplate 모듈을 사용하여 데이터베이스를 쉽게 사용

##### 데이터베이스 사용 예제

1. 의존성추가

```xml
	<!-- mariaDb -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jdbc</artifactId>
		</dependency>
		<dependency>
			<groupId>org.mariadb.jdbc</groupId>
			<artifactId>mariadb-java-client</artifactId>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
		</dependency>
		<dependency>
			<groupId>org.apache.tomcat.embed</groupId>
			<artifactId>tomcat-embed-jasper</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
```

2. properties

```properties
server.port=8081
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp

#mariadb 설정
spring.datasource.driver-class-name=org.mariadb.jdbc.Driver
spring.datasource.url=jdbc:mariadb://localhost:3307/testdb
spring.datasource.username=root
spring.datasource.password=1234
```

3. DTO, DAO 추가

```JAVA
package com.study.springboot.jdbc;

import lombok.Data;

@Data // 게터와 세터 등등 자동생성
public class MyUserDTO {
	private String id;
	private String name;
}

```

```JAVA
package com.study.springboot.jdbc;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository //빈으로 등록
public class MyUserDAO {
	
	//설정한 데이터베이스의 정보를 바탕으로 오라클 드라이버를 로드하고 데이터베이스에 접속한 후 커넥션 풀까지 생성한 정보가 들어옴
	@Autowired
	private JdbcTemplate jdbcTemplate;
	
	public List<MyUserDTO> list(){
		String query = "select * from myuser";
		List<MyUserDTO> list = jdbcTemplate.query(query, new BeanPropertyRowMapper<>(MyUserDTO.class));
		return list;
	}
}

```

- @Repository 

  - 스테레오 타입의 일종

    - 스테레오 타입

      빈을 등록하고 사용할 때 개발자가 내부적으로 의미 파악을 하기 쉽게 하기위해서 사용하는 별칭

      @Controller : 컨트롤러 용도로 사용

      @Repository : 데이터베이스와 관련된 처리 용도로 사용

```java
package com.study.springboot;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import com.study.springboot.jdbc.MyUserDAO;

@Controller
public class MyController {
	
	//@Repository로 등록한 빈이 들어옴
	@Autowired
	private MyUserDAO userDao;
	
	@RequestMapping("/")
	@ResponseBody
	public String root() throws Exception{
		return "JdbcTemplate 사용하기";
	}
	
	//@GetMapping("/user") get방식으로 지정
	@RequestMapping(value="/user" , method = RequestMethod.GET)
	public String userlistPage(Model model) {
		model.addAttribute("users",userDao.list());
		return "userlist";
	}
}

```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<c:forEach var="dto" items="${users }">
	${dto.id } / ${dto.name }<br/>
</c:forEach>
</body>
</html>
```

### 간단한 게시판 만들기

```java
package com.study.springboot.dto;

import lombok.Data;

@Data
public class SimpleBbsDto {
	private int id;
	private String writer;
	private String title;
	private String content;
}

```

```java
package com.study.springboot.dao;

import java.util.List;

import com.study.springboot.dto.SimpleBbsDto;

public interface ISimpleBbsDao {
	//리스트 보기
	public List<SimpleBbsDto> listDao();
	//개별 항목보기
	public SimpleBbsDto viewDao(String id);
	//글 작성
	public int writeDao(String writer,String title, String content);
	//글 수정
	public int deleteDao(String id);
}

```

```java
package com.study.springboot.dao;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import com.study.springboot.dto.SimpleBbsDto;

@Repository
public class SimpleBbsDao implements ISimpleBbsDao {
	
	@Autowired
	private JdbcTemplate template;
	
	@Override
	public List<SimpleBbsDto> listDao() {
		System.out.println("listdao()");
		
		String query = "select * from simple_bbs order by id desc";
		List<SimpleBbsDto> dtos = template.query(query, new BeanPropertyRowMapper<>(SimpleBbsDto.class));
		return dtos;
	}

	@Override
	public SimpleBbsDto viewDao(String id) {
		System.out.println("viewDao()");
		
		String query = "select * from simple_bbs where id = "+ id;
		SimpleBbsDto dto = template.queryForObject(query, new BeanPropertyRowMapper<>(SimpleBbsDto.class));
		return dto;
	}

	@Override
	public int writeDao(String writer, String title, String content) {
		System.out.println("writeDao()");
		
		String query = "INSERT INTO simple_bbs (writer,title,content) VALUES (?,?,?)";
		return template.update(query, writer,title,content);
	}

	@Override
	public int deleteDao(String id) {
		System.out.println("deleteDao()");
		
		String query = "DELETE FROM simple_bbs WHERE id = ?";
		return template.update(query,Integer.parseInt(id));
	}

}

```

- 쿼리문의 결과가 하나 이상 여러 개가 나오는 SQL문을 처리하기 이해서는 JdbcTemplate 의 query 메서드를 사용
- 결과가 하나만 나오는 sql문은 queryForObject 메서드 사용
- insert , delete, update는 update메서드를 이용

```java
package com.study.springboot;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.study.springboot.dao.ISimpleBbsDao;

@Controller
public class MyController {
	@Autowired
	private ISimpleBbsDao dao;
	
	@RequestMapping("/")
	public String root() throws Exception{
		return "redirect:list";
	}
	
	@RequestMapping("/list")
	public String userlistPage(Model model) {
		model.addAttribute("list",dao.listDao());
		return "list";
	}
	
	@RequestMapping("/view")
	public String view(@RequestParam String id , Model model) {
			model.addAttribute("dto",dao.viewDao(id));
			return "view";
	}
	
	@RequestMapping("/writeForm")
	public String writeForm() {
		return "writeForm";
	}
	
	@RequestMapping("/write")
	public String write(Model model,@RequestParam String writer,@RequestParam String title,@RequestParam String content) {
		dao.writeDao(writer, title, content);
		return "redirect:list";
	}
	
	@RequestMapping("/delete")
	public String delete(@RequestParam String id,Model model) {
		dao.deleteDao(id);
		return "redirect:list";
	}
}

```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>    
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>

<table width="500" cellpadding="0" cellspacing="0" border="1">
    <tr>
        <td>번호</td>
        <td>작성자</td>
        <td>제목</td>
        <td>삭제</td>
    <tr>
    <c:forEach items="${list}" var="dto">
    <tr>
        <td>${dto.id}</td>
        <td>${dto.writer}</td>
        <td><a href="view?id=${dto.id}">${dto.title}</a></td>
        <td><a href="delete?id=${dto.id}">X</a></td>
    <tr>
    </c:forEach>
</table>

<p><a href="writeForm">글작성</a></p>

</body>
</html>
```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>

내용보기 <br>
<hr>
작성자 : ${dto.writer} <br>
제목 : ${dto.title} <br>
내용 : ${dto.content} 
<hr>

<br><p>
<a href="list">목록보기</a>
 
</body>
</html>
```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
<br><p>

<table width="500" cellpadding="0" cellspacing="0" border="1">
    <form action="write" method="post">
    <tr>
        <td > 작성자 </td>
        <td> <input type="text" name="writer" size = "100"> </td>
    </tr>
    <tr>
        <td> 제목 </td>
        <td> <input type="text" name="title" size = "100" > </td>
    </tr>
    <tr>
        <td> 내용 </td>
        <td> <input type="text" name="content" size = "100" > </td>
    </tr>
    <tr >
        <td colspan="2"> <input type="submit" value="입력">
              &nbsp;&nbsp; <a href="list">목록보기</a></td>
    </tr>
    </form>
</table>
</body>
</html>
```

## 스프링 입문을 위한 객체지향의 원리와 이해

### 싱글톤 패턴

- 인스턴스를 하나만 만들어 사용하기 위한 패턴
- 커넥션 풀, 스레드 풀 , 디바이스 설정 객체 등과 같은 경우 인스턴스를 여러 개 만들게 되면 불필요한 자원을 사용하게 되고 , 또 프로그램이 예쌍치 못한 결과를 낳을 수 있기 때문에 싱글톤 패턴을 사용
- 단일 객체가 속성을 갖게 되면 하나의 참조 변수가 변경한 단일 객체의 속성이 다른 참조 변수에 영향을 미치게 되기 때문에 싱글톤 패턴은 쓰기전용 속성을 가지지 않는다.
  - 다만 읽기 전용 속성을 갖는것은 괜찮다.

#### 필요 요소

- new 를 실행할 수 없도록 생성자에 private 접근 제어자
- 유일한 단일 객체를 반환할 수 있는 정적 메서드가 필요
- 유일한 단일 객체를 참조할 정적 참조 변수가 필요

```java
package singletonPattern;

public class Singleton {
	static Singleton singletonObject;
	private Singleton() {}
	
	public static Singleton getInstance() {
		if(singletonObject == null) {
			singletonObject = new Singleton();
		}
		return singletonObject;
	}
}

```

### 템플릿 메서드

**상위 클래스의 견본 메서드에서 하위 클래스가 오러바이딩한 메서드를 호출하는 패턴**

**상위 클래스에 공통 로직을 수행하는 템플릿 메서드와 하위 클래스에 오버라이딩을 강제하는 추상 메서드 또는 선택적으로 오버라이딩할 수 있는 Hook메서드를 두는 패턴**

```java
package TemplateMethod;

public abstract class Animal {
	//템플릿 메서드 - 견본
	public void playWithOwner() {
		System.out.println("귀염둥이 이리온");
		play();
		runSomething();
		System.out.println("잘했어");
	}
	//추상메서드 - 하위 클래스에게 구현을 강제
	abstract void play();
	
	//Hook 메서드 - 하위 클래스가 선택적으로 오버라이딩할 수 있다.
	public void runSomething() {
		System.out.println("꼬리 살랑살랑");
	}
}

```

```java
package TemplateMethod;

public class Dog extends Animal{

	@Override
	void play() {
		System.out.println("멍멍");
	}

	@Override
	public void runSomething() {
		System.out.println("멍 멍 살랑살랑");
	}
	
}

```

```java
package TemplateMethod;

public class Cat extends Animal{
	@Override
	void play() {
		System.out.println("야옹");
	}

	@Override
	public void runSomething() {
		System.out.println("야옹 야옹 살랑살랑");
	}
}

```

```java
package TemplateMethod;

public class Driver {
	public static void main(String[] args) {
		Animal bolt = new Dog();
		Animal kitty  = new Cat();
		
		bolt.playWithOwner();
		
		System.out.println();
		
		kitty.playWithOwner();
		
	}
}
/*
귀염둥이 이리온
멍멍
멍 멍 살랑살랑
잘했어

귀염둥이 이리온
야옹
야옹 야옹 살랑살랑
잘했어
*/
```

### 펙터리 메서드 패턴

펙터리 메서드 : 객체를 생성 반환하는 메서드

**하위 클래스에서 펙터리 메서드를 오버라이딩해서 객체를 반환하는 것**

```java
package FactoryMethod;

public abstract class Animal {
	//추상 펙터리 메서드
	abstract AnimalToy getToy();
}

```

```java
package FactoryMethod;

public abstract class AnimalToy {
	//펙터리 메서드가 생성할 객체의 상위 클래스
	abstract void indentify();
}

```

```java
package FactoryMethod;

public class Dog extends Animal{
	// 추상 펙터리 메서드 오버라이드
	@Override
	AnimalToy getToy() {
		return new DogToy();
	}
}

```

```java
package FactoryMethod;

//펙터리 메서드가 생성할 객체
public class DogToy extends AnimalToy {

	@Override
	void indentify() {
		System.out.println("강아지");
	}

}

```

```java
package FactoryMethod;

public class Cat extends Animal{
	// 추상 펙터리 메서드 오버라이드
	@Override
	AnimalToy getToy() {
		return new CatToy();
	}

}

```

```java
package FactoryMethod;
//펙터리 메서드가 생성할 객체
public class CatToy extends AnimalToy {

	@Override
	void indentify() {
		System.out.println("고양이");
	}

}

```

```java
package FactoryMethod;

public class Driver {
	public static void main(String[] args) {
		//펙터리메서드를 보유한 객체들 생성
		Animal bolt = new Dog();
		Animal kitty  = new Cat();
		
		//펙터리 메서드가 반환하는 객체들
		AnimalToy boltToy = bolt.getToy();
		AnimalToy kittyToy = kitty.getToy();
		
		//펙터리 메서드가 반환한 객체들을 사용
		boltToy.indentify();
		kittyToy.indentify();
	}
}
/*
강아지
고양이
*/
```

### 전략 패턴

#### 요소 

- 전략 메서드를 가진 전략 객체
- 전략 객체를 사용하는 컨텍스트
- 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트

#### 예시

보급장교가 무기를 군인에게 지급해주면 군인은 무기에 따라 전투를 수행

- 무기 - 전략
- 군인 - 컨텍스트
- 보급장교 - 클라이언트

```java
package Stretegy;

//전략 인터페이스
public interface Strategy {
	public abstract void runStrategy();
}

```

```java
package Stretegy;

public class StrategyGun implements Strategy{

	@Override
	public void runStrategy() {
		System.out.println("탕");
	}

}

```

```java
package Stretegy;

public class StrategySword implements Strategy{

	@Override
	public void runStrategy() {
		System.out.println("챙");
	}

}

```

```java
package Stretegy;

public class StrategyBow implements Strategy{

	@Override
	public void runStrategy() {
		System.out.println("슝");
	}

}

```

```java
package Stretegy;

public class Soldier {
	void runContext(Strategy strategy) {
		System.out.println("시작");
		strategy.runStrategy();
		System.out.println("종료");
	}
}

```

```java
package Stretegy;

public class Client {
	public static void main(String[] args) {
		Strategy strategy = null;
		Soldier rambo = new Soldier();
		
		//총을 람보에게 전달해서 전투를 수행
		strategy = new StrategyGun();
		rambo.runContext(strategy);
		
		System.out.println();
		
		//검을 람보에게 전달해서 전투를 수행
		strategy = new StrategySword();
		rambo.runContext(strategy);
		
		System.out.println();
		
		//활을 람보에게 전달해서 전투를 수행
		strategy = new StrategyBow();
		rambo.runContext(strategy);
		
		System.out.println();
	}
}

```

### 탬플릿 콜백 패턴

전략을 익명 내부 클래스로 구현한 전략 패턴

```java
package templateCallBack;

//전략 인터페이스
public interface Strategy {
	public abstract void runStrategy();
}

```

```java
package templateCallBack;

public class Soldier {
	void runContext(Strategy strategy) {
		System.out.println("시작");
		strategy.runStrategy();
		System.out.println("종료");
	}
}

```

```java
package templateCallBack;

public class Client {
	public static void main(String[] args) {
		Strategy strategy = null;
		Soldier rambo = new Soldier();
		
		//총을 람보에게 전달해서 전투를 수행
		rambo.runContext(new Strategy() {
			@Override
			public void runStrategy() {
				System.out.println("탕탕");
			}
		});
		
		System.out.println();
		
		//검을 람보에게 전달해서 전투를 수행
		rambo.runContext(new Strategy() {
			@Override
			public void runStrategy() {
				System.out.println("칼칼");
			}
		});
		
		System.out.println();
		
		//활을 람보에게 전달해서 전투를 수행
		rambo.runContext(new Strategy() {
			@Override
			public void runStrategy() {
				System.out.println("활활");
			}
		});
		
		System.out.println();
	}
}

```

