# 2021-06-14

## 코딩테스트 - Greedy Algorithm

### 우선순위 큐(Priority Queue)란?

일반적으로 큐는 데이터를 일시적으로 쌓아두기 위한 자료구조로 스택과는 다르게 FIFO(First In First Out)의 구조 즉 먼저 들어온 데이터가 먼저 나가는 구조를 가집니다. PriorityQueue는 먼저 들어온 순서대로 데이터가 나가는 것이 아닌 우선순위를 먼저 결정하고 그 우선순위가 높은 엘리먼트가 먼저 나가는 자료구조입니다. 우선순위 큐는 힙을 이용하여 구현하는 것이 일반적입니다. 데이터를 삽입할 때 우선순위를 기준으로 최대힙 혹은 최소 힙을 구성하고 데이터를 꺼낼 때 루트 노드를 얻어낸 뒤 루트 노드를 삭제할 때는 빈 루트 노드 위치에 맨 마지막 노드를 삽입한 후 아래로 내려가면서 적절한 자리를 찾아서 옮기는 방식으로 진행됩니다. 

#### Priority Queue의 특징

**1.** 높은 우선순위의 요소를 먼저 꺼내서 처리하는 구조 (큐에 들어가는 원소는 비교가 가능한 기준이 있어야함) 
**2.** 내부 요소는 힙으로 구성되어 이진트리 구조로 이루어져 있음  
**3.** 내부구조가 힙으로 구성되어 있기에 시간 복잡도는 O(NLogN)

**4.** 응급실과 같이 우선순위를 중요시해야 하는 상황에서 쓰임

### 유니온 파인드(Union-Find)

- 대표적 **그래프 알고리즘**으로 '**합집합 찾기'**라는 의미를 가지고 있습니다.

- **상호 배타적 집합(Disjoint-set)이라고도 합니다.**

-  여러 노드가 존재할 때, 두 개의 노드를 선택해서, 현재 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘이다.
- 2가지 연산으로 이루어져 있습니다.
  - **Find** : x가 어떤 집합에 포함되어 있는지 찾는 연산
  - **Union** : x와 y가 포함되어 있는 집합을 합치는 연산

### 4. 최대 수입 스케쥴(PriorityQueue 응용문제)

1. Priority Queue를 만들어서 가장 큰 값(우선순위가 높은값)이 나올수 있도록 reverseOrder해줌
2. 마감기한에 따라 정렬
3. max값을 최대 날짜로 설정해 놓고 마감기한이 같을 때 pQ에 넣어줌
4. 마감기한이 max보다 작아지는 순간 break하고 pQ에서 poll한값을 answer에 넣어줌

```java
package sec09;

import java.util.ArrayList;
import java.util.Collections;
import java.util.PriorityQueue;
import java.util.Scanner;

class Lecture implements Comparable<Lecture>{
	int money; // 기업이 지불할 강연료
	int time ; // 마감기한
	public Lecture(int money, int time) {
		this.money = money;
		this.time = time;
	}
	@Override
	public int compareTo(Lecture o) {
		return o.time - this.time ;
	}	
}

public class Ex04 {
	static int n,max=Integer.MIN_VALUE;
	
	public static int solution(ArrayList<Lecture> lectures) {
		int answer=0;		
		PriorityQueue<Integer> pQ = new PriorityQueue<>(Collections.reverseOrder());
		Collections.sort(lectures); //날짜에 따라 내림차순 정렬
		int j=0;
		for(int i=max;i>=1;i--) {
			for( ;j<n;j++) {
				if(lectures.get(j).time < i ) break;
				pQ.offer(lectures.get(j).money);
			}
			if(!pQ.isEmpty()) {
				answer += pQ.poll();
			}
		}
		return answer;
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		n = kb.nextInt(); // 강연을 요청한 기업의 수
		ArrayList<Lecture> lectures = new ArrayList<>();
		for(int i=0;i<n;i++) {
			int m = kb.nextInt();
			int d = kb.nextInt();
			lectures.add(new Lecture(m, d));
			if(d > max) { //날짜중에서 가장 큰 값
				max = d;
			}
		}
		System.out.println(solution(lectures));
	}
}

```

### 5. 다익스트라 알고리즘

![image](https://user-images.githubusercontent.com/52770718/121843070-8b03ea00-cd1c-11eb-8e60-0d09b3517bfd.png)

```JAVA
package sec09;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.Scanner;


class Edge implements Comparable<Edge>{
    public int vex; //정점
	public int cost; //가중치값
    Edge(int vex, int cost) {
        this.vex = vex;
        this.cost = cost;
    }
    @Override
    public int compareTo(Edge ob){
        return this.cost-ob.cost; 
    }
}
public class Ex05 {
	static int n, m;
	static ArrayList<ArrayList<Edge>> graph;
	static int[] dis;
	
	public static void solution(int v){
		PriorityQueue<Edge> pQ = new PriorityQueue<>();
		pQ.offer(new Edge(v, 0));
		dis[v]=0;
		while(!pQ.isEmpty()){ //다 익스트라
			Edge tmp=pQ.poll(); // COST비용이 가장 작은값
			int now=tmp.vex; //현재 정점
			int nowCost=tmp.cost; // 현재 정점까지 가는데 비용
			if(nowCost>dis[now]) continue; //더 낮은값이면 더 비교할 필요없다.
			for(Edge ob : graph.get(now)){
				if(dis[ob.vex]>nowCost+ob.cost){
					dis[ob.vex]=nowCost+ob.cost;
					pQ.offer(new Edge(ob.vex, nowCost+ob.cost));
				}
			}
		}
	}

	public static void main(String[] args){
		Scanner kb = new Scanner(System.in);
		n=kb.nextInt(); //정점의 개수
		m=kb.nextInt(); //간선의 개수
		graph = new ArrayList<ArrayList<Edge>>(); //인접리스트
		for(int i=0; i<=n; i++){
			graph.add(new ArrayList<Edge>());
		}
		dis=new int[n+1]; // 정점 1부터 사용
		Arrays.fill(dis, Integer.MAX_VALUE); //MAX_VALUE로 초기화
		for(int i=0; i<m; i++){
			int a=kb.nextInt();
			int b=kb.nextInt();
			int c=kb.nextInt();
			graph.get(a).add(new Edge(b, c));
		}
		solution(1);
		for(int i=2; i<=n; i++){
			if(dis[i]!=Integer.MAX_VALUE) System.out.println(i+" : "+dis[i]);
			else System.out.println(i+" : impossible");
		}
	}
}

```

### 6. 친구인가(Uion&Find)

```java
package sec09;

import java.util.Scanner;

public class Ex06 {
	static int[] unf; //인덱스번호는 학생번호 , 배열값은 집합의 번호
	
	public static int Find(int v){ // v라는 학생의 집합번호 리턴
		if(v==unf[v]) return v;
		else return unf[v]=Find(unf[v]); //경로 압축
	}
	
	public static void Union(int a, int b){ //
		int fa=Find(a);
		int fb=Find(b);
		if(fa!=fb) unf[fa]=fb;
	}
	
	public static void main(String[] args){
		Scanner kb = new Scanner(System.in);
		int n=kb.nextInt();
		int m=kb.nextInt();
		unf=new int[n+1];
		for(int i=1; i<=n; i++) unf[i]=i;
		for(int i=1; i<=m; i++){
			int a=kb.nextInt();
			int b=kb.nextInt();
			Union(a, b); //a와 b를 한 집합으로 만들어라
		}
		int a=kb.nextInt();
		int b=kb.nextInt();
		int fa=Find(a);
		int fb=Find(b);
		if(fa==fb) System.out.println("YES");
		else System.out.println("NO");		
	}
}

```

## 스프링 입문을 위한 객체지향의 원리의 이해

### 객체 지향 설계 5원칙

#### SRP - 단일 책임 원칙

- 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
- **역활과 책임을 분리**
  - ![img](https://mblogthumb-phinf.pstatic.net/20151008_74/rain483_1444230268453rD9tW_JPEG/001.jpg?type=w2)
    - 남자는 역활과 책임이 너무 많기 떄문에 힘들다.
  - ![img](https://mblogthumb-phinf.pstatic.net/20151008_29/rain483_14442302687088ep7O_JPEG/002.jpg?type=w2)
    - 각각 하나의 역활과 책임만 갖게하니 훨씬 좋다.

- SRP가 지켜지지 않는경우

  1. 속성이 SRP를 지키지 않은경우

     ```java
     Class 사람{
     
     }
     
     사람 로미오 = new 사람();
     사람 줄리엣 = new 사람();
     
     줄리엣.군번 = 1234; //줄리엣은 여자인데 군번이 왠말..
     ```

  2. 메서드가 단일 책임 원칙을 지키지 않은경우

     ```java
     class 강아지 {
     	final static Boolean 수컷 = true;
     	final static Boolean 암컷 = false;
     	Boolean 성별;
     	
     	void 소변보다() {
             if(this.성별 == 수컷) {
                 // 한쪽 다리를 들고 소변을 본다.
             } else {
                 // 뒷다리 두 개를 굽혀 앉은 자세로 소변을 본다.
             }
     	}
     }
     ```

     - 소변보다() 메서드가 수컷 강아지의 역할과 암컷 강아지의 역활을 모두 구현하려고 하기에 SRP에 위반됨

     - 해결

       ```JAVA
       abstract class 강아지 {
       	abstract void 소변보다()
       }
        
       class 수컷강아지 extends 강아지 {
           void 소변보다() {
       		// 한쪽 다리를 들고 소변을 본다.
           }
       }
        
       class 암컷강아지 extends 강아지 {
           void 소변보다() {
       		// 뒷다리 두 개를 굽혀 앉은 자세로 소변을 본다.
           }
       }
       ```

- 단일 책임 원칙과 가장 관계가 깊은 것은 모델링 과정을 담당하는 **추상화** 
  - 애플리케이션의 경계를 정하고 추상화를 통해 클래스들을 선별하고 속성과 메서드를 설계할 때 반드시 단일 책임 원칙을 고려

#### OCP - 개방 폐쇄 원칙

- **자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.**

![Screenshot](https://sehun-kim.github.io/sehun/assets/images/1541913936787.png)

![Screenshot](https://sehun-kim.github.io/sehun/assets/images/1541913944420.png)

운전자가 마티즈에서 쏘나타로 차를 바꾸면 운전자는 위와 같이 차량에 따라 운전방법을 바꿔야한다.

![Screenshot](https://sehun-kim.github.io/sehun/assets/images/1541913950879.png)

위와 같이 상위 클래스 또는 인터페이스를 중간에 둠으로써 다양한 자동차가 생긴다고 해도 객체 지향 세계의 운전자는 운전 습관에 영향을 받지 않을 수 있다.

다양한 자동차가 생긴다고 하는 것은 자동차 입장에서는 자신의 확장에는 개방돼 있는 것이고 운전자 입장에서는 주변의 변화에 폐쇄돼 있는 것

#### LSP - 리스코프 치환 원칙

- **서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.**
- **하위 클래스의 인스턴스는 상위형 객체 참조 변숭 대입해 상위 클래스의 인스턴스 역활을 하는데 문제가 없어야 한다.**

하위 클래스 is kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류이다.

구현 클래스 be able to 인터페이스 - 구현 분류는 인터페이스 할 수 있어야한다.

![Screenshot](https://sehun-kim.github.io/sehun/assets/images/1541915202328.png)

분류도 형태인 경우에는 상위 클래스와 하위 클래스로 나누면 이상하다.

```java
아버지 춘향이 = new 딸(); // 딸이 있는데 아버지 역활을 하는 이름이 춘향이다. 말이 이상하다.
```

![Screenshot](https://sehun-kim.github.io/sehun/assets/images/1541915209305.png)

```java
동물 뽀로로 = new 펭귄(); //펭귄이 있는데 동물 역활을하는 이름이 뽀로로다. 말이 어울린다.
```

