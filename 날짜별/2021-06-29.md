# 2021-06-29

## 코딩테스트 Sorting

### 미팅룸(Meeting Room) 

1. 문제분석

   1. star 시간으로 소팅
   2. 전미팅.end > 현재미팅.start인 경우 회의실 필요

2. 코딩화

   1. 자바 Arrays 소팅

      Arrays.sort(intervals , (a,b)->a[0]-b[0])

   2. 전미팅.end > 현재미팅.start

      이차원배열 사용

      첫번째 배열은 미리 빼서 저장, 두번째부터 비교

      end = intervals[ 0 ] [ 1 ]

```java
package sec02;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;

public class MeetingRoom {
	public static void main(String[] args) {
		/*
		int[][] intervals = {
				{5,10},
				{16,20},
				{0,30}
		};
		*/
		int[][] intervals = {
				{6,10},
				{1,3}
		};
		System.out.println(solve(intervals));
	}
	
	public static boolean solve(int[][] intervals) {
		
		Arrays.sort(intervals,new Comparator<int[]>() {

			@Override
			public int compare(int[] o1, int[] o2) {
				return o1[0] - o2[0];
			}
		});
		
		int endtime = intervals[0][1];
		for(int i=1;i<intervals.length;i++) {
			if(endtime > intervals[i][0]) {
				return false;
			}
			endtime = intervals[i][1];
		}
		return true;
	}
}

```

### 미팅룸2(Meeting Room2)

1. 문제분석
   1. 시작시간을 오름차순으로 소팅
   2. 회의끝시간이 제일 긴것을 관리
   3. 앞.end 뒷.start 시간을 비교
   4. 회의실 추가가 필요 없는 것은 하나로 합치고, 추가가 필요한 것은 PQ에 넣는다.

```JAVA
package sec02;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.PriorityQueue;

public class MeetingRoom2 {
	public static void main(String[] args) {
		int[][] intervals = {
				{5,10},
				{16,20},
				{0,30}
		};
		/*
		int[][] intervals = {
				{6,10},
				{1,3}
		};
		*/
		System.out.println(solve(intervals));
	}
	
	public static int solve(int[][] intervals) {
		int count = 1;
        //1. 소팅
		Arrays.sort(intervals,new Comparator<int[]>() {

			@Override
			public int compare(int[] o1, int[] o2) {
				return o1[0] - o2[0];
			}
		});
		// 0,30  , 5,10 , 16,20
		
        //end타임을 오름차순으로 정렬
		PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[1] - b[1]);
		
		for(int[] arr : intervals) {
			if(pq.isEmpty()) { // PQ가 비어있다면
				pq.offer(arr); // 0,30  -> 0,30 , 5,10
			}else {
				if(pq.peek()[1] <= arr[0]) {//30 와 5비교 -> 10과 16을비교
					pq.poll();
				}
				pq.offer(arr);
			}
		}
		return pq.size();
	}
}

```

### interval 병합(Merge Interval) 

1. 문제분석
   1. 시작시간에 대해서 오름차순 소팅
   2. 전.end >= 현재.start면 전.start와 전.end와 현재.end를 비교해서 최고값으로 결과 배열에 넣어줌

```java
package sec02;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class MergeInterval {
	public static int[][] solve(int[][] intervals){
		List<int[]> result = new ArrayList<>();
		
		if(intervals.length == 0 || intervals == null) {
			return result.toArray(new int[0][]);
		}
		
		//1.ds
		Arrays.sort(intervals, (a,b) -> a[0] -b[0]);
		
		//2.for while
		int start = intervals[0][0]; // 1
		int end = intervals[0][1];  //  4
		
		for(int[] i : intervals) {
			if(end >= i[0]) { // 4 >= 2 
				end = Math.max(end, i[1]); //end = 6
			}else {
				result.add(new int[] {start,end});
				start = i[0];
				end = i[1];
			}
			// start = 1 , end = 6
		}
		//마지막 start, end 대입
		result.add(new int[] {start,end});
		
		return result.toArray(new int[0][]);
	}
	public static void main(String[] args) {
		int[][] intervals = {
				{1,4},{2,6},{8,10},{15,18}
//				{1,5},{5,6}
		};
		
		for(int[] arr : solve(intervals)) {
			System.out.println(arr[0] +" "+arr[1]);
		}
		
		
	}
}

```

### 로그 파일의 데이터 재정렬

- 개념

1. ​	

   ```java
   public int compareTo() { 
   	return A.compareTo(B); 
   } 
   ```

   1. A와 B가 같으면 0 
   2. A> B 이면 1
   3. A< B 이면 -1 오름차순 (ex 1 2 3 이런식이면 2-3은 -1 음수) 오름마 -1

2. 

   ```java
   Collections.sort(intervals,(a,b) -> a.start-b.start);
   ```

3. 

```java
Collections.sort(intervals, comp2);
Comparator<Interval> comp2 = new Comparator<Interval>() {
	@Override
	public int compare(Interval o1, Interval o2) {
		if (o1.start > o2.start) {
 			return 1;
		} else if (o1.start < o2.start) {
 			return -1;
		} else {
 			return 0;
		}
	};
```

4. 

   ```java
   3. Comparator comp = new Comparator<Interval>() {
    public int compare(Interval a, Interval b) {
    return a.start - b.start;
   }};
   ```

1. 문제분석

   1. Identifier와 나누기

   2. 두번째 문자열 판단

      1. Char값이 숫자인지 문자인지 판단

         isDIgit , isLetter

   3. Comparator 적용하기

   4. Comparator 모두 문자인 경우

   5. Comparator 나머지 비교

```java
package sec02;

import java.util.Arrays;


public class Logos {
	public static void main(String[] args) {
		String[] logs = {
				"dig1 8 2 3 1",
				"let1 abc cat",
				"dig1 2 5",
				"let2 good dog book",
				"let3 abc zoo" 
		};
		
		String[] result = reorderLogFiles_1(logs);
		for(String s : result) {
			System.out.println("s "+ s);
		}
	}

	public static String[] reorderLogFiles_1(String[] logs) {
		Arrays.sort(logs, (s1, s2) -> {
			
			//비교할 두 문자를 각각 쪼갬
			
			String[] split1 = s1.split(" ", 2); // dig1 , 8 2 3 1
			String[] split2 = s2.split(" ", 2);// let1 , abc cat

			boolean isDigit1 = Character.isDigit(split1[1].charAt(0)); // true
			boolean isDigit2 = Character.isDigit(split2[1].charAt(0)); // false

			if (!isDigit1 && !isDigit2) {
				// 둘다 문자
				int comp = split1[1].compareTo(split2[1]); // 오름차순 마-1
				System.out.println(comp);
				if (comp == 0)
					return split1[0].compareTo(split2[0]); //오름차순
				else
					return comp;
			} else if (isDigit1 && isDigit2) {
				// 둘다 숫자
				return 0;
			} else if (isDigit1 && !isDigit2) {
				// 첫번째는 숫자, 두번째는 문자
				return 1; //내림차
			} else {
				// 첫번째는 문자 , 두번째는 숫자
				return -1; //오름차
			}
		});
		return logs;
	}
}

```

## SQL200제 86번부터 92번

### 86. 서브쿼리를 사용하여 데이터 수정하기

```SQL
--직업이 SALSEMAN인 사원들의 월급을 ALLEN의 월급으로 갱신
UPDATE emp
    SET sal = (SELECT sal
                FROM emp
                WHERE ename ='ALLEN'
                )
    WHERE job = 'SALESMAN';
```

| UPDATE문 | 서브 쿼리 가능 여부 |
| -------- | ------------------- |
| UPDATE절 | 서브 쿼리 사용 가능 |
| SET절    | 서브 쿼리 사용 가능 |
| WHERE 절 | 서브 쿼리 사용 가능 |

### 87. 서브 쿼리를 사용하여 데이터 삭제하기

```sql
--SCOTT보다 더 많은 월급을 받는 사원들을 삭제
DELETE FROM emp
    WHERE sal > (SELECT sal 
                    FROM emp
                    WHERE ename='SCOTT');

--사원의 월급이 자기가 속한 부서 번호의 평균 월급보다 크면 삭제하고 작으면 삭제하지 않는다.                   
DELETE FROM emp m
    WHERE sal > (SELECT avg(sal)
                    FROM emp s
                    WHERE s.deptno = m.deptno)
```

### 88. 서브 쿼리를 사용하여 데이터 합치기

```sql
ALTER TABLE dept    
    ADD sumsal number(10);

--dept 테이블과 , emp에서 부서번호별로 sal합을 가져와서 dept의 deptno가 v.deptno와 같은곳에 sumsal을 업데이트
MERGE INTO dept d
USING (
    SELECT deptno , sum(sal) sumsal
        FROM emp
        GROUP BY deptno) v
ON(d.deptno = v.deptno)
WHEN MATCHED THEN
UPDATE set d.sumsal = v.sumsal; 

```

### 89. 계층형 질의문으로 서열을 주고 데이터 출력하기-1

```sql
SELECT RPAD(' ',level*3) || ename as employee , level, sal , job
    FROM emp
    START WITH ename = 'KING' --루트 노드의 데이터를 지정, 최상위 노드
    CONNECT BY PRIOR empno = mgr; -- 부모 노드와 자식 노드들 간의 관계 , PRIOR를 가운데로 두고 왼쪽에 부모 노드가 되는 컬럼을 적고 오른쪽에 자식 노드가 되는 컬럼을 기술
```

| 용어   | 설명                            |
| ------ | ------------------------------- |
| node   | 표시된 항목                     |
| level  | 트리구조에서 각각의 계층        |
| root   | 트리구조에서 최상위에 있는 노트 |
| parent | 트리 구조에서 상위에 있는 노드  |
| child  | 트리구조에서 하위에 있는 노드   |

- CONNECT BY와 START WITH 절을 사용하면 PSEUDO COLUMN인 LEVEL을 출력
- LEVEL은 계층 트리 구조에서 계층을 말한다

### 90. 계층형 질의문으로 서열을 주고 데이터 출력하기-2

```sql
-- BLAKE뿐만 아니라 BLAKE의 팀원들까지 모두 출력되지 않게 하기
SELECT RPAD(' ',level*3) || ename as employee , level, sal , job
    FROM emp
    START WITH ename = 'KING'
    CONNECT BY PRIOR empno = mgr AND ename != 'BLAKE';
```

### 91. 계층형 질의문으로 서열을 주고 데이터 출력하기 - 3

- ORDER 와 BY 사이에 SIBLINGS를 사용하여 정렬하면 계층형 질의문의 서열 순서를 깨트리지않으면서 출력

```SQL
SELECT RPAD(' ',level*3) || ename as employee , level, sal , job
    FROM emp
    START WITH ename = 'KING'
    CONNECT BY PRIOR empno = mgr 
    ORDER SIBLINGS BY sal DESC;
```

### 92. 계층형 질의문으로 서열을 주고 데이터 출력하기 -4

- SYS_CONNECT_BY 함수를 이용하여 서열 순서를 가로로 출력
- SYS_CONNECT_BY_PATH 함수에 두 번째 인자값으로 ' / ' 을 사용해서 이름과 이름 사이의 연결을  ' / ' 로 출력

```SQL
SELECT ename, SYS_CONNECT_BY_PATH(ename,'/') as path1, LTRIM(SYS_CONNECT_BY_PATH(ename,'/'),'/') as path2
    FROM emp
    START WITH ename = 'KING'
    CONNECT BY PRIOR empno = mgr;
```

