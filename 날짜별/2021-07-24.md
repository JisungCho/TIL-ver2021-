# 2021-07-24

## 정보처리산업기사 필기

### CA 9강 기억장치 분류, 주기억 장치

#### 기억장치 분류

- 전원공급 유무
  -  휘발성(RAM)
  - 비휘발성(ROM)
- 내용 보존 유무
  - 파괴(자기코어)
  - 비 파괴
- 시간의 흐름
  - 정적(SRAM)
  - 동적(DRAM ) - Refresh필요
- 액세스
  - DASD (하드디스크) - 직접 접근
  - SASD(자기 테이프) - 순차 접근
- 주기억 장치 ( 처리용 , 속도 빠름)
- 보조기억 장치(저장용 , 용량 큼)
- 특수용도 기억장치

#### 기억장치 계층구조

- 특수용도 -> 주기억장치 -> 보조기억 장치 순으로 속도가 느려짐 용량은 커짐

#### 기억장치 성능 평가 요소

- 기억용량 , 편리성 , 응답성 , 신뢰도

- 접근시간(Access Time)

  - 정보를 기억장치에 기억시키거나 읽어 내는 명령을 한 후부터 실제로 정보를 기억 또는 읽기 시작할 때까지 소요되는 시간
  - seek time : 트랙을 찾는데 걸리는시간
  - search time : 섹터를 찾는데 걸리는 시간
  - transmission time : 전송 시간

- Cycle time 

  - 기억장치에 접근을 위하여 판독신호를 내고나서 다음 판독신호를 낼 수 있을때까지의 시간

  - 자기코어는 Cycle titme > Access time

- 소요시간 

- 밴드폭(Band width)

  - 기억장치 자료 처리 속도 
  - 정보 전달능력에 한계
  - 1초당 접근가능한 비트

#### 주기억 장치

- cpu가 직접 엑세스

#### ROM

- 비휘발성
- 종류
  - MASK ROM : 프로그램
  - PROM : 내용을 지울 수 없다
  - EPROM : 자외선을 이용하여 지울 수 있다
  - EEPROM : 전기적으로 삭제하고 다시 쓸수 있다.

#### RAM

- 휘발성

- 종류 - 재충전의 유무에 따라서
- DRAM - DYNAMIC RAM
  - 주기적 재충전
  - 일반적인 주기억장치에 사용
  - 전력소모 적다
- SRAM - STATIC RAM
  - 데이터 유지
  - 빠르다
  - 캐시 메모리에 사용

#### 자기코어

- 데이터를 읽으면 읽은 내용이 지워지는 파괴멤리

#### 주기억장치 용량 계산

- 2^Address bus bit X Data bus
- Address bus == PC == MAR
- DataBus == 워드의 사이즈 ==MBR

### CA 10강 보조, 특수용도기억장치 , 병렬컴퓨터

#### 보조기억 장치

- 대규모의 기억용량을 갖는 장비로 구현
- DATA 보관 -> 주기억장치로 이동

#### 자기 테이프 ( 순차 접근 )

- 백업용 ( 대량의 자료를 장시간 보관)
- 입추력 장치
- 블로킹하는 이유
  - 입출력 횟수(시간)을 줄이기 위해
  - 공간 절약
  - 블럭 팩터  : 블럭의 크기 / 레코드 크기

#### 자기 디스크 (직접 접근)

- 구성요소
  - 자기디스크
  - 엑세스 암
  - 헤드
- 구성요소가 아닌 것
  - 실린더
- 실리더의 수 == 트랙의 수

#### 연관(연상) 기억장치 (Associative Memory)

- 자료를 찾을 때 주소가 아니라 기억된 내용의 일부를 이용
- 가격 비쌈
- 속도 빠름
- 기본요소
  - 일치 지시기 
  - 마스크 레지스터
  - 검색 데이터 레지스터

#### 복수 모듈 메모리 기법 (Memory Interleaving)

- 기억장치 모듈을 여러 개 가진 기억장치
- 기억장치에 접근하는 시간을 줄여 CPU와 속도 차이를 줄이기 위한 기법
- 병렬 실행
- 가격 비쌈
- 속도 빠름
- 캐시 기억장치, 고속 DMA 전송 등에 사용

#### 캐시 메모리

- CPU속도와 메모리 속도 차이를 줄이기위해 사용하는 고속 Buffer
- 매핑방식
  - 어소시어티브 매핑
  - 세트-어소시어티브 매핑
  - 직접 매핑

#### 가상기억장치

- 보조기억장치 일부를 마치 주기억장치인 것처럼 이용하는 운영체제의 메모리 운영 기법
- 주기억장치 용량을 크게 <-----> 속도랑은 관계 없다

- 관리 기법
  - 페이징
  - 세그먼트
- 매핑 
  - 가상기억장치에서 주기억장치로 자료의 페이지를 옮길 때 주소를 조정해 주는 것

#### 병렬컴퓨터

여러 프로세서에서 동시에 여러 작업

#### 플린의 분류 ( 명령어와 데이터에 따라)

1. SISD

   단일처리,생산성 적고, 병렬컴퓨터 아님

2. SIMD

   다중처리

3. MISD

   이론적, 사용하지 않음

4. MIMD

## 코딩테스트 - Two Pointer ,  Sliding window

### 두 배열 합치기

```java
import java.util.ArrayList;
import java.util.Scanner;

class Main {
	public static ArrayList<Integer> solution(int n,int m ,int[] arr1 , int[] arr2){
		ArrayList<Integer> answer = new ArrayList<Integer>();
		int pointer1 = 0;
		int pointer2 = 0;
		while(pointer1 < n && pointer2 < m) {
			if(arr1[pointer1] <= arr2[pointer2]) {
				answer.add(arr1[pointer1]);
				pointer1++;
			}else {
				answer.add(arr2[pointer2]);
				pointer2++;
			}
		}
		
		if(pointer1 < n) {
			for(int i=pointer1 ; i<n;i++) {
				answer.add(arr1[i]);
			}
		}
		if(pointer2<m) {
			for(int i=pointer2 ; i<m;i++) {
				answer.add(arr2[i]);
			}
		}
		return answer;
	}

	public static void main(String[] args){
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt(); //첫번째 배열
		int[] arr1 =new int[n];
		for(int i=0;i<n;i++) {
			arr1[i] = kb.nextInt();
		}
		
		int m =kb.nextInt();
		int[] arr2 = new int[m];
		for(int i=0;i<m;i++) {
			arr2[i] = kb.nextInt();
		}
		
		for(int i : solution(n, m, arr1, arr2)) {
			System.out.print(i+ " ");
		}
	}
}
```

### 공통원소 구하기

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

class Main {
	public static ArrayList<Integer> solution(int n,int m ,int[] arr1 , int[] arr2){
		ArrayList<Integer> answer = new ArrayList<Integer>();
		Arrays.sort(arr1);
		Arrays.sort(arr2);
		int p1 = 0;
		int p2 = 0;
		while(p1 < n && p2 < m ) {
			if(arr1[p1] < arr2[p2] ) {
				p1++;
			}else if(arr1[p1] > arr2[p2] ) {
				p2++;
			}else { //같을 때
				answer.add(arr1[p1]);
				p1++;
				p2++;
			}
		}
		return answer;
	}

	public static void main(String[] args){
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt(); //첫번째 배열
		int[] arr1 =new int[n];
		for(int i=0;i<n;i++) {
			arr1[i] = kb.nextInt();
		}
		
		int m =kb.nextInt();
		int[] arr2 = new int[m];
		for(int i=0;i<m;i++) {
			arr2[i] = kb.nextInt();
		}
		
		for(int i : solution(n, m, arr1, arr2)) {
			System.out.print(i+ " ");
		}
	}
}
```

### 최대 매출

- 내 풀이

```java
import java.util.Scanner;

class Main {
	public static int solution(int n,int k ,int[] arr){
		int max = Integer.MIN_VALUE;
		int sum = 0;
		int lt = 0;
		int rt = k-1;
		
		for(int i=0;i<k;i++) {
			sum += arr[i];
		}
		
		max = sum;
		rt++;
		
		while(rt < n) {
			sum = sum - arr[lt]+arr[rt];
			if(sum > max) {
				max = sum;
			}
			lt++;
			rt++;
		}
		
		return max;
	}

	public static void main(String[] args){
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt(); //날짜
		int k = kb.nextInt(); // 일 수 
		int[] arr =new int[n];
		for(int i=0;i<n;i++) { //매출
			arr[i] = kb.nextInt();
		}

		System.out.println(solution(n, k, arr));
	}
}
```

- 풀이

```java
import java.util.*;
class Main {	
	public int solution(int n, int k, int[] arr){
		int answer, sum=0;
		for(int i=0; i<k; i++) sum+=arr[i];
		answer=sum;
		for(int i=k; i<n; i++){
			sum+=(arr[i]-arr[i-k]);
			answer=Math.max(answer, sum);
		}
		return answer;
	}

	public static void main(String[] args){
		Main T = new Main();
		Scanner kb = new Scanner(System.in);
		int n=kb.nextInt();
		int k=kb.nextInt();
		int[] arr=new int[n];
		for(int i=0; i<n; i++){
			arr[i]=kb.nextInt();
		}
		System.out.print(T.solution(n, k, arr));
	}
}
```

