# 2021-06-25

## 코딩테스트 - String

### String 처리에서 필요한 사전 지식

1. charAt(i) => 문자열에서 해당인덱스의 문자
2.  toCharArray() => char[] 
3. IndexOf(), substring(begin, end) 
   - String str = “abcd” 
     - str.indexOf (“a”)// 0 indexOf( "찾을 특정 문자" , "시작할 위치" )
     - str.substring(0,3)= abc 

4. startsWith(), endWith(), split() 
   - String str =“abc”
     - str. startsWith(“a”); => true 
     - str. endWith(“c”);=true 
   - String str =“010 888 7777” 
     - String[] spStr = str. split(“ ”) 
     - String s1 = spStr[0]; =>010 
     - String s2 = spStr[1];  =>888
     - String s3 = spStr[0];  => 7777

5. toLowerCase() 
6. replace() 
7. Character.isDigit(c), Character.isLetter(c) 
8. StringBuilder sb = new StringBuilder(); sb.append(“aa”) 

###  고유한 이메일(Unique Email Addresses)

1. 문제분석
   1. 로컬네임 + 도메인네임
   2. 로컬네임에서는 . 무시
   3. 로컬네임에서 + 이후로 나오는 문자열은 무시
   4. 도메인네임에서 . 이 들어가면 고유하다
2. 규칙찾기
   1. . 이 나오면 => Continue
   2. + or @가 나오면 =>break
   3. Set< String >

```java
package sec01;

import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class UniqueEmailAddresses {

	// basic
	public int solve_basic(String[] emails) {
		// 1.ds
		Set<String> set = new HashSet<>();

		// 2.for while
		for (String s : emails) {
			// test.email+james@coding.com

			String local = getLocal(s); //testemail
			String domain = getDomain(s); //coding.com
			set.add(local + "@" + domain);
		}
		return set.size();
	}

	private String getDomain(String s) {
		return s.substring(s.indexOf('@') + 1);
	}

	private String getLocal(String s) {
		// test.email+james@coding.com

		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == '.') {
				continue;
			} else if (s.charAt(i) == '+' || s.charAt(i) == '@') {
				break;
			} else {
				sb.append(s.charAt(i));
			}
		}
		return sb.toString();
	}

	// split
	public int solve_split(String[] emails) {
		// 1.ds
		Set<String> set = new HashSet<>();

		// 2.for while
		for (String email : emails) {
			// test.email+james@coding.com

			String[] parts = email.split("@");
			// parts[0] test.email+james
			// parts[1] coding.com

			String[] localName = parts[0].split("\\+");
			// test.email
			// james

			// testemail+@+coding.com
			set.add(localName[0].replace(".", "") + "@" + parts[1]);
		}
		return set.size();
	}

	public static void main(String[] args) {
		UniqueEmailAddresses u = new UniqueEmailAddresses();
		Scanner kb = new Scanner(System.in);

		/*
		 * String[] emails = { "test.email+james@coding.com",
		 * "test.e.mail+toto.jane@coding.com", "testemail+tom@cod.ing.com" };
		 */
		String[] emails = { "a@coding.com", "b@coding.com", "c@coding.com" };
		System.out.println(u.solve_basic(emails));
		System.out.println(u.solve_split(emails));
	}
}

```

### 보석과 돌(Jewels And Stones) 

1. 문제분석 & 규칙찾기
   1. 보석은 대소문자를 구분해서 갖고 있어야한다
   2. aA -> 2개
   3. 보석을 저장한다 set
   4. Strone을 for루프
   5. Set에 있는 값과 비교해서 count

```java
package sec01;

import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class JewelsAndStones {
	public static void main(String[] args) {
		JewelsAndStones js = new JewelsAndStones();
		Scanner kb = new Scanner(System.in);
		
		String jewels = kb.next();
		String stones = kb.next();
		
		System.out.println(js.solve(jewels, stones));
	}
	public int solve(String jew , String stones) {
		int count = 0;
		//1.ds
		Set<Character> set = new HashSet<>();
		
		//2.for while
		for(int i=0;i<jew.length();i++) {
			set.add(jew.charAt(i));
		}
		
		for(int i=0;i<stones.length();i++) {
			if(set.contains(stones.charAt(i))) {
				count++;
			}
		}
		
		return count;
	}
}

```

### 라이센스 키 포맷(License Key Formatting)

1. 문제분석
   1. 라이센스 키는 숫자,문자,대시로 구성
   2. 첫번째 그룹은 제외
   3. 두 번째 그룹부터 k개수만큼 그룹
   4. 그룹과 그룹사이에 대쉬
   5. 모든 소문자를 대문자로
2. 규칙찾기
   1. 첫번재 대쉬 인덱스 기억
   2. 대쉬 없애기
   3. 대문자로 만들기
   4. k=4로 문자열 나누기
   5. 나눈 문자열 사이 대쉬 넣기

```java
package sec01;

public class Test1 {
	public static void main(String[] args) {
		String str = "8F-3Z-2e-9-wabcdef";
//		String str = "8F3Z-2e-9-w";
//		String str = "8-5g-3-J";
		int k =2;
		System.out.println(solve(str, k));
	}
	
	public static String solve(String str, int k ) {
        //첫번째 그룹 인덱스 저장
		int index = str.indexOf("-");
		System.out.println(index);
		
        //1. - del
		String newStr= str.replace("-", "");
		System.out.println("1: "+newStr);
		
		//2. upper
		newStr= newStr.toUpperCase();
		System.out.println("2: "+newStr);
		
		//3. k개로 파싱하기, 그리고 - 넣기
		StringBuilder sb = new StringBuilder(newStr);
		System.out.println("3: "+newStr);
//		"8F3Z2E9W"
		int len = sb.length();
		for(int i=k; i<len; i=i+k) {
			if(len-i  < index) {
				break;
			}
			sb.insert(len-i, '-');
		}
		return sb.toString();
	}
}

```

## SQL - 79번부터 85번

### 79. 데이터 수정하기 (UPDATE)

```SQL
UPDATE emp
    SET sal = 3200
    WHERE ename = 'SCOTT';
```

| UPDATE문 | 가능 여부      |
| -------- | -------------- |
| UPDATE   | 서브 쿼리 가능 |
| SET      | 서브 쿼리 가능 |
| WHERE    | 서브 쿼리 가능 |

### 80. 데이터 삭제하기 (DELETE , TRUNCATE , DROP)

- DELETE FROM 다음에 데이터를 지울 테이블명을 작성 , WHERE절을 통해 삭제할 행 제한

  ```SQL
  DELETE FROM emp
      WHERE ename = 'SCOTT';
  ```

- TRUNCATE 명령어는 모든 데이터 한번에 삭제

  - 데이터 삭제 후에는 취소가 불가능하기 때문에 DELETE 보다는 삭제되는 속도가 빠름
  - **데이터를 모두 지우고 테이블 구조만 남겨두는 것이 TRUNCATE**

  ```SQL
  TRUNCATE TABLE emp;
  ```

- DROP 테이블 전체를 한 번에 삭제하는 명령어

  - 삭제 후에 취소는 불가능하지만 플래쉬백으로 테이블을 복구할 수 있다.

  ```SQL
  DROP TABLE emp;
  ```

- **DML ( Data Manipulation Language) - INSERT , UPDATE, DELETE , MERGER**
- **DDL ( Data Definition Laguage)** 
  
  - **암시적인 COMMIT이 발생**
  - **CREATE  - 객체를 생성**
  - **ALTER - 객체를 수정**
  - **DROP - 객체를 삭제**
  - **TRUNCATE - 객체를 삭제**
  - **RENAME - 객체의 이름을 변경**

### 81. 데이터 저장 및 취소하기 (COMMIT , ROLLBACK)

```SQL
SELECT *FROM emp;
INSERT INTO emp (empno,ename,sal,deptno) VALUES (1122,'JACK',3000,20);

COMMIT;

UPDATE emp
    SET sal = 4000
    WHERE ename = 'JACK';

ROLLBACK;
```

- COMMIT 명령어는 **COMMIT 이전에 수행했던 DML작업들을 데이터베이스에 영구히 반영하는 TCL(Transaction Control Language)**
- **ROLLBACK 명령어는 마지막 COMMIT 명령어를 수행한 이후 DML문을 취소하는 TCL**

- TCL
  - COMMIT
  - ROLLBACK
  - SAVEPOINT - 특정 지점까지의 변경을 취소

### 82.데이터 입력, 수정 , 삭제 한번에 하기 (MERGE)

- 데이터 입력과 수정과 삭제를 한 번에 수행할 수 있게 해주는 명령어

```SQL
MERGE INTO 입력 또는 수정할 테이블

USING (원본 테이블, 소스 테이블)

ON (조건)

WHEN MATCHED THEN UPDATE (조건 데이터가 존재하면)

WHEN NOT MATCHED THEN INSERT (조건 데이터가 존재하지 않으면)

```

```SQL
MERGE INTO emp e -- MERGE에 대상이 되는 TARGET 테이블명
USING dept d -- SOURCE 테이블명
ON (e.deptno = d.deptno)
WHEN MATCHED THEN --조인에 성공하면 수행
UPDATE SET e.loc = d.loc
WHEN NOT MATCHED THEN -- 조인에 실패하면 수행
INSERT (e.empno , e.deptno , e.loc ) VALUES (1111,d.deptno,d.loc);
```

### 83. 락(LOCK) 이해하기

- 같은 데이터를 동시에 갱신할 수 없도록 하는것
- 데이터의 일관성을 보장하기 위해
- UPDATE문을 수행하면 UPDATE 대상이 되는 행을 잠궈버린다.

```SQL
1. SCOTT으로 접속한 터미널창 1

UPDATE emp
  SET sal = 3000
  WHERE ename='JONES';

2. SCOTT으로 접속한 터미널창 2

UPDATE emp
  SET sal = 9000
  WHERE ename='JONES';
---멈춤

3. SCOTT으로 접속한 터미널창 1

COMMIT;
```

### 84. SELECT FOR UPDATE절 이해하기

- SELECT ... FOR UPDATE문은 검색하는 행에 락을 거는 SQL문

```SQL
1. SCOTT으로 접속한 터미널창 1

SELECT ename, sal, deptno
  FROM emp
  WHERE ename='JONES'
  FOR UPDATE;

2. SCOTT으로 접속한 터미널창 2

UPDATE emp
  SET sal = 9000
  WHERE ename='JONES';
--멈춤

3. SCOTT으로 접속한 터미널창 1
COMMIT;

```

### 85. 서브 쿼리를 사용하여 데이터 입력하기

- 데이터는 복사하지 않고 테이블의 구조만 복사하여 새로운 테이블 생성하기
- WHERE절이 항상 거짓이 되는 조건으로 지정하여 테이블에서 얻을 수 있는 행을 없게 함

```SQL
CREATE TABLE 새로운테이블명
AS SELECT 컬렴명 , 컬렴명 ,... 	
	FROM 기존테이블명
	WHERE 1=0;
```

VALUES절에 VALUES 대신 입력하고자 하는 서브쿼리문을 기술 , 서브 쿼리문의 컬럼 순서는 INSERT 절 괄호 안의 컬럼 순서대로 작성

여러 개의 행을 한 번에 테이블에 입력할 수 있다.

```sql
INSERT INTO emp2(empno,ename,sal,deptno)
    SELECT empno , ename, sal , deptno
        FROM emp
        WHERE deptno = 10;
```

