# 2021-05-14

## Todo List 프로젝트

### 오늘 할 일

- task를 체크했을 때 만약 아직 완료안된 일정이라면 체크표시로 바꿔주고 task에 줄이 그어진다.
- 완료된 task라면 다시 완료안된 일정이라고 바꿔주고 체크안된표시로 바꿔주고 task의 글이 원래대로 돌아옴

### 해결한 내용

1. jquery에서 해당 클래스를 가지고 있는 hasClass()를 이용해서 파악하고 ajax로 업데이트 정보 전송

   ```js
     	//마커 클릭시
   		$(document).on("click",".todo_mark",function(){ //동적 이벤트 설정
   			
   			var seq = $(this).data("number"); //클릭한 할 일의 번호
   			var mark = $(this); // 클릭한 마커
   			
   			if($(this).hasClass("fa-square-o") === true){  // 아직 할 일 상태이면
   					//db에 업데이트
   					//해당 seq를 가진 todo에 접근해서 todo_state를 completed로 바꿔줌
   					var data = {
   						seq : seq,
   						todo_state : "COMPLETED",
   					};					
   					
   					$.ajax({
   						url : "/todolist/update",
   						type : "put",
   						data : JSON.stringify(data),
   						contentType : "application/json",
   						dataType : 'json',
   						success : function(){
   							location.reload(); //페이지 새로고침
   						}
   					});
   			}else{ //완료 상태이면
   					//db에 업데이트
   					//해당 seq를 가진 todo에 접근해서 todo_state를 ACTIVE로 바꿔줌
   					var data = {
   						seq : seq,
   						todo_state : "ACTIVE",
   					};					
   					
   					$.ajax({
   						url : "/todolist/update",
   						type : "put",
   						data : JSON.stringify(data),
   						contentType : "application/json",
   						dataType : 'json',
   						success : function(){
   							location.reload();
   						}
   					});
   			}
   		});    
   ```

2. mybatis의 동적 sql을 가지고 update문을 수정

   ```xml
   	<update id="update" parameterType="kr.co.jisung.mvc.domain.Todo">
   		UPDATE todo 
   		<set>
   			<if test="todo_content != null">todo_content = #{todo_content},</if>
   			<if test="todo_date != null">todo_date = #{todo_date},</if>
   			<if test="todo_state != null">todo_state = #{todo_state},</if>
   		</set>
   		WHERE seq = #{seq}
   	</update>
   ```

3. history.scrollRestoration  = 'auto' 로 설정해서 페이지 새로고침 시 스크롤 위치를 기억하게 만듬

   ```jsp
   <script>history.scrollRestoration = "auto"</script><!-- 스크롤 위치 기억 -->
   ```

4. jsp 페이지에서 todo_state의 상태가 무엇인지에 따라서 다르게 보일 수 있도록 설정

   ```jsp
   		<!-- Todo list section -->
   		<div class="row mx-1 px-5 pb-3 w-80">
   			<div class="col mx-auto to_do_list">
   				<c:forEach items="${todolist}" var="todo">
   		            <div class="row px-3 align-items-center todo-item rounded">
   		                <div class="col-auto m-1 p-0 d-flex align-items-center">
   		                    <h2 class="m-0 p-0">
   		                    <!-- todo_state의 상태에 따라서 마커 설정 -->
   		                    	<c:if test="${todo.todo_state == 'ACTIVE' }">
   		                    		<i class="fa fa-square-o text-primary btn m-0 p-0 todo_mark" data-number="${todo.seq }" data-toggle="tooltip" data-placement="bottom" title="Mark as complete"></i>
   		                    	</c:if>
   		                        <c:if test="${todo.todo_state == 'COMPLETED' }">
   		                    		<i class="fa fa-check-square-o text-primary btn m-0 p-0 todo_mark" data-number="${todo.seq }" data-toggle="tooltip" data-placement="bottom" title="Mark as do"></i>
   		                    	</c:if>
   		                    </h2>
   		                </div>
   		                <div class="col px-1 m-1 d-flex align-items-center">
   		                	<!-- todo_state의 상태에 따라서 todo내용 설정 -->
   		                	<c:if test="${todo.todo_state == 'ACTIVE' }">
   		                		<input type="text" id="${todo.seq }" class="form-control form-control-lg border-0 edit-todo-input bg-transparent rounded px-3" readonly value="${todo.todo_content }" title="${todo.todo_content }" />
   		                	</c:if>
   		                   	<c:if test="${todo.todo_state == 'COMPLETED' }">
   		                		<input type="text" id="${todo.seq }" class="form-control form-control-lg border-0 edit-todo-input bg-transparent rounded px-3" style="text-decoration: line-through;" readonly value="${todo.todo_content }" title="${todo.todo_content }" />
   		                	</c:if>
   		                </div>
   		                <c:if test="${todo.todo_date != null }"> <!--알림 날짜가 있는 경우 -->
   			                <div class="col-auto m-1 p-0 px-3">
   			                    <div class="row">
   			                        <div class="col-auto d-flex align-items-center rounded bg-white border border-warning">
   			                            <i id="todo_date${todo.seq}" class="fa fa-hourglass-2 my-2 px-2 text-warning btn d-none due" data-toggle="tooltip" data-placement="bottom" title="" data-original-title="Due on date"></i>
   			                            <h6 id="todo_label${todo.seq }" class="text my-2 pr-2"><fmt:formatDate value="${todo.todo_date }" pattern="yyyy/MM/dd"/></h6>
   			                        </div>
   			                    </div>
   			                </div>		                	
   		                </c:if>
   		                <div class="col-auto m-1 p-0 todo-actions">
   		                	<!--  todo_state 가 active인 경우에만 삭제,수정 할 수 있게끔 -->
   		                	<c:if test="${todo.todo_state == 'ACTIVE' }">
   			                    <div class="row d-flex align-items-center justify-content-end">
   			                   		<h5  id="todo_check${todo.seq}" class="m-0 p-0 px-2 d-none">
   			                            <i class="fa fa-check text-info btn m-0 p-0 text-primary check" data-number="${todo.seq }" data-toggle="tooltip" data-placement="bottom" title="수정 완료"></i>
   			                        </h5>
   			                        <h5 id="todo_cancle${todo.seq}" class="m-0 p-0 px-2 d-none">
   			                            <i class="fa fa-times text-info btn m-0 p-0 text-danger cancle" data-number="${todo.seq }" data-toggle="tooltip" data-placement="bottom" title="수정 취소"></i>
   			                        </h5>
   			                        <h5  id="todo_edit${todo.seq }" class="m-0 p-0 px-2">
   			                            <i class="fa fa-pencil text-info btn m-0 p-0 edit" data-number="${todo.seq }" data-toggle="tooltip" data-placement="bottom" title="Edit todo"></i>
   			                        </h5>
   			                        <h5  id="todo_delete${todo.seq }" class="m-0 p-0 px-2">
   			                            <i  class="fa fa-trash-o text-danger btn m-0 p-0 delete" data-number="${todo.seq }" data-toggle="tooltip" data-placement="bottom" title="Delete todo"></i>
   			                        </h5>
   			                    </div>
   		                    </c:if>
   		                    <div class="row todo-created-info">
   		                        <div class="col-auto d-flex align-items-center pr-2">
   		                            <i class="fa fa-info-circle my-2 px-2 text-black-50 btn" data-toggle="tooltip" data-placement="bottom" title="" data-original-title="Created date"></i>
   		                            <label class="date-label my-2 text-black-50"><fmt:formatDate value="${todo.reg_date }" pattern="yyyy/MM/dd"/></label>
   		                        </div>
   		                    </div>
   		                </div>
   		            </div>					
   				</c:forEach>
   			</div>
   		</div>
   ```

### 내일 할 일

- option에 따라서 해당하는 알람을 보여줄 수 있도록 설정 
  - EX) COMPLETED면 완료한 내용만 보여줌



## 코딩테스트 - Sorting and Searching(정렬, 이분검색과 결정알고리즘)

### 4. LSR

- 내 생각

  - 새로운 작업이 들어오면 맨 앞으로 옮기고 메모리가 가득찬 경우 맨뒤의 작업을 삭제하고 뒤로민다
  - 기존 작업을 불러오면 맨 앞으로 옮기고 앞에 있던 것들을 뒤로 민다

  1. 메모리 만큼 배열을 만듬
  2. 메모리에 같은 숫자가 있는지 확인
     1. 있다
        1. 옮긴숫자앞에 있었던 숫자를 뒤로 옮김
        2. 해당 숫자를 맨 앞으로 
     2. 없다
        1. 기존에 있었던 숫자를 뒤로 전부 민다
        2. 해당 숫자를 맨 앞에 넣는다

  ```java
   package sec06;
  
  import java.util.LinkedList;
  import java.util.Queue;
  import java.util.Scanner;
  
  public class Ex04 {
  	public static int[] solution(int s,int n,int[] memory,int[] task) { // ex) n=5
  		Queue<Integer> que = new LinkedList<Integer>();
  		for(int i=0;i<n;i++) {
  			que.offer(task[i]);
  		}
  		
  		while(!que.isEmpty()) {
  			int number = que.poll(); // 작업을 하나 뺌
  			boolean equal = false; // 캐쉬메모리에 같은 숫자가 있는지 없는지
  			
  			int  i=0;
  			for(i=0;i<s;i++) {
  				if(memory[i] == number) {
  					equal = true;
  					break;
  				}
  			}
  			
  			// i는 2
  			
  			if(equal) { // 캐쉬에 같은 작업이 있는 경우
  				for(int j=i-1;j>=0;j--) { // 
  					memory[j+1] = memory[j]; 
  				}
  				memory[0] = number;
  			}else { // 캐쉬에 같은 작업이 없는경우
  				for(int j=s-2;j>=0;j--) {
  					memory[j+1] = memory[j];
  				}
  				memory[0] = number;
  			}
  		}
  		return memory;
  	}
  
  	public static void main(String[] args) {
  		Scanner kb = new Scanner(System.in);
  
  		int s = kb.nextInt(); // 캐시 메모리 크기
  		int n = kb.nextInt(); // 작업의 갯수
  		int[] memory = new int[s];
  		int[] task = new int[n];
  		for(int i=0;i<n;i++) {
  			task[i] = kb.nextInt();
  		}
  		for(int x : solution(s,n,memory,task)) {
  			System.out.print(x+" ");
  		}
  	}
  }
  
  ```

- 풀이

  - 숫자를 뒤로 미는 방법을 잘 생각해야함
    - c[i] = c[i-1]

  ```java
   package sec06;
  
  import java.util.LinkedList;
  import java.util.Queue;
  import java.util.Scanner;
  
  public class Sol04 {
  	public static int[] solution(int s,int n,int[] arr) { // ex) n=5
  		int[] cache = new int[s];
  		for(int x : arr) { // 히트냐 미스냐
  			int pos = -1 ; //인덱스 번호
  			for(int i=0;i<s;i++) { //같은 번호 찾기
  				if(x == cache[i]) { //hit
  					pos = i;
  					break;
  				}
  			}
  			if(pos == -1) {  //mis
  				for(int i=s-1 ; i>=1 ; i--) {
  					cache[i] = cache[i-1];
  				}
  				
  			}else { // hit
  				for(int i=pos ; i>=1 ; i--) {
  					cache[i] = cache[i-1];
  				}
  			}
  			
  			cache[0] = x;
  		}
  		return cache;
  	}
  
  	public static void main(String[] args) {
  		Scanner kb = new Scanner(System.in);
  
  		int s = kb.nextInt(); // 캐시 메모리 크기
  		int n = kb.nextInt(); // 작업의 갯수
  		int[] arr = new int[n];
  		for(int i=0;i<n;i++) {
  			arr[i] = kb.nextInt();
  		}
  		for(int x : solution(s,n,arr)) {
  			System.out.print(x+" ");
  		}
  	}
  }
  
  ```

### 5. 중복 확인

- 내 생각

  - 2중 for문
    - 첫번째 for문은 처음부터 끝앞에까지
    - 두번째 for문은 i다음부터 끝까지
    - 중복된 것이 나오면 break

  ```java
   package sec06;
  
  import java.util.Scanner;
  
  public class Ex05 {
  	public static char solution(int n,int[] arr) { // ex) n=5
  		char answer = 'U';
  		for(int i=0;i<n-1;i++) {
  			for(int j=i+1;j<n;j++) {
  				if(arr[i] == arr[j]) {
  					return answer='D';
  				}
  			}
  		}
  		
  		return answer ;
  	}
  
  	public static void main(String[] args) {
  		Scanner kb = new Scanner(System.in);
  
  		int n = kb.nextInt(); 
  		int[] arr = new int[n];
  		for(int i=0;i<n;i++) {
  			arr[i] = kb.nextInt();
  		}
  		System.out.println(solution(n, arr));
  	}
  }
  
  ```

- 풀이

  - HashMap을 이용해도되고
  - 오름차순 정렬을 써서 이웃한 두 항끼리 비교하면서 체크

  ```java
   package sec06;
  
  import java.util.Arrays;
  import java.util.Scanner;
  
  public class Sol05 {
  	public static char solution(int n,int[] arr) { // ex) n=5
  		char answer = 'U';
  		
  		Arrays.sort(arr); //오름차순으로 정렬
  		
  		for(int i=0;i<n-1;i++) {
  			if(arr[i] == arr[i+1]) {
  				return answer = 'D';
  			}
  		}
  		return answer ;
  	}
  
  	public static void main(String[] args) {
  		Scanner kb = new Scanner(System.in);
  
  		int n = kb.nextInt(); 
  		int[] arr = new int[n];
  		for(int i=0;i<n;i++) {
  			arr[i] = kb.nextInt();
  		}
  		System.out.println(solution(n, arr));
  	}
  }
  
  ```

### 6. 장난꾸러기 (오답)

- 내 풀이

  ```java
   package sec06;
  
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.Scanner;
  
  public class Ex06 {
  	public static ArrayList<Integer> solution(int n,int[] arr) { // ex) n=5
  		ArrayList<Integer> list = new ArrayList<>();
  		
  		Arrays.sort(arr); //오름차순으로 정렬
  		
  		for(int i=0;i<n;i++) {
  			if(arr[i] == 127) {
  				list.add(i+1);
  			}else if(arr[i] == 152) {
  				list.add(i+1);
  			}
  		}
  		return list ;
  	}
  
  	public static void main(String[] args) {
  		Scanner kb = new Scanner(System.in);
  
  		int n = kb.nextInt(); 
  		int[] arr = new int[n];
  		for(int i=0;i<n;i++) {
  			arr[i] = kb.nextInt();
  		}
  		for(int i : solution(n, arr)) {
  			System.out.print(i+" ");
  		}
  	}
  }
  
  ```

- 풀이

  - 깊은복사
  - 오름차순 정렬

  ```java
   package sec06;
  
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.Scanner;
  
  public class Sol06 {
  	public static ArrayList<Integer> solution(int n,int[] arr) { // ex) n=5
  		ArrayList<Integer> answer = new ArrayList<>();
  		
  		int[] tmp = arr.clone(); //깊은 복사
  		Arrays.sort(tmp);
  		
  		for(int i=0;i<n;i++) {
  			if(arr[i] != tmp[i]) {
  				answer.add(i+1);
  			}
  		}
  		return answer ;
  	}
  
  	public static void main(String[] args) {
  		Scanner kb = new Scanner(System.in);
  
  		int n = kb.nextInt(); 
  		int[] arr = new int[n];
  		for(int i=0;i<n;i++) {
  			arr[i] = kb.nextInt();
  		}
  		for(int i : solution(n, arr)) {
  			System.out.print(i+" ");
  		}
  	}
  }
  
  ```


### 7. 좌표정렬

- 내 풀이

  - location이라는 클래스에 x , y를 변수를 만들어서 담는다.

  - 배열에 객체를 담는다.

  - 버블정렬을 통해서 이웃한 location을 비교한다

  - x가 크면 정렬하고 x값이 같으면 y값을 통해서 비교한다. 

    ```java
     package sec06;
    
    import java.util.Scanner;
    
    class Location {
    	int x;
    	int y;
    	
    	public Location(int x, int y) {
    		this.x = x;
    		this.y = y;
    	}
    }
    
    
    public class Ex07 {
    	public static Location[] solution(int n,Location[] arr) { // ex) n=5
    		for(int i=0;i<n-1;i++) { //총 n-1번 반복
    			Location tmp;
    			for(int j=0;j<n-1-i;j++) {
    				if(arr[j].x > arr[j+1].x) {
    					tmp = arr[j];
    					arr[j] = arr[j+1];
    					arr[j+1] = tmp;
    				}else if(arr[j].x == arr[j+1].x) {
    					if(arr[j].y > arr[j+1].y) {
    						tmp = arr[j];
    						arr[j] = arr[j+1];
    						arr[j+1] = tmp;
    					}
    				}
    			}
    		}
    		return arr ;
    	}
    
    	public static void main(String[] args) {
    		Scanner kb = new Scanner(System.in);
    		
    		int n = kb.nextInt(); 
    		Location[] arr = new Location[n];
    		for(int i=0;i<n;i++) {
    			int x = kb.nextInt();
    			int y = kb.nextInt();
    			arr[i] = new Location(x, y);
    		}
    		for(Location i : solution(n, arr)) {
    			System.out.println(i.x+" "+i.y);
    		}
    	}
    }
    
    ```

- 풀이

  - comparable을 이용해서 정렬

  ```java
   package sec06;
  
  import java.util.ArrayList;
  import java.util.Collections;
  import java.util.Scanner;
  
  class Point implements Comparable<Point> { // Point라는 객체를 정렬한다.
  	public int x, y;
  
  	public Point(int x, int y) {
  		this.x = x;
  		this.y = y;
  	}
  
  	@Override
  	public int compareTo(Point o) {
  		// 오른차순
  		if(this.x == o.x) return this.y - o.y;
  		//this 객체-----------> 매개변수 객체  이 순서대로 정렬 하려면 음수값 (오름차순)
  		// 내림차순으로 정렬하려면 	o.y - this.y		
  		else return this.x - o.x;
  		
  		/*
  		 * 내림차순
  		if(this.x == o.x) return o.y-this.y;
  		//this 객체-----------> 매개변수 객체  이 순서대로 정렬 하려면 음수값 (오름차순)
  		// 내림차순으로 정렬하려면 	o.y - this.y		
  		else return o.x-this.x;
  		*/
  	}
  }
  
  
  public class Sol07 {
  
  	public static void main(String[] args) {
  		Scanner kb = new Scanner(System.in);
  		
  		int n = kb.nextInt(); 
  		ArrayList<Point> arr = new ArrayList<>();
  		for(int i=0;i<n;i++) {
  			int x = kb.nextInt();
  			int y = kb.nextInt();
  			arr.add(new Point(x, y));
  		}
  		Collections.sort(arr); // 컬렉션을 정렬 , comparable 인터페이스를 통해서 정렬
  		
  		for(Point o : arr) {
  			System.out.println(o.x+" "+o.y);
  		}
  	}
  }
  
  ```

  