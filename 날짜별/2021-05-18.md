# 2021-05-18

## 자바 객체지향의 원리와 이해

### 객체 지향은 인간 지향이다

절차적/구조적 프로그래밍까지의 과정은 인간이 기계를 이해하려는 노력에서 크게 벗어나지 못하였지만 현실 세계를 반영하는 객체 지향 프로그래밍 등장하게 됨

- 구조적 프로그래밍

  - 함수
    - 논리적인 단위로 나누어 블록화

- 객체 지향 프로그래밍

  우리가 주변에서 사물을 인지하는 방식대로 프로그래밍

  - 객체
    - 세상에 존재하는 모든 것
    - 각각의 사물은 고유
    - 사물은 속성을 갖는다.
    - 사물은 행위를 한다
  - 직관적
    - 인간의 의지 및 사고 방식까지 프로그래밍에 접속하는 인간 지향을 실천

### 객체 지향의 4대 특성 - 캡!상추다.

- **캡** - 캡슐화 : **정보은닉**
- **상** - 상속 : **재사용**
- **추** - 추상화 : **모델링**
- **다** - 다형성 : **사용 편의**

### 클래스 : 객체 = 붕어빵틀 : 붕어빵?

클래스 객체명 = new 클래스(); 

- 붕어빵틀 붕어빵 = new 붕어빵틀();
  - 새로운 붕어빵틀을 만들었더니 붕어빵이 되었다? 이상하다
- 금형기계 붕어빵틀 = new 금형기계()
  - 새로운 금형기계를 만들었더니 붕어빵틀이 되었다? 이상하다

따라서 클래스와 객체는 붕어빵틀과 붕어빵의 관계가 아니다. 

클래스 와 객체의 관계는 개념 과 실체의 관계 이다

- **클래스 : 객체 = 사람 : 김연아 = 펭귄 : 뽀로로 = 개념 : 실체**

### 추상화 : 모델링

- 추상화

  여러가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용

  => **공통 특성 / 공통 속성 추출**

### 추상화는 모델링이다

- 객체 지향의 4대 특성(캡상추다)는 클래스 또는 객체를 통해 구현된다
  - 객체 
    - **세상에 존재하는 유일무이한 사물**
    - **속성과 기능을 가지고 있다.**
  - 클래스
    - **분류 , 집합 , 같은 속성과 기능을 가진 객체를 총칭하는 개념**
- 사람 홍길동  = new 사람();
  - **클래스(분류)를 이용해 유일무이하고 새로운 하나의 사람(객체)를 만들어 홍길동(객체 참조 변수)이라는 이름을 지어줌**
- 객체 = 클래스의 인스턴스
- 애플리케이션 경계
  - 내가 만들고자하는 애플리케이션은 어디에서 사용될 것인가
- **추상화**
  - **구체적인 것을 분해해서 관심 영역(애플리케이션 경계)에 있는 특성만 가지고 재조합 하는 것 = 모델링**
  - **클래스 설계에서 추상화가 사용**
  - **클래스 설계를 위해서는 애플리케이션 경계를 정해야 한다**
  - **객체 지향에서 추상화의 결과는 클래스**
  - **추상화 = 모델링 = 자바의 class 키워드**
  - **클래스 객체참조변수 = new 클래스()**
    - 새로운 객체를 하나 생성해 그 객체의 주소값을 객체 참조 변수에 할당

### 추상화와 T메모리

- 추상화는 주관적 , 추상화의 결과가 설계자마다 다를 수 있다.

- 논리적 설계는 개발환경에 영향을 받지 않는 설계 , 물리적 설계는 개발환경에 맞춰진 설계

  ```java
  package ch3;
  
  public class Mouse {
  	public String name;
  	public int age;
  	public int countOfTail;
  	
  	public void sing() {
  		System.out.println(name+" 찍찍!!!");
  		
  	};
  	
  }
  
  ```

  ```java
  package ch3;
  
  public class MouseDriver {
  	public static void main(String[] args) {
  		//Mouse mickey : Mouse에 대한 참조 변수 mickey를 만든다
  		// new Mouse() : Mouse클래스의 인스턴스를 하나 만들어 힙에 배치한다
  		// 대입문 :  Mouse 객체에 대한 주소를 참조 변수 mickey에 할당
  		// 한 마리 쥐가 태어났으니 그 이름을 mickey라 하였다.
  		//	쥐 : 클래스
  		// 한 마리 쥐 : 클래스의 인스턴스 : 객체
  		// mickey : 객체의 참조변수
  		Mouse micky = new Mouse();
  		
  		//참조 연산자를 이용해 실제 힙 상의 객체에 접근해서 속성에 할당
  		micky.name = "미키";
  		micky.age =85;
  		micky.countOfTail = 1;
  		micky.sing();
  		
  		// mickey가 더 이상 힙 영역에 존재하는 Mouse 객체를 참조하지 않는다.
  		// 가비지 컬렉터가 아무도 참조해 주지 않는 Mouse 객체를 쓰레기로 인지하고 수거
  		micky = null; 
  		
  		Mouse jerry = new Mouse();
  		 jerry.name= "제리";
  		 jerry.age=73;
  		 jerry.countOfTail = 1;
  		 
  		 jerry.sing();
  	}
  }
  
  ```

### 클래스 멤버 vs 객체멤버 = static멤버  vs 인스턴스 멤버

- 같은 클래스의 모든 객체가 같은 값을 가지고 있다면 그 값을 클래스에 저장하면 메모리를 아낄수 있다.

- 클래스 멤버 = static 멤버 = 정적 멤버

- 객체 멤버 = 인스턴스 멤버

  ```java
  package abstraction2;
  
  public class Mouse {
  	public String name; //객체 멤버 속성
  	public int age; //객체 멤버 속성
  	public static int countOfTail = 1; //클래스 멤버 속성
  	
  	public void sing() { 
  		System.out.println(name+" 찍찍!!!");
  		
  	};
  	
  }
  
  ```

  ```java
  package abstraction2;
  
  public class MouseDriver {
  	public static void main(String[] args) {
  		Mouse.countOfTail = 1;
  		
  		Mouse mickey = new Mouse();
  		Mouse jerry = new Mouse();
  		Mouse mighty = new Mouse();
  		
  		//객체로 접근
  		System.out.println(mickey.countOfTail);
  		System.out.println(jerry.countOfTail);
  		System.out.println(mighty.countOfTail);
  		
  		//클래스로 접근
  		System.out.println(Mouse.countOfTail);
  	}
  }
  
  ```

- main() 메서드는 T 메모리가 초기화 된 순간 객체는 하나도 존재하지 않기 때문에 정적 메서드여야만 한다.

- 정적 속성

  - T메모리의 스태틱 영역에 클래스가 배치될 때 클래스 내부에 메모리 공간이 확보

- 객체 속성

  - 속성명만 있지 실제 메모리 공간은 확보하지 않음

- **클래스 변수과 객체 변수는 별도의 초기화를 해주지 않아도 초기화됨**

  - 객체 변수는 하나의 객체 안에서 다수의 객체 메서드가 공유하는 변수
  - 클래스 변수는 전역 변수로써 프로그램 어디서든 접근 가능한 공유 변수

- **지역변수는 별도로 초기화 해야함**

  - 지역 변수는 한 지역에서만 쓰는 변수

- **정리**

| 이름          | 다른 이름                         | T메모리 |
| ------------- | --------------------------------- | ------- |
| static변수    | 클래스 속성, 정적 변수, 정적 속성 | 스태틱  |
| 인스턴스 변수 | 멤버 속성, 객체 변수              | 힙      |
| local변수     | 지역 변수                         | 스택    |

## SQL 200제

### 4.연결 연산자 사용하기 ( || )

- 컬럼과 컬럼을 서로 연결해서 출력할 수 있다.
- 컬럼과 문자열을 연결해서 출력할 수 있다.
- 컬럼 별칭은 맨 마지막에 사용

```SQL
SELECT ename || sal
    FROM emp;

SELECT ename || '의 월급은 ' || sal || '입니다 ' as "월급 정보"
    FROM emp;
    
SELECT ename || '의 직업은 ' || job || '입니다. ' as "직업 정보"
    FROM emp;

```

### 5. 중복된 데이터를 제거해서 출력하기 (DISTINCT)

- 중복된 데이터를 제외하고 출력
- UNIQUE를 써도 됨

```SQL
SELECT DISTINCT job
    FROM emp;
    
SELECT UNIQUE job
    FROM emp;
```

### 6. 데이터를 정렬해서 출력하기 (ORDER BY)

- 데이터를 오름차순 또는 내림차순으로 정렬
- **SQL 작성 시에도 맨 마지막에 작성하고 오라클이 실행할 떄도 맨 마지막에 실행**
- SELECT절에 사용한 컬럼 별칭을 ORDER BY 절에 사용할 수 있다.

```SQL
SELECT ename,sal as "월급"  /*2번실행*/
    FROM emp        /*1번실행*/
    ORDER BY "월급" asc; /*3번실행*/
    
```

```sql
/*부서 번호를 먼저 오름차순 정렬한 기준으로 월급을 내림차순으로 정렬*/
SELECT ename, deptno , sal
    FROM emp
    ORDER BY deptno asc,sal desc;
```

### 7. WHERE절 배우기1 (숫자 데이터 검색)

- WHERE 절은 FROM 절 다음에 작성
- 실행순서는 from절 다음에 실행
- 연산자 사용가능

```SQL
SELECT ename , sal , job 
    FROM emp
    WHERE sal = 3000;
    
/*where절에는 별칭 사용할 수 없다*/
SELECT ename as "이름", sal as "월급"  /*3번순서*/
    FROM emp/*1번순서*/
    WHERE sal >= 3000;/*2번순서*/
```

### 8. WHERE 절 배우기 ( 문자,날짜)

- 문자를 검색할 때는 싱글 쿼테이션 사용
- 싱글 쿼테이션 마크 안에 있는 것이 숫자가 아니라 문자라고 오라클에게 알려줌

```SQL
SELECT ename , sal , job , hiredate ,deptno
    FROM emp
    WHERE ename = 'SCOTT'; 
```

- 날짜도 양쪽에 싱글 쿼테이션 마크

- 날짜 데이터 검색의 경우 현재 접속한 세션의 날짜 형식에 맞춰 작성

- 현재 접속한 세션의 날짜 형식을 확인

  ```SQL
  SELECT *
      FROM NLS_SESSION_PARAMETERS
      WHERE PARAMETER = 'NLS_DATE_FORMAT';
  ```

```SQL
SELECT ename,hiredate
    FROM emp
    WHERE hiredate = '81/11/17';
```

### 9. 산술 연산자 배우기 (*,/,+,-)

- NULL은 데이터가 없는 상태 , 즉 데이터가 할당되지 않은 상태 또는 알 수 없는 값
- 산술식의 컬럼값이 NULL 인 경우 결과도 NULL
- NVL함수
  - NVL(comm, 0) comm을 출력할 때 comm이 NULL이면 0으로 출력하는 함수

```SQL
SELECT ename , sal*12 as 연봉
    FROM emp
    WHERE sal*12 >= 36000;

SELECT ename, sal , comm , sal + comm
    FROM emp
    WHERE deptno = 10;

SELECT ename, sal , comm , sal + NVL(comm,0)
    FROM emp
    WHERE deptno = 10;
```

### 10. 비교 연산자 배우기 1

```sql
SELECT ename , sal , job , deptno
    FROM emp
    WHERE sal >= 1200;
```

## 알고리즘 - Sorting and Searching(정렬, 이분검색과 결정알고리즘)

### 8. 이분 검색

- 내 풀이

  ```java
  package sec06;
  
  import java.util.Arrays;
  import java.util.Scanner;
  
  public class Ex08 {
  	public static int solution(int n,int m,int[] arr) {
  		int answer = 0;
  		
  		int start = 0;
  		int last = arr.length-1;
  		int mid = (start+last) / 2;
  		
  		Arrays.sort(arr);
  		
  		
  		while(true) {
  			if(arr[mid] < m) {
  				start = mid;
  				mid = (start+last) / 2;
  			}else if(arr[mid] > m){
  				last = mid;
  				mid  = (start + last ) / 2;
  			}else if(arr[mid] == m) {
  				return answer = mid+1;
  			}
  		}
  	}
  	
  	public static void main(String[] args) {
  		Scanner kb = new Scanner(System.in);
  		
  		int n = kb.nextInt(); // 갯수
  		int m = kb.nextInt(); // 자연수
  		int[] arr = new int[n];
  		for(int i = 0;i<arr.length;i++) {
  			arr[i] = kb.nextInt();
  		}
  		System.out.println(solution(n, m, arr));
  	}
  }
  
  ```

- 풀이

  ![image](https://user-images.githubusercontent.com/52770718/118638996-64808b00-b812-11eb-9671-d5caa16bfab6.png)

  ```java
  package sec06;
  
  import java.util.Arrays;
  import java.util.Scanner;
  
  public class Sol08 {
  	public static int solution(int n, int m, int[] arr) {
  		int answer = 0;
  		Arrays.sort(arr);
  		int lt = 0, rt = n - 1;
  		while (lt <= rt) {
  			int mid = (lt + rt) / 2;
  			if (arr[mid] == m) {
  				answer = mid + 1;
  				break;
  			}
  			if (arr[mid] > m) {
  				rt = mid - 1;
  			} else {
  				lt = mid + 1;
  			}
  		}
  		return answer;
  	}
  
  	public static void main(String[] args) {
  		Scanner kb = new Scanner(System.in);
  
  		int n = kb.nextInt(); // 갯수
  		int m = kb.nextInt(); // 자연수
  		int[] arr = new int[n];
  		for (int i = 0; i < arr.length; i++) {
  			arr[i] = kb.nextInt();
  		}
  		System.out.println(solution(n, m, arr));
  	}
  }
  
  ```

  