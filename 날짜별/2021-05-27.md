# 2021-05-27

## 코딩테스트 - Recursive, Tree, Graph(DFS, BFS 기초)

### 9. Tree 말단노드까지의 까장 짧은 경로(DFS)

​	<img src="https://user-images.githubusercontent.com/52770718/119766185-86070400-beef-11eb-8ac5-3db8653df06f.png" alt="image" style="zoom: 80%;" />

- DFS로 풀려면 자식노드가 2개 무조건 있어야한다

```JAVA
package sec07;

public class Sol09 {
	
	public static int DFS(int L,Node root) { // root노드가 들어옴
		//노드가 말단 노드이면 return L
		if(root.lt == null && root.rt == null) {
			return L;
		}else {
			//왼쪽과 오른쪽 가지로 뻗는다
			return Math.min(DFS(L+1,root.lt) , DFS(L+1, root.rt) );
		}
	}
	
	public static void main(String[] args) {
		Node root = new Node(1);
		root.lt = new Node(2);
		root.rt = new Node(3);
		root.lt.lt = new Node(4);
		root.lt.rt = new Node(5);
		System.out.println(	DFS(0,root));
	}
}

```

### 10. Tree 말단노드까지의 까장 짧은 경로(BFS)

```java
package sec07;

import java.util.LinkedList;
import java.util.Queue;

class Node {
	int data;
	Node lt, rt; // 왼쪽 자식 , 오른쪽 자식 객체 주소

	public Node(int val) {
		data = val;
		lt = rt = null;
	}
}

public class Sol10 {
	static Node root;

	public static int BFS(Node root) { // root노드가 들어옴
		Queue<Node> Q = new LinkedList<Node>();
		Q.offer(root);
		int L=0;
		while(!Q.isEmpty()) {
			int len =Q.size();
			for(int i=0;i<len;i++) {
				Node cur = Q.poll();
				if(cur.lt == null && cur.rt == null) { //말단 노드이면
					return L; //레벨리턴
				}
				if(cur.lt != null) Q.offer(cur.lt); //왼쪽자식 노드
				if(cur.rt != null) Q.offer(cur.rt); //오른쪽자식 노드
			}
			L++;
		}
		return 0;
	}

	public static void main(String[] args) {
		root = new Node(1);
		root.lt = new Node(2);
		root.rt = new Node(3);
		root.lt.lt = new Node(4);
		root.lt.rt = new Node(5);
		System.out.println(BFS(root));
	}
}

```

### 11. 그래프와 인접행렬

![image](https://user-images.githubusercontent.com/52770718/119768414-8d301100-bef3-11eb-94df-a2b998aa6dee.png)

![image](https://user-images.githubusercontent.com/52770718/119768539-c36d9080-bef3-11eb-8598-450ba5bef6e5.png)

![image](https://user-images.githubusercontent.com/52770718/119768482-aa64df80-bef3-11eb-9191-d15d26f829bb.png)

### 12. 경로탐색(DFS)

![image](https://user-images.githubusercontent.com/52770718/119769414-6246bc80-bef5-11eb-98e5-851b64b98ae5.png)

```java
package sec07;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Sol12 {
	static int n,m,answer = 0;
	static int[][] graph;
	static int[] ch;

	public static void DFS(int v) { // root노드가 들어옴
		if(v == n) { //목적지이면
			answer++;
		}else {
			for(int i=1;i<=n;i++) {
				if(graph[v][i] == 1 && ch[i] == 0) { //갈수 있고
					ch[i] = 1;
					DFS(i);
					//백하는 시점
					ch[i] = 0;
				}
			}
		}
	}

	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		n= kb.nextInt(); // 노드의 갯수
		m=kb.nextInt(); //간선 수
		graph = new int[n+1][n+1]; //인접행렬 , 1번인덱스부터 n번인덱스
		ch = new int[n+1];
		for(int i=0;i<m;i++) {
			int a = kb.nextInt();
			int b = kb.nextInt();
			graph[a][b] = 1;
		}
		ch[1] = 1;
		DFS(1);
		System.out.println(answer);
	}
}

```

### 13. 경로탐색(인접리스트, ArrayList)

![image](https://user-images.githubusercontent.com/52770718/119771492-c4ed8780-bef8-11eb-87fd-332b0b23c0f5.png)

```java
package sec07;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Sol13 {
	static int n,m,answer = 0;
	static ArrayList<ArrayList<Integer>> graph;
	static int[] ch;

	public static void DFS(int v) { 
		if(v == n) {
			answer++;
		}else {
			for(int nv : graph.get(v)) { //v번 arraylist
				if(ch[nv] == 0) {
					ch[nv]  = 1;
					DFS(nv);
					ch[nv] = 0;
				}
			}
		}
	}

	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		n= kb.nextInt(); // 노드의 갯수
		m=kb.nextInt(); //간선 수
		graph = new ArrayList<ArrayList<Integer>>();
		for(int i=0;i<=n;i++) {
			graph.add(new ArrayList<Integer>());
		}
		ch = new int[n+1];
		for(int i=0;i<m;i++) {
			int a = kb.nextInt();
			int b = kb.nextInt();
			graph.get(a).add(b);
		}
		ch[1] = 1;
		DFS(1);
		System.out.println(answer);
	}
}

```

## Spring 프로젝트

- 글 수정 부분 바꿈
- 앞으로 할 일
  - 기간 만료일 때 어떻게 할 것인지
  - 완료상태일 때 삭제 가능하게

## SQL  32번부터 40번까지

### 32.  암시적 형 변환 이해하기

- **오라클은 문자형과 숫자형 두 개를 비교할 때는 문자형을 숫자형으로 변환**

```SQL
SELECT ename, sal
    FROM emp
    WHERE sal = '3000';

CREATE TABLE EMP32(
    ename VARCHAR2(10),
    sal VARCHAR2(10)
);

INSERT INTO EMP32 VALUES ('SCOTT','3000');
INSERT INTO EMP32 VALUES ('SMITH','1200');
COMMIT;

/*문자형 =  문자형*/
SELECT ename, sal
    FROM emp32
    WHERE sal = '3000';

/*문자형을 숫자형으로 자동변환*/
SELECT ename , sal
    FROM emp32
    WHERE sal = 3000;
```

### 33. NULL 값 대신 다른 데이터 출력하기 (NVL,NVL2)

```Sql
/*comm이 null이면 0 출력 ,실제 데이터가 0으로 변경되는 것은 아님*/
SELECT ename , comm , NVL(comm,0)
    FROM emp;
    
-- NULL + 숫자는 NULL
SELECT ename , sal , comm , sal+comm
    FROM emp
    WHERE job IN ('SALESMAN','ANALYST');

SELECT ename , sal , comm , NVL(comm,0) , sal+NVL(comm,0)
    FROM emp
    WHERE job IN ('SALESMAN','ANALYST');
    
--NVL2 
--comm이 null이 아닌 사람은 sal+comm을 출력
--comm이 null인 사람은 sal을 출력
SELECT ename , sal , comm , NVL2(comm,sal+comm,sal)
    FROM emp
    WHERE job IN ('SALESMAN','ANALYST');

```

### 34. IF문을 SQL로 구현하기 (DECODE)

- = 비교만 가능

```sql
--부서번호가 10번이면 300
--20번이면 400
--둘다 아니면 0
SELECT ename , deptno, DECODE(deptno,10,300,20,400,0) as 보너스
    FROM emp;

--짝수인지 홀수 인지 출력
SELECT empno , MOD(empno,2), DECODE(MOD(empno,2),0,'짝수',1,'홀수') as 보너스
    FROM emp;

SELECT ename, job , DECODE(job,'SALESMAN',5000,2000) as 보너스
    FROM emp;
```

### 35.  IF문을 SQL로 구현하기 (CASE)

- 등호와 부등호 가능

```SQL
SELECT ename, job , sal , CASE    WHEN sal >= 3000 THEN 500
                                WHEN sal >= 20000 THEN 300
                                WHEN sal >= 1000 THEN 200
                                ELSE 0 END AS 보너스
    FROM emp
    WHERE job IN ('SALESMAN','ANALYST');
    
--보너스는 커미션이 NULL이면 500 NULL이 아니면 0
SELECT ename, job , comm , CASE    WHEN comm is null THEN 500
                                ELSE 0 END AS 보너스
    FROM emp
    WHERE job IN ('SALESMAN','ANALYST');

--보너스는 직업이 SALESMAN, ANALYST이면 500을 출력 CLERK,MANAGER이면 400을 출력 , 나머지는 0
SELECT ename, job , CASE    WHEN job IN('SALESMAN','ANALYST') THEN 500
                                WHEN job IN('CLERK','MANAGER') THEN 400
                                ELSE 0 END AS 보너스
    FROM emp;

                            
```

### 36. 최대값 출력하기(MAX)

```sql
--최대월급
SELECT MAX(sal)
    FROM emp;

--직업이 SALESMAN인 사원들중 최대월급
SELECT MAX(sal)
    FROM emp
    WHERE job = 'SALESMAN';
    
--에러발생 , job컬럼은 여러개이지만 MAX(sal)은 한개의 값만 나옴 따라서 GROUP BY절 필요
--GROUP BY : 데이터를 그룹핑
SELECT job ,MAX(sal)
    FROM emp
    WHERE job = 'SALESMAN';    

SELECT job, MAX(sal) --4
    FROM emp  --1
    WHERE job = 'SALESMAN' --2
    GROUP BY job; --3

--부서 번호별 최대 월급
SELECT deptno , MAX(sal)
    FROM emp
    GROUP BY deptno;
```

### 37. 최소값 출력하기(MIN)

```SQL
SELECT MIN(sal)
    FROM emp
    WHERE job ='SALESMAN';
    
SELECT job ,  MIN(sal) AS 최소값 --3
    FROM emp    --1
    GROUP BY job --2
    ORDER BY 최소값 DESC; --4
    
--그룹 함수의 특징은 WHERE절이 조건이 거짓이어도 결과를 항상 출력
--예제에서는 null출력
SELECT MIN(sal)
    FROM emp
    WHERE 1 = 2;

--직업 , 직업별 최소 월급
--직업에서 SALESMAN은 제외하고 출력
--최소 월급이 높은 것부터 출력
SELECT job , MIN(sal) 
    FROM emp
    WHERE job != 'SALESMAN'
    GROUP BY job
    ORDER BY MIN(sal) desc;
```

### 38. 평균값  출력하기(AVG)

- 그룹 함수는 NULL 값은 무시

```SQL
-- emp에는 comm이 null인 데이터가 10개 , 아닌 데이터가 4개있는데
-- null값은 무시하고 4개의 데이터의 합을 4개로 나눠줌
SELECT AVG(comm)
    FROM emp;

--null 값을 0으로
-- 14로 나누게됨
SELECT ROUND(AVG(NVL(comm,0)))
    FROM emp;
```

### 39. 토탈값 출력

```sql
-- 부서번호별 합계
SELECT deptno , SUM(sal)
    FROM emp
    GROUP BY deptno;

--직업과 직업별 토탈 월급을 출력하는데 직업별 토탈 월급이 높은 것부터 출력
SELECT job, SUM(sal) --3
    FROM emp -- 1
    GROUP BY job --2
    ORDER BY SUM(sal) desc; --4
    
--직업, 직업별 토탈 월급 출력, 직업별 토탈월급이 4000이상인것만 출력
--그룹 함수로 조건을 줄 때는 WHERE 절 대신 HAVING 절을 사용
SELECT job , SUM(sal)
    FROM emp
    WHERE SUM(sal) >= 4000
    GROUP BY job;
    
SELECT job , SUM(sal)
    FROM emp
    GROUP BY job
    HAVING SUM(sal) >= 4000;

--salesman제외 , 직업별 토탈 월급 4000이상
SELECT job , SUM(sal) --5
    FROM emp --1
    WHERE job != 'SALESMAN' --2
    GROUP BY job --3
    HAVING SUM(sal) >=4000 --4
    ORDER BY SUM(SAL) DESC; --6  
```

### 40. 건수 출력하기 (COUNT)

```SQL
--empno만 카운트
SELECT COUNT(empno)
    FROM emp;
    
--전체 행 카운트
SELECT COUNT(*)
    FROM emp;

--NULL값은 카운트하지 않음
SELECT COUNT(comm)
    FROM emp;
```

