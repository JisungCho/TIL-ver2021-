# 2021-06-17

## 코딩테스트 - String 복습 ( 1 ,2 ,3 ,4 ,5)

### 1. 문자 찾기

1. 기본 문자열을 입력받는다 소문자로 바꿔준다.
2. 찾을 문자를 입력받는다. 소문자로 바꿔준다.
3. 문자열을 문자형 배열로 바꿔준다. (toCharArray)
4. 배열을 돌면서 입력받은 문자와 같으면 answer를 1증가시켜준다.

```java
package sec01;

import java.util.Scanner;

public class Ex01 {
	public static int solution(String msg , char s) {
		int answer = 0;
		char[] arr = msg.toCharArray();
		for(char c : arr) {
			if(c == s) {
				answer++;
			}
		}
		
		return answer;
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		String msg = kb.next().toLowerCase(); // 소문자로
		char s = kb.next().toLowerCase().charAt(0); //한 글자 입력,소문자로
		
		
		System.out.println(solution(msg, s));
	}
}

```

### 2. 대소문자 변환

1. 문자열 입력
2. 문자열을 문자형 배열로 변경
3. Character.isUpperCase를 이용해서 대문자인지 확인
4. 대문자이면 toLowerCase , 소문자이면 toUpperCase

```java
package sec01;

import java.util.Scanner;

public class Ex02 {
	public static char[] solution(String msg) {
		char[] c = msg.toCharArray();
		
		for(int i=0;i<c.length;i++) {
			if(Character.isUpperCase(c[i])) {
				c[i] = Character.toLowerCase(c[i]);
			}else {
				c[i] = Character.toUpperCase(c[i]);
			}
		}
		
		return c;
	}
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		String msg = kb.next();
		
		System.out.println(solution(msg));
	}
}

```

### 3.  문장 속 단어

1. 문자열을 입력 받음
2. 문자열을 split으로 쪼개서 배열에 저장
3. 각 배열의 최고 길이를 구하면서 최고 길이를 갱신하면 해당 문자를 string 배열에 저장
4. string 출력

```java
package sec01;

import java.util.Scanner;

public class Ex03 {
	public static String solution(String msg) {
		String[] str = msg.split(" ");
		int max = Integer.MIN_VALUE;
		String answer= "";
		for(String s : str) {
			if(s.length() > max) {
				max = s.length();
				answer = s;
			}
		}
		return answer;
	}
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		String msg = kb.nextLine();
		
		System.out.println(solution(msg));
	}
}

```

### 4. 단어 뒤집기 

- StringBuffer reverse 이용
  - 쉬움

- Two Pointer 이용

```java
package sec01;

import java.util.ArrayList;
import java.util.Scanner;

public class Ex04 {
	public static ArrayList<String> solution(int n,String[] str) {
		ArrayList<String> answer = new ArrayList<>();
		for(String s : str) {
			char[] arr = s.toCharArray(); //문자형 배열로 만듬
			int lt=0; //처음 인덱스
			int rt = arr.length-1; //끝 인덱스
			while(lt < rt) {
				char tmp = arr[lt]; 
				arr[lt] = arr[rt];
				arr[rt] = tmp;
				lt++;
				rt--;
			}
			String tmp = String.valueOf(arr);
			answer.add(tmp);
		}
		return answer;
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		int n = kb.nextInt(); //크기 
		String[] str = new String[n];
		for(int i=0;i<n;i++) {
			str[i] = kb.next();
		}
		for(String x : solution(n, str)) {
			System.out.println(x);
		}
	}
}

```

### 5. 특정 문자 뒤집기

- Two Pointer를 이용해 해결

```java
package sec01;

import java.util.Scanner;

public class Ex05 {
	public static String solution(String s) {
		char[] arr = s.toCharArray();
		int lt = 0;
		int rt = arr.length-1;
		String answer ="";
		while(lt < rt) {
			if(!Character.isAlphabetic(arr[lt])){ //arr[lt]가 알파벳이 아니면
				lt++;
			}else if(!Character.isAlphabetic(arr[rt])) { // arr[rt]가 알파벳이 아니면
				rt--;
			}else { // arr[lt] 도 arr[rt]도 알파벳이면
				char c = arr[lt];
				arr[lt] = arr[rt];
				arr[rt] = c;
				lt++;
				rt--;
			}
		}
		answer = String.valueOf(arr);
		return answer;
	}
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		String s = kb.next();
		System.out.println(solution(s));
	}
}

```

## 예제로 배우는 스프링부트

### Web 기초

#### 1. 정적 리소스 사용하기

- JSP는 스프링부트에서 기본으로 지원되지 않기에 제공되는 스타터가 없다.
- 프로젝트를 생성한 후에 추가적인 설정을 해야한다

- 'Spring Web'

  스프링 MVC를 사용하는 RESTful 애플리케이션을 포함한 웹 구축을 위한 스타터이며, 톰캣을 기본 내장 컨테이너로 사용 , 웹 기능을 사용하기 위한 다양한 의존성들을 프로젝트 생성 시 자동으로 추가

- static 영역에 생성

  ![image](https://user-images.githubusercontent.com/52770718/122353133-b8ee6600-cf8a-11eb-84cd-586f28f34f55.png)

```html
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>index</title>
</head>
<body>
Hello world<br/>
안녕하세요<br/>

<img src="/image/boot.png">
</body>
</html>
```

```html
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>test</title>
</head>
<body>
	Hello (Sub)
</body>
</html>
```

#### 2. JSP 사용하기

- 실행 가능한 jar 파일로 만들었을 때 JSP가 동작하지 않는다.
- 내장 서버로 제티를 사용할 수 없다.

- JSP를 사용하기 위해 직접 의존성 패키지 추가

  ```XML
  		<!-- jstl 사용 -->
  		<dependency>
  			<groupId>javax.servlet</groupId>
  			<artifactId>jstl</artifactId>
  		</dependency>
  		<!-- 톰캣이 jsp 파일을 컴파일할 수 있도록 만들어주는 라이브러리 -->
  		<dependency>
  			<groupId>org.apache.tomcat.embed</groupId>
  			<artifactId>tomcat-embed-jasper</artifactId>
  		</dependency>
  ```

- **스프링부트에서 기본으로 제공하는 다른 템플릿 뷰들과 달리 JSP는 src/main/resources 의 템플릿 폴더를 사용할 수 없어서 사용할 폴더를 직접 만들고 지정**

  ![image](https://user-images.githubusercontent.com/52770718/122354080-9f015300-cf8b-11eb-9be0-bb95e460d9a0.png)

  ```properties
  server.port=8081
  spring.mvc.view.prefix=/WEB-INF/views/
  spring.mvc.view.suffix=.jsp
  ```

```java
package com.study.springboot;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class MyController {
	
	@RequestMapping("/")
	@ResponseBody // 리턴되는 스트링 값 자체만 웹 브라우저로 전달
	public String root() throws Exception{
		return "Jsp In MAVEN";
	}
	
    //jsp를 찾아 실행하고 그 결과를 웹 브라우저에 전달
	@RequestMapping("/test1") // localhost:8081/test1
	public String test1() {
		return "test1"; // test1.jsp
	}
	
	@RequestMapping("/test2")
	public String test2() {
		return "/sub/test2";
	}
}

```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<%
	out.println("Helloworld");
%>
</body>
</html>
```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<%
	out.println("Helloworld (Sub)");
%>
</body>
</html>
```

#### 3. 모델 사용하기

- **컨트롤러**

  **@RequestMapping 어노테이션이 적용된 메서드에서 파라미터로 모델(Model) ,  커맨드 객체 등을 받아 파라미터로 받은 객체에 데이터를 저장하고 다시 뷰에 전달해 뷰에서 데이터를 사용할 수 있게 한다.**

##### 자바 프로젝트에서 스프링의 모델 유사하게 구현하기

1. **main을 톰캣 컨테이너라 가정**
2. **요청이 오면 Map변수를 만듬**
3. **리퀘스트 맵핑에 의해 메서드를 호출하면서 메서드에 객체 변수를 넘겨준다.**
4. **리퀘스트 맵핑의 호출에 의해 실행된 메서드는 파라미터로 받은 model에 데이터를 원하는 만큼 넣을 수있다.**
5. **사용자에게 보여줄 JSP 페이지의 이름을 리턴**
6. **다시 컨테이너는 리턴 받은 정보를 이용하여 뷰를 출력하는 메서드를 호출**
7. **페이지 이름과 페이지에서 사용할 정보를 파라미터로 모두 넘겨줌**

```JAVA
package mytest;

import java.util.HashMap;
import java.util.Map;

public class ModelUse {
	public static void main(String[] args) { // 1
		Map<String, String> model = new HashMap<>();  //2 
		String sReturn = root(model); //3
		printDate(sReturn, model); //6 , 7
	}
	
	public static String root(Map<String, String> model) {
		model.put("name2", "전우치"); //4
		return "Hello"; //5
	}
	
	public static void printDate(String s, Map<String, String> model) {
		String str1 = model.get("name1");
		System.out.println(str1);
		System.out.println("WEB-INF/views/"+s+".jsp");
	}
}
```

##### 스프링의 모델 사용 예제 만들기

```JAVA
package com.study.springboot;

import java.util.ArrayList;
import java.util.List;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class MyController {
	
	@RequestMapping("/")
	@ResponseBody
	public String root() throws Exception{
		return "Model & View";
	}
	
	@RequestMapping("/test1")
	public String test1(Model model) {
		//Model 객체를 이용해서 , view로 Data전달
		// 데이터만 설정이 가능
		model.addAttribute("name","홍길동");
		
		return "test1";
	}
	
	@RequestMapping("/mv")
	public ModelAndView test2() {
		//데이터와 뷰를 동시에 설정이 가능
		ModelAndView mv = new ModelAndView();
		
		List<String> list = new ArrayList<>();
		
		list.add("test1");
		list.add("test2");
		list.add("test3");
		
		mv.addObject("lists",list);
		mv.addObject("ObjectTest","테스트입니다.");
		mv.addObject("name","홍길동");
		mv.setViewName("view/myView");
		
		return mv;
	}
}

```

- test1.jsp

  ```jsp
  <%@ page language="java" contentType="text/html; charset=UTF-8"
      pageEncoding="UTF-8"%>
  <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset="UTF-8">
  <title>Insert title here</title>
  </head>
  <body>
  <%
  	out.print("Model : Hello World" );
  %>
  <br>
  당신의 이름은 ${name}입니다.
  </body>
  </html>
  ```

- myView.jsp

  ```jsp
  <%@ page language="java" contentType="text/html; charset=UTF-8"
      pageEncoding="UTF-8"%>
  <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset="UTF-8">
  <title>Insert title here</title>
  </head>
  <body>
  <%
  	out.print("Model(Sub) : Hello World" );
  %>
  <br>
  
  ${Object }
  
  <br/>
  
  ${lists }
  
  <br/>
  <br/>
  
  <c:forEach var="mylist" items="${lists }">
  	${mylist} <br/>
  </c:forEach>
  당신의 이름은 ${name}입니다.
  </body>
  </html>
  ```

#### 4. 폼 데이터 사용하기

##### 커맨드 객체의 이해

- 데이터베이스 테이블과 관련해서  -> DTO
- 지금처럼 파라미터와 관련해서  -> 커맨드 객체

- **http 요청 파라미터의 이름으로 클래스에 setter 메서드를 만들고 이 클래스의 객체(커맨드 객체)를 메서드의 파리미터 값으로 넣어주면, 스프링은 요청 파라미터의 값을 커맨드 객체에 담는다.**
- **넘어오는 파라미터를 받을 빈의 class 타입을 정의해주면 class 타입을 보고 객체를 만든 다음 그객체에 넘어오는 파라미터 데이터를 다 담아서 주입을 해준다**

##### 스프링의 폼 사용 예제 만들기

- 커맨드 객체

  ```java
  package com.study.springboot;
  
  public class Member {
  	private String id;
  	private String name;
  	public String getId() {
  		return id;
  	}
  	public void setId(String id) {
  		this.id = id;
  	}
  	public String getName() {
  		return name;
  	}
  	public void setName(String name) {
  		this.name = name;
  	}
  	
  }
  
  ```

- 컨트롤러

  ```JAVA
  package com.study.springboot;
  
  import java.util.ArrayList;
  import java.util.List;
  
  import javax.servlet.http.HttpServletRequest;
  
  import org.springframework.stereotype.Controller;
  import org.springframework.ui.Model;
  import org.springframework.web.bind.annotation.PathVariable;
  import org.springframework.web.bind.annotation.RequestMapping;
  import org.springframework.web.bind.annotation.RequestParam;
  import org.springframework.web.bind.annotation.ResponseBody;
  import org.springframework.web.servlet.ModelAndView;
  
  @Controller
  public class MyController {
  	
  	@RequestMapping("/")
  	@ResponseBody
  	public String root() throws Exception{
  		return "Form 데이터 전달받아 사용하기";
  	}
  	
  	// Jsp/Servlet에서 사용하던 전형적인 방법
  	@RequestMapping("/test1")
  	public String test1(HttpServletRequest httpServletRequest , Model model) {
  		String id = httpServletRequest.getParameter("id");
  		String name = httpServletRequest.getParameter("name");
  		
  		model.addAttribute("id",id);
  		model.addAttribute("name", name);
  		return "test1";
  	}
  	
  	//@RequestParam으로 파라미터 변수에 직접 값을 넣어줌
  	@RequestMapping("/test2")
  	public String test2(@RequestParam("id") String id , @RequestParam("name") String name, Model model) { //파라미터가 많아지면 불편
  		
  		model.addAttribute("id",id);
  		model.addAttribute("name", name);
  		return "test2";
  	}
  	
  	//파라미터와 이름이 같은 변수를 가진 커맨드 객체를 이용하면 쉽고 간편하게 많은 데이터를 받아서 처리할 수 있다.
  	// 커맨드 객체 자체도 뷰에 전달
  	@RequestMapping("/test3")
  	public String test3(Member member , Model model) { 
  		//파라미터와 일치하는 빈을 만들어서 사용할 수 있다.
  		//View 페이지에서 model을 사용하지 않고 member를 사용한다.
  		return "test3";
  	}
  	
  	//패스 자체에 변수를 넣을 수 있다.
  	// @PathVariable
  	@RequestMapping("/test4/{studentId}/{name}")
  	public String getStudent(@PathVariable String studentId , @PathVariable String name, Model model) { 
  		model.addAttribute("id",studentId);
  		model.addAttribute("name", name);
  		return "test4";
  	}
  }
  
  ```

- test1 부터 test4.jsp

  ```jsp
  <%@ page language="java" contentType="text/html; charset=UTF-8"
      pageEncoding="UTF-8"%>
  <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset="UTF-8">
  <title>Insert title here</title>
  </head>
  <body>
  <%
  	out.print("#01 : Hello World");
  %>
  
  당신의 아이디는 ${id } 입니다.<br>
  당신의 이름은 ${name } 입니다.
  </body>
  </html>
  ```

  ```jsp
  <%@ page language="java" contentType="text/html; charset=UTF-8"
      pageEncoding="UTF-8"%>
  <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset="UTF-8">
  <title>Insert title here</title>
  </head>
  <body>
  <%
  	out.print("#02 : Hello World");
  %>
  
  당신의 아이디는 ${id } 입니다.<br>
  당신의 이름은 ${name } 입니다.
  </body>
  </html>
  ```

  ```jsp
  <%@ page language="java" contentType="text/html; charset=UTF-8"
      pageEncoding="UTF-8"%>
  <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset="UTF-8">
  <title>Insert title here</title>
  </head>
  <body>
  <%
  	out.print("#03 : Hello World");
  %>
  
  <!-- 커맨드 객체 변수의 속성값 이용 -->
  당신의 아이디는 ${member.id } 입니다.<br> 
  당신의 이름은 ${member.name } 입니다.
  </body>
  </html>
  ```

  ```jsp
  <%@ page language="java" contentType="text/html; charset=UTF-8"
      pageEncoding="UTF-8"%>
  <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset="UTF-8">
  <title>Insert title here</title>
  </head>
  <body>
  <%
  	out.print("#04 : Hello World");
  %>
  
  당신의 아이디는 ${id } 입니다.<br>
  당신의 이름은 ${name } 입니다.
  </body>
  </html>
  ```

#### 5. 롬복 사용하기

- 롬복

  자바 클래스를 만들 때 흔히 만드는 코드들을 어노테이션을 이용해서 자동으로 만들어주는 유틸리티 라이브러리

  게터, 세터, toString, equals, hashcode와 같은 메서드를 만들어줌

```java
package com.study.springboot;

import lombok.Data;

@Data
public class Member {
	private String id;
	private String name;
}

```

## 스프링입문을 위한 자바 객체지향 원리의 이해

### ISP - 인터페이스 분리 원칙

- **클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.**
  - 클래스를 분할 하는 것이 아니라  인터페이스를 이용해 역활에 따른 행동만 할 수 있도록 제한 함

![img](https://mblogthumb-phinf.pstatic.net/20151009_36/rain483_1444372396433Qj1kV_JPEG/014.jpg?type=w2)

- 프로젝트 요구사항과 설계자의 취향에 따라 SRP(단일 책임 원칙) 나 ISP(인터페이스 분할 원칙)중 하나를 선택해서 설계

- #### 특별한 경우가 아니라면 SRP(단일 책임 원칙)을 적용

#### 인터페이스 최소주의 원칙

인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공

#### 빈약한 상위 클래스 vs 풍성한 상위 클래스

![Screenshot](https://sehun-kim.github.io/sehun/assets/images/1541916340635.png)

- 상위클래스가 풍성할 수록 캐스팅이 적게 일어나서 소스코드가 깔끔해진다.

### DIP - 의존 역전 원칙

**자신보다 변하기 쉬운것에 의존하지 마라**

![Screenshot](https://sehun-kim.github.io/sehun/assets/images/1541916908016.png)

- 스노우타이어를 일반타이어로 교체할 때 자동차는 그 영향에 노출되어 있다. 

  => 자동차 자신보다 더 자주 변하는 스노우타이어에 의존하기에 부서지기 쉬움

![Screenshot](https://sehun-kim.github.io/sehun/assets/images/1541917299687.png)

- 자동차가 구체적인 타이어들이 아닌 추상화된 타이어 인터페이스만 의존하게 함으로써 스노우타이어에서 일반타이어로, 또는 다른 구체적인 타이어로 변경돼도 자동차는 이제 그 영향을 받지 않는 형태로 구성

따라서 **자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는것이 의존 역전 원칙이다.**

**상위 클래스일 수록, 인터페이스일수록 , 추상클래스일수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위클래스, 인터페이스, 추상 클래스를 통해 의존**

### SoC - 관심사의 분리

**관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모으고 , 관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지않도록 분리**

### 디자인 패턴

- 상속, 인터페이스 , 합성(객체를 속성으로 사용)을 이용

| 요리             | oop 객체지향 프로그래밍                                      |
| ---------------- | ------------------------------------------------------------ |
| 요리도구         | 객체지향 4대 특성 (Encapsulation, Abstraction, Extend, Polymorphysim 캡상추다) |
| 요리 도구 사용법 | 객체지향 설계 원칙 (SOLID - SRP, OCP, LSP, ISP, DIP)         |
| 레시피           | Design Pattern 설계 패턴                                     |

### 어댑터 패턴(Adapter Pattern)

**이미 제공되는 기능이  형태가 달라 , 필요로 하는 형태로 변경하고자 할 때 사용**

기존의 클래스를 사용해야 하나 인터페이스가 수정되어야 하는경우

기존 라이브러리 모양을 달리하여 재사용하고자 할 경우

```java
package adapter;

public class Math {
	//두배
	public static double twoTime(double num) {return num*2;}
	//절반
	public static double half(double num) {return num/2;}
	
	
	//추가된 알고리즘
	public static Double doubled(double d) {return d*2;}
}

```

```java
package adapter;

public class Main {
	public static void main(String[] args) {
		Adapter adapter = new AdapterImpl();
		System.out.println(adapter.twiceOf(100f));
		System.out.println(adapter.halfOf(88f));
	}
}

```

```java
package adapter;

public interface Adapter {
	//원하는 기능
	public Float twiceOf(Float f);
	//원하는 기능
	public Float halfOf(Float f);
}

```

```java
package adapter;

public class AdapterImpl  implements Adapter{
	
	@Override
	public Float twiceOf(Float f) {
		
		//FLOAT -> DOUBLE 바꾸고 다시 RETURN값을 FLOAT값으로 변경
		//변경해야하는 수고로움 발생
		//return (float) Math.twoTime(f.doubleValue());
		
		
		return Math.doubled(f.doubleValue()).floatValue();
	}

	@Override
	public Float halfOf(Float f) {
		return (float) Math.half(f.doubleValue());
	}

}

```

### 프록시 패턴(Proxy Pattern)

**대리인 == 다른 누군가를 대신해 그 역활을 수행하는 존재**

작업을 나눠서 구현할 수 있다.

```java
package proxy;

public class Main {
	public static void main(String[] args) {
		Subject real = new RealSubject();
		Subject proxy1 = new Proxy(real);
		Subject proxy2 = new Proxy(real);
		
		//간단한 업무 프록시
		proxy1.action1();
		proxy2.action1();

		//복잡한 업무는 실제
		proxy1.action2();
		proxy2.action2();
	}
}

```

```java
package proxy;

public interface Subject {
	//리소스가 적게 드는 일
	void action1();
	
	//리소스가 많이 드는 일 - 네트워크 , 메모리 많이사용업무
	void action2();
}

```

```java
package proxy;

public class Proxy implements Subject{
	private Subject real;
	
	public Proxy(Subject real) {
		this.real = real;
	}
	@Override
	public void action1() {
		System.out.println("간단한 업무 by 프록시");
	}

	@Override
	public void action2() {
		//복잡한 업무라서 프록시가 할 수 없다.
		//실제 객체가 처리
		this.real.action2();
		
	}

}

```

```java
package proxy;

public class RealSubject implements Subject {

	@Override
	public void action1() {
		System.out.println("간단한 업무 by 실제");
	}

	@Override
	public void action2() {
		System.out.println("복잡한 업무 by 실제");
	}

}

```