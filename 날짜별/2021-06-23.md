# 2021-06-23

## 코딩테스트 Array - 4 , 5 , 6 , 7, 8

### 4. 피보나치 수열

1. 배열을 입력된 숫자의 크기만큼 생성
2. 배열의 크기는 3이상이여야 한다. 따라서 배열 0번째와 1번째에 1을 넣어줌
3. 배열을 2번째 부터 n번째 전까지 돌면서 현재 인덱스의값을 현재 인덱스 -2번째 값과 -1번째 값을 더해준 값을 넣는다.

```java
package sec02;

import java.util.Scanner;

public class Ex04 {
	public static int[] solution(int[] arr,int n) {
		arr[0] = 1;
		arr[1] = 1;
		for(int i=2;i<n;i++) {
			arr[i] = arr[i-2] + arr[i-1];
		}
		
		return arr;
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt();
		int[] arr = new int[n];
		for(int i : solution(arr, n)) {
			System.out.print(i+" ");
		}
	}
}

```

### 5. 소수 찾기

에스토스테네스의 체

- 소수이면 소수를 저장해 놓고 그 소수의 배수를 제거

  ex ) 2이면 2 4 6 8 10 12 ....

```java
package sec02;

import java.util.Scanner;

public class Ex05 {
	static String s="";
	public static int solution(int[] arr) {
		int answer = 0;
		
		for(int i=2 ; i<arr.length;i++) {
			if(arr[i] == 0) { //소수
				answer++;
				s += i+" ";
				for(int k=i; k<arr.length; k+=i) {
					arr[k] = 1;
				}
			}
		}

		return answer;
	}
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt(); 
		int[] arr = new int[n+1];
		System.out.println(solution(arr));
		System.out.println(s);
	}
}

```

### 6. 뒤짚은 소수

1. 입력받은 값을 배열에 넣는다.
2. 배열에서 값을 꺼내서 자리를 뒤집는다
   1. res * 10 + t
3. 자리 바꾼값이 소수 인지 확인 

```java
package sec02;

import java.util.ArrayList;
import java.util.Scanner;

public class Ex06 {
	public static boolean isPrime(int num) {
		if(num == 1) return false;
		for(int i=2;i<num;i++) {
			if(num % i ==0) return false;
		}
		return true;
	}
	public static ArrayList<Integer> solution(int[] arr,int n) {
		ArrayList<Integer> answer = new ArrayList<>();
		for(int i=0;i<n;i++) {
			int res =0;
			int tmp = arr[i];
			while(tmp > 0 ) {
				int t = tmp % 10; // 1의 자리수
				res = res * 10 +t;
				tmp = tmp / 10;
			}
			if(isPrime(res)) {
				answer.add(res);
			}
		}
		return answer;
	}
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt();
		int[] arr = new int[n];
		for(int i=0;i<n;i++) {
			arr[i] = kb.nextInt();
		}
		for(int i : solution(arr, n)) {
			System.out.print(i+" ");
		}
	}
}

```

### 7. 점수 계산

1. 배열에 값을 입력받는다.
2. 배열의 앞부터 조사
   1. 1이면 count++해주고 answer에다가 값을 누적
   2. 0이면 count = 0해줌
3. answer출력

```java
package sec02;

import java.util.Scanner;

public class Ex07 {
	public static int solution(int[] arr) {
		int answer = 0;
		int count = 0;
		for(int i : arr) {
			if(i == 1) {
				count++;
				answer += count;
			}else {
				count = 0;
			}
		}
		return answer;
	}
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		int n = kb.nextInt();
		int[] arr = new int[n];
		for(int i=0;i<n;i++) {
			arr[i] = kb.nextInt();
		}
		System.out.println(solution(arr));
	}
}

```

### 8. 등수 구하기

1. 배열에 값을 입력받는다.
2. 이중for문을 돈다
   1. 첫번째 이중for문은 배열의 처음부터 끝가지
   2. 두번째 이중for문은 배열의 처음부터 끝까지
3. 첫번째 for문의 인덱스와 두번째 for문의 인덱스의 배열값을 비교해서 두번째 for문의 인덱스의 배열값이 더크면 rank++

```java
package sec02;

import java.util.ArrayList;
import java.util.Scanner;

public class Ex08 {
	public static ArrayList<Integer> solution(int[] arr,int n) {
		ArrayList<Integer> answer = new ArrayList<>();
		for(int i=0;i<n;i++) {
			int rank = 1;
			for(int j=0;j<n;j++) {
				if(arr[i] < arr[j]) rank++;
			}
			answer.add(rank);
		}
		return answer;
	}
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		int n = kb.nextInt();
		int[] arr = new int[n];
		for(int i=0;i<n;i++) {
			arr[i] = kb.nextInt();
		}
		for(int i : solution(arr, n)) {
			System.out.print(i+" ");
		}
	}
}

```

## 예제로 배우는 스프링부트 - Mybatis

### MyBatis 기초

#### MyBatis란

자바에서 데이터베이스를  사용하기 쉽게 해주는 것

- JdbcTemplate를 써도 여전히 프로그램 소스 안에 SQL문을 작성, 따라서 SQL의 변경 등이 발생할 경우 , 자바소스를 수정하고 재컴파일해야 해서 그 유연성이 좋지 못함
- MyBatis에서는 SQL을 자바 코드 외부의 XML 파일에 작성할 수 있어서 SQL의 수정이 자유롭고 , SQL문 가독성이 좋다

#### 예제

##### application.properties

- mybatis / mapper 폴더 아래의 모든 폴더( ** )의 모든 xml ( **.xml )을 매퍼로 사용한다고 지정 
- classpath : 란
  - /src/main/java/ 
    /src/main/resources/ 

```properties
#mybatis
mybatis.mapper-locations=classpath:mybatis/mapper/**/**.xml
```

##### DTO ,DAO

- **@Mapper** 

  다음 인터페이스의 구현을 xml로 한다는 의미

```JAVA
package com.study.springboot.jdbc;

import lombok.Data;

@Data
public class MyUserDTO {
	private String id;
	private String name;
}

```

```JAVA
package com.study.springboot.jdbc;

import java.util.List;

import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface IMyUserDao {
	List<MyUserDTO> list();
}

```

##### mapper구현

- **namespace** 

  이 매퍼가 어떤 인터페이스와 관련된 매퍼인지 알려줌

- **id**

  인터페이스에 정의된 메서드 이름

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  
<mapper namespace="com.study.springboot.jdbc.IMyUserDao">
	<select id="list" resultType="com.study.springboot.jdbc.MyUserDTO">
  		SELECT id , name
  			FROM myuser
  	</select>
</mapper>

```

##### 리퀘스트 맵핑

```java
package com.study.springboot;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import com.study.springboot.jdbc.IMyUserDao;

@Controller
public class MyController {
	@Autowired
	private IMyUserDao userDao;
	
	@RequestMapping("/")
	@ResponseBody
	public String root() throws Exception {
		return "Mybatis 사용하기";
	}
	
	@GetMapping("/user")
	public String userlistPage(Model model) {
		model.addAttribute("users",userDao.list());
		return "userlist";
	}
}

```

##### 뷰

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<c:forEach var="dto" items="${users }">
	${dto.id } / ${dto.name }<br/>
</c:forEach>
</body>
</html>
```

### MyBatis로 간단한 게시판 만들기

#### 예제

##### DTO,DAO,mapper추가

```java
package com.study.springboot.dto;

import lombok.Data;

@Data
public class SimpleBbsDto {
	private int id;
	private String writer;
	private String title;
	private String content;
}

```

```java
package com.study.springboot.dao;

import java.util.List;

import org.apache.ibatis.annotations.Mapper;

import com.study.springboot.dto.SimpleBbsDto;

@Mapper
public interface ISimpleBbsDao {
	public List<SimpleBbsDto> listDao();
	public SimpleBbsDto viewDao(String id);
	public int writeDao(String writer,String title,String content);
	public int deleteDao(String id);
}

```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  
<mapper namespace="com.study.springboot.dao.ISimpleBbsDao">
	<select id="listDao" resultType="com.study.springboot.dto.SimpleBbsDto">
		SELECT * 
			FROM simple_bbs
			ORDER BY id DESC
  	</select>
  	
  	<select id="viewDao" resultType="com.study.springboot.dto.SimpleBbsDto">
  		SELECT * 
  			FROM simple_bbs
  			WHERE id = #{param1}
  	</select>
  	
  	<insert id="writeDao">
  		INSERT INTO simple_bbs (writer,title,content) 
  		VALUES(#{param1},#{param2},#{param3})
  	</insert>
  	
  	<delete id="deleteDao">
  		DELETE FROM simple_bbs 
  			WHERE id = #{param1}
  	</delete>
</mapper>

```

##### 리퀘스트 맵핑

```java
package com.study.springboot;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.study.springboot.dao.ISimpleBbsDao;

@Controller
public class MyController {
	@Autowired
	private ISimpleBbsDao dao;
	
	@RequestMapping("/")
	public String root() throws Exception{
		return "redirect:list";
	}
	
	@RequestMapping("/list")
	public String userlistPage(Model model) {
		model.addAttribute("list",dao.listDao());
		return "list";
	}
	
	@RequestMapping("/view")
	public String view(@RequestParam String id , Model model) {
			model.addAttribute("dto",dao.viewDao(id));
			return "view";
	}
	
	@RequestMapping("/writeForm")
	public String writeForm() {
		return "writeForm";
	}
	
	@RequestMapping("/write")
	public String write(Model model,@RequestParam String writer,@RequestParam String title,@RequestParam String content) {
		dao.writeDao(writer, title, content);
		return "redirect:list";
	}
	
	@RequestMapping("/delete")
	public String delete(@RequestParam String id,Model model) {
		dao.deleteDao(id);
		return "redirect:list";
	}
}

```

##### 뷰

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>    
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>

<table width="500" cellpadding="0" cellspacing="0" border="1">
    <tr>
        <td>번호</td>
        <td>작성자</td>
        <td>제목</td>
        <td>삭제</td>
    <tr>
    <c:forEach items="${list}" var="dto">
    <tr>
        <td>${dto.id}</td>
        <td>${dto.writer}</td>
        <td><a href="view?id=${dto.id}">${dto.title}</a></td>
        <td><a href="delete?id=${dto.id}">X</a></td>
    <tr>
    </c:forEach>
</table>

<p><a href="writeForm">글작성</a></p>

</body>
</html>
```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>

내용보기 <br>
<hr>
작성자 : ${dto.writer} <br>
제목 : ${dto.title} <br>
내용 : ${dto.content} 
<hr>

<br><p>
<a href="list">목록보기</a>
 
</body>
</html>
```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
<br><p>

<table width="500" cellpadding="0" cellspacing="0" border="1">
    <form action="write" method="post">
    <tr>
        <td > 작성자 </td>
        <td> <input type="text" name="writer" size = "100"> </td>
    </tr>
    <tr>
        <td> 제목 </td>
        <td> <input type="text" name="title" size = "100" > </td>
    </tr>
    <tr>
        <td> 내용 </td>
        <td> <input type="text" name="content" size = "100" > </td>
    </tr>
    <tr >
        <td colspan="2"> <input type="submit" value="입력">
              &nbsp;&nbsp; <a href="list">목록보기</a></td>
    </tr>
    </form>
</table>
</body>
</html>
```

### MyBtis에서 파라미터 사용하기

##### 방법1

param1,param2,param3와 같이 param 변수 뒤의 숫자를 늘려 가면서 #{ } 사이에 적어서 사용

##### 방법2

0부터 시작하는 인덱스를 사용하여 #{ }사이에 적어 준다. 

##### 방법3

지정한 파라미터명을 사용하기 위해 @Param 어노테이션을 사용하여 이름을 지정

##### 방법4

다량의 데이터를 파라미터로 받을 때 해시맵을 사용하여 받는 방법

##### DAO , mapper에서 파라미터 부분 변경

```java
package com.study.springboot.dao;

import java.util.List;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import com.study.springboot.dto.SimpleBbsDto;

@Mapper
public interface ISimpleBbsDao {
	public List<SimpleBbsDto> listDao();
	public SimpleBbsDto viewDao(String id);
	public int writeDao(String writer,String title,String content);
	public int deleteDao(@Param("_id") String id);
}

```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  
<mapper namespace="com.study.springboot.dao.ISimpleBbsDao">
	<select id="listDao" resultType="com.study.springboot.dto.SimpleBbsDto">
		SELECT * 
			FROM simple_bbs
			ORDER BY id DESC
  	</select>
  	
  	<select id="viewDao" resultType="com.study.springboot.dto.SimpleBbsDto">
  		SELECT * 
  			FROM simple_bbs
  			WHERE id = #{0}
  	</select>
  	
  	<insert id="writeDao">
  		INSERT INTO simple_bbs (writer,title,content) 
  		VALUES(#{param1},#{param2},#{param3})
  	</insert>
  	
  	<delete id="deleteDao">
  		DELETE FROM simple_bbs 
  			WHERE id = #{_id}
  	</delete>
</mapper>

```

### MyBatis에서 쿼리 결괏값 사용하기

##### 커리 결괏값 사용하기

- **SELECT - select문에서 해당하는 결과**
- **INSERT - 1 (여러 개일 경우 에도 1)**
- **UPDATE - UPDATE된 행의 개수 반환 (없다면 0)**
- **DELETE - DELETE된 행의 개수 (없다면 0)**

#####   DAO , mapper

- #{item1} , #{item2} ... 는 해쉬맵의 키값
- 데이터 타입이 원시형인 경우는 언더바를 앞에 붙인다. ( _int , _double , _float 등등)

```java
package com.study.springboot.dao;

import java.util.List;
import java.util.Map;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import com.study.springboot.dto.SimpleBbsDto;

@Mapper
public interface ISimpleBbsDao {
	public List<SimpleBbsDto> listDao();
	public SimpleBbsDto viewDao(String id);
	public int writeDao(Map<String, String> map);
	public int deleteDao(@Param("_id") String id);
	public int articleCount();
}

```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  
<mapper namespace="com.study.springboot.dao.ISimpleBbsDao">
	<select id="listDao" resultType="com.study.springboot.dto.SimpleBbsDto">
		SELECT * 
			FROM simple_bbs
			ORDER BY id DESC
  	</select>
  	
  	<select id="viewDao" resultType="com.study.springboot.dto.SimpleBbsDto">
  		SELECT * 
  			FROM simple_bbs
  			WHERE id = #{0}
  	</select>
  	
  	<insert id="writeDao">
  		INSERT INTO simple_bbs (writer,title,content) 
  		<!-- #{ 해쉬맵의 키 } -->
  		VALUES(#{item1},#{item2},#{item3})
  	</insert>
  	
  	<delete id="deleteDao">
  		DELETE FROM simple_bbs 
  			WHERE id = #{_id}
  	</delete>
  	
  	<select id="articleCount" resultType="_int">
  		SELECT COUNT(*) 
  			FROM simple_bbs
  	</select>
</mapper>

```

#####  컨트롤러

```java
package com.study.springboot;

import java.util.HashMap;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.study.springboot.dao.ISimpleBbsDao;

@Controller
public class MyController {
	@Autowired
	private ISimpleBbsDao dao;
	
	@RequestMapping("/")
	public String root() throws Exception{
		return "redirect:list";
	}
	
	@RequestMapping("/list")
	public String userlistPage(Model model) {
		model.addAttribute("list",dao.listDao());
		
		int total = dao.articleCount();
		System.out.println("Count : "+total);
		
		return "list";
	}
	
	@RequestMapping("/view")
	public String view(@RequestParam String id , Model model) {
			model.addAttribute("dto",dao.viewDao(id));
			return "view";
	}
	
	@RequestMapping("/writeForm")
	public String writeForm() {
		return "writeForm";
	}
	
	@RequestMapping("/write")
	public String write(Model model,@RequestParam String writer,@RequestParam String title,@RequestParam String content) {
		Map<String, String> map = new HashMap<String, String>();
		
		map.put("item1", writer);
		map.put("item2", title);
		map.put("item3",content);
		
		int result = dao.writeDao(map);
		//insert되었으면 1
		System.out.println("write : "+result);
		
		return "redirect:list";
	}
	
	@RequestMapping("/delete")
	public String delete(@RequestParam String id,Model model) {
		dao.deleteDao(id);
		return "redirect:list";
	}
}

```

### MyBatis로 SQL 로그 출력하기

##### 스프링 부트와 로깅

- 스프링 부트는 logback을 기본적인 로깅 시스템으로 지원
- 로깅 커스터마이징을 사용할 경우 스프링 부트에서는 logback-spring.xml을 사용

##### 예제

###### 로깅 설정 파일

- src / main / resources 에 logback-spring.xml을 추가
  - apeender에서 지정하는 클래스에 따라 로그의 출력 방법을 콘솔이나 파일, 데이터베이스,메일 등으로 정할 수 있다.
    - 현재는 콘솔에 출력하기 위한 클래스를 지정하고 어펜더의 이름은 console
  - pattern에서는 출력되는 패턴을 지정
  - 20라인에서 로그를 출력하기 위해 전체적으로 참조하는 레벨을 오프 상태
  - 21라인에서 출력할 대상의 이름은 console로 지정
  - 9라인부터 18라인 까지는 개별적으로 출력할 대상과 출력 레벨을 정함

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <Pattern>[%d{yyyy-MM-dd HH:mm:ss}:%-3relative] [%thread] %-5level %logger{36} - %msg%n</Pattern>
        </encoder>
    </appender>

    <logger name="com.study.springboot" level="info"/>

    <!-- log4j2-jdbc4 -->
    <logger name="jdbc" level="OFF" />
    <logger name="jdbc.sqlonly" level="OFF" />
    <logger name="jdbc.sqltiming" level="DEBUG" />
    <logger name="jdbc.resultset" level="OFF" />
    <logger name="jdbc.resultsettable" level="DEBUG" />
    <logger name="jdbc.connection" level="OFF" />
    <!-- log4j2-jdbc4 -->
    
    <root level="off">
        <appender-ref ref="console"/>
    </root>
</configuration>
```

- log4jdbc.log4j2.properties추가

```
log4jdbc.spylogdelegator.name=net.sf.log4jdbc.log.slf4j.Slf4jSpyLogDelegator
log4jdbc.dump.sql.maxlinelength=0
```

- pom.xml 추가

```xml
		<dependency>
			<groupId>org.bgee.log4jdbc-log4j2</groupId>
			<artifactId>log4jdbc-log4j2-jdbc4.1</artifactId>
			<version>1.16</version>
		</dependency>
```

- application.properties수정

```properties
server.port=8081
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp

#mariadb 설정
spring.datasource.driverClassName = net.sf.log4jdbc.sql.jdbcapi.DriverSpy
spring.datasource.url = jdbc:log4jdbc:mariadb://localhost:3307/testdb
spring.datasource.username=root
spring.datasource.password=1234

#mybatis
mybatis.mapper-locations=classpath:mybatis/mapper/**/**.xml

```

## SQL200제 70번 - 78번

### 70. 집합 연산자로 데이터의 차이를 출력하기 (MINUS)

MINUS 연산자를 이용하여 MINUS연산자 위쪽 쿼리의 결과 데이터에서 MINUS 아래쪽 쿼리의 결과 데이터의 차이를 출력

```SQL
SELECT ename , sal , job , deptno
    FROM emp
    WHERE deptno IN (10,20)
MINUS
SELECT ename , sal , job , deptno
    FROM emp
    WHERE deptno IN (20,30);
```

| 집합 연산자 | 결과 데이터 정렬 | 중복 제거 |
| ----------- | ---------------- | --------- |
| UNION ALL   | X                | X         |
| UNION       | O                | O         |
| INTERSECT   | O                | O         |
| MINUS       | O                | O         |

### 71. 서브 쿼리 사용하기 (단일행 서브쿼리)

```sql
--JONES의 sal보다 sal값이 큰 사원의 이름과 , sal
--메인쿼리
SELECT ename, sal
    FROM emp
    WHERE sal > ( SELECT sal --서브쿼리
                    FROM emp
                    WHERE ename = 'JONES'
                );
```

### 72. 서브 쿼리 사용하기 (다중 행 서브쿼리)

- 서브 쿼리에서 메인 쿼리로 하나의 값이 아니라 여러 개의 값이 반환되는것을 다중 행 서브 쿼리

```SQL
SELECT ename , sal
    FROM emp
    WHERE sal In (SELECT sal 
                    FROM emp
                    WHERE job = 'SALESMAN'
                    );
```

| 종류                | 설명                                               |
| ------------------- | -------------------------------------------------- |
| 단일 행 서브 쿼리   | 서브 쿼리에서 메인 쿼리로 하나의 값이 반환         |
| 다중 행 서브 쿼리   | 서브 쿼리에서 메인 쿼리로 여러 개의 값이 반환      |
| 다중 컬럼 서브 쿼리 | 서브 쿼리에서 메인 쿼리로 여러 개의 컬럼 값이 반환 |

| 종류              | 연산자                                 |
| ----------------- | -------------------------------------- |
| 단일 행 서브 쿼리 | = , != , > , < , >= , <=               |
| 다중 행 서브 쿼리 | IN , NOT IN , >ANY ,<ANY , >ALL , <ALL |

### 73. 서브 쿼리 사용하기 (NOT IN)

- NOT IN을 사용할 경우 서브 쿼리에서 메인 쿼리로 NULL 값이 하나라도 리턴되면 결과가 출력되지 않는다.

```SQL
--자기 밑에 직속 부하 사원이 한 명도 없는 사원들을 출력하는 쿼리
SELECT ename , sal , job
    FROM emp
    WHERE empno NOT IN( SELECT mgr
                            FROM emp
                            WHERE mgr IS NOT NULL );
```

### 74. 서브 쿼리 사용하기 (EXISTS 와 NOT EXISTS)

- **EXISTS(**서브 쿼리**)**는 서브 쿼리의 결과가 ***"한 건이라도 존재하면"*** **TRUE** 없으면 **FALSE**를 리턴한다.

- 테이블 A가 존재하는 데이터가 테이블 B에 존재하는지 여부를 확인할 때 EXISTS 또는 NOT EXISTS를 사용
- WHERE 절 바로 다음에 EXISTS문을 작성

```SQL
--DEPT 테이블에 존재하는 부서번호가 EMP 테이블에서도 존재하는 검색
SELECT *
    FROM dept d
    WHERE EXISTS ( SELECT *
                    FROM emp e
                    WHERE e.deptno = d.deptno);
```

```SQL
-- e에서 e.deptno 와 d.deptno가 같지 않은 행을 출력 
SELECT *
    FROM dept d
    WHERE NOT EXISTS ( SELECT *
                    FROM emp e
                    WHERE e.deptno = d.deptno);
```

### 75. 서브 쿼리 사용하기(HAVING 절의 서브 쿼리)

**그룹 함수로 검색 조건을 작성할 때는 WHERE 절을 사용할 수 없고 HAIVNG절을 사용**

```SQL
--emp에서 직업별로 묶어서 
--직업별로 sal의 합을 직업이 SALESMAN인 사람들이 sal합이랑 비교해서 크면 출력
SELECT job , SUM(sal)
    FROM emp
    GROUP BY job
    HAVING sum(sal) > (SELECT SUM(sal)
                        FROM emp
                        WHERE job = 'SALESMAN');
```

### 76 .서브쿼리 사용하기 (FROM절의 서브 쿼리)

- FROM 절의  서브 쿼리를 in line viewfkrh gksek
- WHERE절에는 분석 함수를 사용할 수 없다.

```SQL
-- emp에서 sal가 높은순으로 순위를 매겨서 출력한 데이터 v로 부터 v.순위가 1인 행의 ename , sal , 순위를 출력
SELECT v.ename , v.sal , v.순위
    FROM (
            SELECT ename , sal , rank() over (order by sal desc) 순위 
                FROM emp ) v
    WHERE v.순위 = 1;
```

### 77. 서브 쿼리 사용하기 (SELECT 절의 서브 쿼리)

- SELECT절의 서브 쿼리는 서브 쿼리가 SELECT 절로 확장되었다고 해서 **스칼라 서브 쿼리**라고 불림

- 스칼라 서브 쿼리는 출력되는 행 수 만큼 반복되어 실행
- 메모리에 올려 놓고 메모리에 올려놓은 데이터를 출력하는 **서브 쿼리 캐싱**이 발생

```SQL
SELECT ename , sal, (SELECT MAX(sal) FROM emp WHERE job = 'SALESMAN') as 최대월급 , (SELECT MIN(sal) FROM emp WHERE job = 'SALESMAN') as 최소월급
    FROM emp
    WHERE job = 'SALESMAN';
```

### 78. 데이터 입력하기 (INSERT)

- INSERT INTO 다음에 입력하고자 하는 테이블명을 작성
- 괄호를 열어 데이터를 컬럼명 순서대로 기술
- 괄호를 쓰지않는다면 전체 컬럼에 모두 데이터를 입력해줘야함
- VALUES다음에 입력하고자 하는 데이터 값을 괄호에 작성했던 컬럼 순서대로 기술
  - 숫자는 그대로 기술
  - 문자와 날짜는 싱글 쿼테이션마크로 기술
  - 날짜를 입력할 때는 TO_DATE 변환 함수를 사용함
- NULL은 직접 기술하거나, 싱글 쿼테이션 마크를 공백 없이 붙여주어 입력
- 데이터를 입력하고 수정하고 삭제하는 SQL문을 DML문이라고 함
  - INSERT
  - UPDATE
  - DELETE
  - MERGE - 입력 수정 삭제를 한번에 수행

