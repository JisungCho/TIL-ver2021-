# 2021-07-01

## 코딩테스트 - Array

### 시험에 나오는 개념

1. Math.max(max,a)
2. Map + Array
3. array + stack
4. sum + = sum + num[ ]

### 두개 합(TwoSum)

1. 문제분석
   1. 정수 배열
   2. 정답은 무조건 1개
   3. 동일한 요소 사용 안함
2. 규칙찾기
   1. for문돌려서 target과 비교
   2. 16-2 = 11
   3. Map(숫자,방번호)확인
   4. 방번호만 리턴

```java
package sec03;

import java.util.HashMap;
import java.util.Map;

public class TwoSum {
	public static int[] solve(int[] nums,int target){
		
        // 1.ds
        Map<Integer, Integer> map = new HashMap<>();
		int[] result = new int[2];
		
        
        //2. for while
		for(int i=0;i<nums.length;i++) {
			if(map.containsKey(nums[i])) {
				result[0] = map.get(nums[i]) + 1;
				result[1] = i+1;
			}else {
				map.put(target-nums[i], i);
			}
		}
		return result;
	}
	public static void main(String[] args) {
		int[] nums = { 2,8,11,14};
		int target = 16;
		
		int[] answer = solve(nums, target); 
		for(int n : answer) {
			System.out.print(n+" ");
		}
	}
}

```

### 일일온도

1. 문제분석
   1. for문을 돌린다
   2. 73이 나온 상태에서 74를 만나야 되는 상황
   3. 73과 74를 비교해서 73<74이니까 인덱스의 차이 1을 결과값에 저장
2. 코딩화
   1. 2중FOR
      1. for문을 돌린다
      2. 75가 나온 시점에 71,69,72,76을 만나야 되는 상황 
         75보다 큰게 나올때까지 while문을 실행
         while문을 빠져나오는 시점, max-i가 됨
   2. stack사용
      1. for문을 돌리면서 0부터 인덱스를 스택에 저장하다가
      2. 1번방을 만나서 비교 73<74을 만나는 시점에 
      3. 인덱스를 이용(1-0) 1을 결과에 저장

### SubArray 최대값 (Maximum SubArray)

1. 문제분석

   1. Max(현재값 + 이전까지누적한값 , 현재값)
   2. Max(지금max값 , 이전까지 max값)

2. 코딩화

   ```java
   		// 현재 값과 현재값까지 누적한 값을 비교해서 현재값이 크면 누적했던 값을 버리고 현재 값으로 curmax를 설정
   		curMax = Math.max(curMax+nums[i],nums[i]);
   		//curmax값들중에 가장 큰 값
   		allMax = Math.max(curMax,allMax);
   ```

```java
package sec03;

public class MaxSubArray {
	public static void main(String[] args) {
		int[] nums = {-2,1,-3,4,-1,2,1,-5,4};
		System.out.println(solve(nums));
	}
	public static int solve(int[] nums) {
		//1 .ds
		int curMax = nums[0]; 
		int allMax = nums[0]; 
		
		for(int i=1;i<nums.length;i++) {
			// 현재 값과 현재값까지 누적한 값을 비교해서 현재값이 크면 누적했던 값을 버리고 현재 값으로 curmax를 설정
			curMax = Math.max(curMax+nums[i],nums[i]);
			//curmax값들중에 가장 큰 값
			allMax = Math.max(curMax,allMax);
		}
		return allMax;
		
	}
}

```

### 그룹 아나그램(Group Anagrams)

1. 문제분석

   1. map의 key value를 이용해서 분류

2. 코딩화

   1. sort

      1. 키 값은 고유하게

         for loop를 이용해서 한 개의 String으로 뺀후 toCharArray를 이용해서 sort한 후 키로 이동

      2. Map을 이용해서 key,value

   2. 배열 이용

      1. 키 값을 int[26]배열로 만들어서 해당 char - 'a'뺀것을 인덱스로 사용하여 배열로 고유한 값을 지정

```java
package sec03;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class GroupAnagrams_solve {
	//1.sort 
	public static List<List<String>> solve_sort(String[] strs) {
		//1
		if(strs ==null || strs.length==0) {
			return new ArrayList<List<String>>();
		}
		Map<String, List<String>> map = new HashMap<String, List<String>>();
		
		//2.
		for(String str : strs) {
			char[] charArr = str.toCharArray();
			Arrays.sort(charArr); // eat -> aet
			
			String key = String.valueOf(charArr);
			
			/*
			if(map.containsKey(key)) {
				map.get(key).add(str);
			}else {
				List<String> list = new ArrayList<String>();
				list.add(str);
				map.put(key, list);
			}
			*/
			List<String> list =  map.getOrDefault(key, new ArrayList<String>());
			list.add(str);
			map.put(key, list);
			
		}
		return new ArrayList<List<String>>(map.values());
	}
	
	//2. not sort
	public static List<List<String>> solve(String[] strs) {
		Map<String, List<String>> map = new HashMap<String, List<String>>();
		List<List<String>> result = new ArrayList<List<String>>();
		
		for(String str : strs) {
			int[] count = new int[26]; // a-z까지
			for(int k=0;k<str.length();k++) {
				count[str.charAt(k)-'a']++;// [0,0,0,..... ] 26개
			}
			String key  = Arrays.toString(count);
			System.out.println(key);
			List<String> list =  map.getOrDefault(key, new ArrayList<String>());
			list.add(str);
			map.put(key, list);
		}
		return new ArrayList<List<String>>(map.values());
	}

	public static void main(String[] args) {
		String[] strs = {"eat","tea","tan","ate","nat","bat"};

		System.out.println(solve_sort(strs));
		System.out.println(solve(strs));
		
	}
}

```

## SQL 93부터 99

### 93. 일반테이블 생성 (CREATE TABLE)

```SQL
CREATE TABLE emp01 (
    empno number(10),
    ename varchar2(10),
    sal number(10,2),
    hiredate date
);
```

### 94. 임시 테이블 생성하기 (CREATE TEMPORARY TABLE)

```SQL
CREATE GLOBAL TEMPORARY TABLE emp37 (
    empno number(10),
    ename varchar2(10),
    sal number(10,2))
ON COMMIT DELETE ROWS;

INSERT INTO emp37 VALUES (1111,'scott',3000);
INSERT INTO emp37 VALUES (2222,'smith',4000);

select * from emp37;

commit; --없어짐

select * from emp37;
```

- ON COMMIT DELETE ROWS 

  임시 테이블에 데이터를 입력하고 COMMIT 할 때까지만 데이터를 보관

- ON COMMIT PRESERVE ROWS

  임시 테이블에 데이터를 입력하고 세션이 종료될 때까지 데이터를 보관

### 95. 복잡한 쿼리를 단순하게 하기(VIEW)

```SQL
CREATE VIEW EMP_VIEW
AS
SELECT empno , ename , sal , job, deptno
    FROM emp
    WHERE job='SALESMAN';
   
SELECT * 
    FROM emp_view;
    
        
SELECT * 
    FROM emp_view;
```

- CREATE VIEW 뷰 이름 다음에 AS 이후에 뷰를 통해 통해 보여줘야 할 쿼리를 작성
- VIEW는 보안상 공개하면 안 되는 데이터들이 있을 때 유용
- VIEW를 변경하면 실제 테이블도 변경됨
  - WHY ) VIEW는 데이터를 가지고 있지 않고 단순히 테이블을 바로 보는 객체기 때문에 뷰를 쿼리하면 뷰를 만들 때 작성했던 쿼리문이 수행

