# 2021-06-15

## 코딩테스트 - Greedy Algorithm , Dynamic Programming

### 최소 스패닝 트리

- 그래프에서 트리를 뽑아내는데 트리의 가중치 값이 최소가 되도록
- 그래프 vs 트리
  - 그래프 : 돌아오는 회로가 존재
  - 트리 : 돌아온느 회로가 존재하지 않는다.

### 7. 원더랜드(크루스칼 : Uion&Find)

- 크루스칼 알고리즘 - Union & Find

1. Edge라는 클래스를 만들어서 v1 , v2 , cost 로 필드설정
   - v1은 정점
   - v2 정점
   - cost는 유지비용
2. ArrayList를 유지비용값이 오름차순이 되도록 정렬
3. Greedy Algorithm을 이용해 cost가 작은 값을 선택
4. 간선으로 연결 
   - 간선으로 연결할 때 Find한게 서로 같으면 같은 그룹이므로 패스
   - Find한게 다르면 Union해줌

![image](https://user-images.githubusercontent.com/52770718/122000441-c8827900-cde9-11eb-9d2f-9d5c23d98f9d.png)

```java
package sec09;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;
class Edge implements Comparable<Edge>{
	int v1;
	int v2;
	int cost;
	public Edge(int v1, int v2, int cost) {
		this.v1 = v1;
		this.v2 = v2;
		this.cost = cost;
	}
	@Override
	public int compareTo(Edge o) {
		return this.cost - o.cost;
	}
	
}

public class Ex07 {
	public static int unf[];
	public static void union(int a,int b) {
		int fa = Find(a);
		int fb = Find(b);
		if(fa!=fb) unf[fa]=fb;
	}
	public static int Find(int a) {
		if(a == unf[a]) return a;
		else return unf[a] = Find(unf[a]);
	}
	
	public static int solution(ArrayList<Edge> arr,int e) {
		Collections.sort(arr); // 오름차순 정렬
		int answer = 0;
		for(Edge ob : arr) {
			int v1 = ob.v1;
			int v2 = ob.v2;
			if(Find(v1) != Find(v2)) { //같은 그룹이 아니면
				union(v1,v2); //그룹화
				answer += ob.cost; //코스트를 더해줌
			}
		}
		return answer;
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		int v = kb.nextInt(); //도시의 개수 
		int e = kb.nextInt(); //도로의 개수
		
		unf = new int[v+1];
		ArrayList<Edge> roads = new ArrayList<>();
		for(int i=1;i<=v;i++) unf[i] = i; //도시를 도시번호로 그룹핑
		for(int i=0;i<e;i++) {
			int v1 = kb.nextInt();
			int v2 = kb.nextInt();
			int cost = kb.nextInt();
			roads.add(new Edge(v1, v2, cost));
		}
		System.out.println(solution(roads, e));
	}
}

```

### 8. 원더랜드(프림 : PriorityQueue)

- 프림 - Priority Queue

1. 인접리스트로 그래프 표현
2. pQ생성 - pQ는 현재 만들고 있는 트리의 연결된 점들에서 뻗어나갈 수 있는 간선들을 표현
3. 임의한점 선택(1,0)
4. ch배열 생성 - ch는 트리로 연결된 정점인지 확인

![image](https://user-images.githubusercontent.com/52770718/122001086-bf45dc00-cdea-11eb-9141-1b614bda501d.png)

```java
package sec09;

import java.util.*;

class Edge2 implements Comparable<Edge2>{
    public int vex; //도착하는 정점
	public int cost; //비용
    Edge2(int vex, int cost) {
        this.vex = vex;
        this.cost = cost;
    }
    @Override
    public int compareTo(Edge2 ob){
        return this.cost-ob.cost; //오름차순
    }
}
public class Ex08 {
	public static void main(String[] args){
		Scanner kb = new Scanner(System.in);
		int n=kb.nextInt(); //정점
		int m=kb.nextInt(); //간선의 수
		ArrayList<ArrayList<Edge2>> graph = new ArrayList<ArrayList<Edge2>>(); //인접리스트
		for(int i=0; i<=n; i++){ // 정점의 수 +1만큼 인접리스트 만듬
			graph.add(new ArrayList<Edge2>());
		}
		int[] ch=new int[n+1]; // 이미 연결된 트리인지 확인하는 배열
		for(int i=0; i<m; i++){
			int a=kb.nextInt();
			int b=kb.nextInt();
			int c=kb.nextInt();
			//무방향이기 때문에
			graph.get(a).add(new Edge2(b, c)); // a에서 b로가는 비용이 c
			graph.get(b).add(new Edge2(a, c)); // b에서 a로가는 비용이 c
		}
		int answer=0;
		PriorityQueue<Edge2> pQ = new PriorityQueue<>();
		pQ.offer(new Edge2(1, 0)); // 초기 임의의점 (1,0) 
		while(!pQ.isEmpty()){
			Edge2 tmp=pQ.poll(); //cost가 최소인것을 poll
			int ev=tmp.vex; //도착 정점
			if(ch[ev]==0){ // 체크 안되있으면
				ch[ev]=1; // 체크하고
				answer+=tmp.cost;
				for(Edge2 ob : graph.get(ev)){ //인접리스트 불러옴
					if(ch[ob.vex]==0) pQ.offer(new Edge2(ob.vex, ob.cost)); //이미 트리에 연결되어있지 않으면
				}
			}
		}
		System.out.println(answer);
	}
}

```

### Dynamic Programming 

복잡도가 큰 문제를 복잡도가 작은 문제로 나누어서 푸는 방법

### 1. 계단오르기

1. 방법의 수를 담을 dy배열 생성
2. 계단이 1개일 때 방법의 수
3. 계단이 2개일 때 방법의 수
4. 계단이 3개일 때는  계단이 2개일 때 방법의 수 + 계단이 1개일 때 방법의 수
5. 따라서 피보나치

```java
package sec10;

import java.util.Scanner;

public class Ex01 {
	static int[] dy;
	public static int solution(int n) {
		dy[1] = 1;
		dy[2] = 2;
		for(int i = 3;i<=n;i++) {
			dy[i] = dy[i-2]+dy[i-1];
		}
		return dy[n];
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt(); //계단 수
		dy = new int[n+1];
		System.out.println(solution(n));
	}
}

```

### 2.돌다리 건너기

1. 방법의 수를 담을 dy배열 생성
2. 돌다리가 1개일 때
3. 돌다리가 2개일 때 방법의 수
4. 돌다리가 3개일 때는  돌다리가 2개일 때 방법의 수 + 돌다리가 1개일 때 방법의 수
5. 따라서 피보나치
6. 마지막에 도착하는 지점도 하나의 돌다리라고 생각

```java
package sec10;

import java.util.Scanner;

public class Ex02 {
	static int[] dy;
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt(); //돌다리수
		dy = new int[n+2]; // 1부터사용 , 도착지점 추가
		System.out.println(solution(n));
	}
	 static int solution(int n) {
		 dy[1] = 1;
		 dy[2] = 2;
		 for(int i=3;i<=n+1;i++) {
			 dy[i] = dy[i-2]+dy[i-1];
		 }
		 return dy[n+1]; // 도착지점
	 }
	 
}

```

## SQL 200제 56번부터 62번

### 56. 출력되는 행 제한하기 (ROWNUM)

ROWNUM은 PSEUDO COLLUMN 으로 '가짜의'라는 뜻 그대로 별표(*)로 검색해서는 출력되지 않는 감춰진 컬럼

```sql
--맨 위의 5개의 행만 출력
--사원 테이블 전체를 다 읽지 않고 5개의 행만 가져옴
SELECT ROWNUM , empno , ename , job , sal
    FROM emp
    WHERE ROWNUM <=5;
    
```

### 57. 출력되는 행 제한하기 (Simple TOP-n Queries)

oracle 12c 부터 지원

TOP-N Query : 정렬된 결과로부터 위쪽 또는 아래쪽의 N개의 행을 반환하는 쿼리

```SQL
--월급이 높은 사원들중에 4개의 행만 출력
SELECT empno , ename , job , sal
 FROM emp
 ORDER BY sal DESC
 FETCH FIRST 4 ROWS ONLY;

--월급이 높은 사원들중 20퍼센트 해당하는 사원들만 출력
SELECT empno , ename ,  job , sal
    FROM emp
    ORDER BY sal desc
    FETCH FIRST 20 PERCENT ROWS ONLY;
    
-- WITH TIES : 여러 행이  N번째 행의 값과 동일하다면 같이 출력
-- 실제로 동일한게있으면 2개의 행이 아니라 더 많이 나오게됨
SELECT empno ,  ename , job , sal
    FROM emp
    ORDER BY sal DESC 
    FETCH FIRST 2 ROWS WITH TIES;
    
--OFFEST : 출력이 시작되는 행의 위치를 지정
-- 10번째 행부터 출력
SELECT empno, ename , job , sal
    FROM emp
    ORDER BY sal DESC
    OFFSET 9 ROWS;

-- 월급이 높은 사원을 10번째 행부터 출력하는데 2개만출력 따라서 10,11
SELECT empno , ename , job, sal
    FROM emp
    ORDER BY sal DESC
    OFFSET 9 ROWS
    FETCH FIRST 2 ROWS ONLY;
```

### 58. 여러 테이블의 데이터를 조인해서 출력하기(EQUI JOIN)

- EQUI JOIN
  - 조인 조건이 이퀄이면 EQUI JOIN

```SQL

SELECT ename , loc
    FROM emp , dept --ename은 emp에 존재 , loc는 dept에 존재 ename과 loc를 하나의 결과로 출력하기 위해서는 from절에 emp,dept둘다 기술
    WHERE emp.deptno = dept.deptno; -- 조인 조건

--전부다 가져옴    
SELECT ename , loc
    FROM emp , dept;
    
-- 부서번호가 같고 Job이 ANALYST인 행을 출력
SELECT ename , sal , job
    FROM emp , dept
    WHERE emp.deptno = dept.deptno and emp.job= 'ANALYST';

--오류발생
-- deptno 는 emp에도 있고 dept에도 있기 때문에 어느 테이블에 있는 deptno를 출력할건지 모름
SELECT ename , sal , job , deptno
    FROM emp , dept
    WHERE emp.deptno = dept.deptno and emp.job= 'ANALYST';

--가급적 테이블 이름을 붙여줌
SELECT emp.ename , dept.loc , emp.job
    FROM emp , dept
    WHERE emp.deptno = dept.deptno and emp.job= 'ANALYST';
    
--테이블 별칭을 사용하여 조인 코드를 간결하게 작성
SELECT e.ename , d.loc , e.job
    FROM emp e , dept d
    WHERE e.deptno = d.deptno and e.job= 'ANALYST';
```

### 59. 여러 테이블의 데이터를 조인해서 출력하기 (NON EQUI JOIN)

-  이퀄 조건이 아닌 경우 BETWEEN AND 연산자를 이용한 NON EQUI JOIN

```sql

-- emp와 salgrade를 조인해서 emp의 sal값이 salgrade의 losal과 hisal 사이의 값인 것을 추력
SELECT e.ename , e.sal , s.grade
    FROM emp e , salgrade s
    WHERE e.sal BETWEEN s.losal and s.hisal;
    


```

### 60. 여러 테이블의 데이터를 조인해서 출력하기 (OUTER JOIN)

- EQUI JOIN으로는 볼 수 없는 결과 데이터를 출력하기 위해서 사용

- OUTER JOIN은 기존 EQUI JOIN 문법에 OUTER 조인 사인 (+) 만 추가

```SQL
-- RIGHT OUTER JOIN : 양쪽다 존재하는 데이터를 출력하면서 DEPT 테이블에는 존재하고 EMP테이블에는 존재하지 않는 데이터도 출력
SELECT e.ename , d.loc
    FROM emp e, dept d
    WHERE e.deptno (+) = d.deptno;

-- LEFT OUTER JOIN : 양쪽다 존재하는 데이터를 출력하면서 DEPT 테이블에는 존재하지않고 EMP테이블에는 존재하는 데이터도 출력
SELECT e.ename , d.loc
    FROM emp e, dept d
    WHERE e.deptno = d.deptno(+);
```

### 61. 여러 테이블의 데이터를 조인해서 출력하기 (SELF JOIN)

- 자기 자신의 테이블과 조인하기 위해서 사용

```SQL
SELECT e.ename as 사원 , e.job as 직업 , m.ename as 관리자 , m.job as 직업
    FROM emp e, emp m
    WHERE e.mgr = m.empno and e.job = 'SALESMAN';
```

### 62. 여러 테이블의 데이터를 조인해서 출력하기 (ON절)

- WHERE절 대신 ON 절을 사용하여 ANSI 조인

```SQL
SELECT e.ename as 이름 , e.job as 직업 , e.sal as 월급 , d.loc as 부서위치
    FROM emp e
    JOIN dept d 
    ON(e.deptno = d.deptno)
    WHERE e.job = 'SALESMAN';
```

