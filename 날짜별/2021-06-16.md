# 2021-06-16

## 코딩테스트 - DP

### **최장 증가 부분 수열(LIS, Longest Increasing Subsequence)란?**

원소가 n개인 배열의 일부 원소를 골라내서 만든 부분 수열 중, 각 원소가 이전 원소보다 크다는 조건을 만족하고, 그 길이가 최대인 부분 수열을 최장 증가 부분 수열이라고 합니다.

- 예를 들어, { 6, **2**, **5**, 1, **7**, 4, **8**, 3} 이라는 배열이 있을 경우, LIS는 { 2, 5, 7, 8 } 이 됩니다.
- { 2, 5 }, { 2, 7 } 등 증가하는 부분 수열은 많지만 그 중에서 가장 긴 것이 { 2, 5, 7, 8 } 입니다.

### 3. 최대부분증가수열(LIS)

![image](https://user-images.githubusercontent.com/52770718/122163335-fd590380-ceaf-11eb-9ba8-180516fc1301.png)

- 순서를 유지하면서 뽑는다

1. 수열을 배열에 입력받는다.
2. dy배열을 만든다.
   - dy[i] 의 의미 : 수열에서 i번째 숫자를 마지막 숫자로하는 최대증가 수열의 길이
3. dy[0]을 생각해봄
   - 5 / 한가지
4. dy[1]
   - 3 / 한가지
5. dy[2]
   - { 3 or 5 , 7}  / 두 가지
6. dy[3]
   - dy[2] + 1 = 3 , dy[1] + 1= 2 , dy[0] + 1 = 2 
     - 따라서 dy[2] + 1 = 3

```java
package sec10;

import java.util.Scanner;

public class Ex03 {
	static int[] dy;
	public static int solution(int[] arr , int[] dy, int n) {
		int answer = 0;
		dy[0] = 1;
		for(int i=1;i<n;i++) {
			int max = 0;
			for(int j=i-1;j>=0;j--) {
				if(arr[j] < arr[i] && dy[j] > max) { // 숫자가 작고 , 바로 앞의 항들중에서 최대 길이 
					max = dy[j];
				}
			}
			dy[i] = max+1;
			answer = Math.max(answer, dy[i]);
		}
		
		return answer;
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		int  n = kb.nextInt(); // 입력되는 데이터의 수
		int[] arr = new int[n];
		dy = new int[n];
		for(int i=0;i<n;i++) {
			arr[i] = kb.nextInt();
		}
		System.out.println(solution(arr, dy,n));
	}
}

```

### 4. 가장 높은 탑 쌓기(LIS 응용)

![image](https://user-images.githubusercontent.com/52770718/122169842-d81cc300-ceb8-11eb-86b6-c029ba3014ff.png)

1. brick이라는 클래스를 만들어서 넓이 높이 무게 속성을 만듬
2. brick클래스를 arraylist에 넣고 넓이에 내림차순 정렬
3. dy배열 : dy[i] 는 i번째 벽돌이 제일 위의 벽돌로 쌓았을 때 최대 높이

```java
package sec10;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;
class Brick implements Comparable<Brick>{
	int area;
	int height;
	int weight;
	public Brick(int area, int height, int weight) {
		this.area = area;
		this.height = height;
		this.weight = weight;
	}
	@Override
	public int compareTo(Brick o) {
		return o.area - this.area;
	}
	
}

public class Ex04 {
	static int[] dy;
	
	public static int solution(ArrayList<Brick> bricks) {
		Collections.sort(bricks); //넓이 순으로 내림차순 정렬
		int answer = 0;
		dy[0] = bricks.get(0).height;
		answer = dy[0];
		for(int i=1;i<bricks.size();i++) {
			int max = 0;
			for(int j=i-1 ; j>=0;j--) {
				if(bricks.get(j).weight > bricks.get(i).weight && max < dy[j]){
					max = dy[j];
				}
			}
			dy[i] = max + bricks.get(i).height;
			answer = Math.max(answer, dy[i]);
		}
		
		return answer;
	}

	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		 
		int n = kb.nextInt(); // 벽돌의 수
		dy = new int[n]; // 해당 벽돌이 제일 위에 놓였을 때 최대 높이
 		ArrayList<Brick> bricks = new ArrayList<Brick>();
		for(int i=0;i<n;i++) {
			int area = kb.nextInt();
			int height = kb.nextInt();
			int weight = kb.nextInt();
			bricks.add(new Brick(area, height, weight));
		}
		System.out.println(solution(bricks));
	}
}

```

**동적계획법과 냅색(Knapsack) 문제**

- 짐 싸기 문제(Knapsack)는 동적 계획법으로 풀 수 있는 경우가 많습니다.

- **여러 물건이 있을 때, 특정한 조건을 만족하는 조합을 구하는 문제입니다.**

### 5. 동전교환(냅색 알고리즘)

- dy[i] 

  i라는 금액을 만드는데 드는 최소동전개수

- dy[j - coin[i] ]+ 1

  j원을 만드는데 coin[i]라는 동전을 사용해보겠다 , coin[i]를 사용했기 때문에 동전 개수를 +1해준다.

```java
package sec10;

import java.util.Arrays;
import java.util.Scanner;


public class Ex05 {
	static int[] dy;
	static int n , m;
	
	public static int solution(int[] coin) {
		Arrays.fill(dy, Integer.MAX_VALUE);
		dy[0] = 0; 
		for(int i=0;i<n;i++) { //동전의 종류
			for(int j=coin[i];j<=m;j++) { //1원부터 m원까지
				dy[j] = Math.min(dy[j], dy[j-coin[i]]+1); 
			}
		}
		return dy[m];
	}

	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		 n = kb.nextInt(); //동전 동류의 개수
		int[] coin = new int[n];
		for(int i=0;i<n;i++) {
			coin[i] = kb.nextInt();
		}
		 m =kb.nextInt(); //거슬러 줄 금액
		dy = new int[m+1]; // 금액을 만드는데 드는 최소 동전의 개수
		System.out.println(solution(coin));
	}
}

```

### 6. 최대점수 구하기(냅색알고리즘)

![image](https://user-images.githubusercontent.com/52770718/122187113-b1b35380-cec9-11eb-8066-5b457b5e9eb1.png)

- dy[] 는 i분이 주어졌을 때 최대 점수

```java
package sec10;

import java.util.Scanner;

public class Ex06 {
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		int n = kb.nextInt();
		int m = kb.nextInt();
		int[] dy = new int[m+1];
		for(int i=0;i<n;i++) {
			int ps = kb.nextInt();
			int pt = kb.nextInt();
			for(int j=m;j>=pt;j--) {
				dy[j] = Math.max(dy[j], dy[j - pt] +ps);
			}
		}
		System.out.println(dy[m]);
	}
}

```

## 예제로 배우는 스프링 부트

### 의존 주입의 이해

#### 의존 주입의 개념

- 객체지향 프로그래밍에서 다른 객체를 사용하는 것을 다르게 표현하면 '**다른 객체에 의존한다**'라고 표현

- 객체를 직접 생성하여 사용

  - 강한결합
  - 생성부터 메모리관리를 위한 소멸까지 해당 객체의 라이프사이클을 개발자가 다 관리

  ![image](https://user-images.githubusercontent.com/52770718/122214921-a2420380-cee5-11eb-9a91-11f00a399bec.png)

- 미리 만들어져 있는 것을 할당받아서 사용

  - 세터나 생성자를 통해 객체를 주입시켜 기능을 사용할 수 있게 만드는 구조
  - 개발자가 관리할 것이 적어짐
  - 약한 결합

  ![img](https://media.vlpt.us/images/gillog/post/08489bda-549e-4dae-851b-8ae1734bf85e/21373937580AEF9B37.jpg)

- 미리 만들어진 객체의 라이프사이클을 관리하고 의존 주입을 관리해주는 것을 **컨테이너**라고 부름

- 개발자가 직접 객체를 제어하지 않고 컨테이너로 객체의 제어권이 넘어갔다는 의미로 **제어의 역전 (IoC)**

  ![img](https://media.vlpt.us/images/gillog/post/41f2eb24-fce2-4b7e-b9ac-d5c3ce97d213/22535642580C4AF12C.jpg)

```java
import java.util.Date;

class Member{
	String name;
	String nickname;
	private Member() {
	}
}

public class UnderstandDI {
	public static void main(String[] args) {
		//날짜를 구하기 위해서는 Date 클래스에 의존해야 한다.	
		Date date = new Date();
		System.out.println(date);
	}
	
	public static void memberUse1() {
		//강한결합 : 직접생성
		//약한 결합을 사용하는 프로그래밍은 다른 클래스의 변화에 더욱 안전하고 유연하게 대처할 수 있는 프로그래밍
		//Member m1 = new Member();
	}
	
	//약한 결합 ; 생성된 것을 주입 받음 - 의존주입(DI)
	public static void memberUse2(Member m) {
		Member m2 = m;
	}
}

```

#### 자바 코드로 DI 사용하기

1. 빈 설정 xml을 이용한 의존주입 => 스프링에서 사용
2. 자바 코드를 이용한 의존 주입 => 스프링부트
3. 어노테이션을 이용한 의존주입 => 스프링부트

```java
package com.study.springboot.bean;

public interface Printer {
	public void print(String message);
}

```

```java
package com.study.springboot.bean;

public class PrinterA implements Printer{

	@Override
	public void print(String message) {
		System.out.println("Printer A : "+message);
	}
	
}

```

```java
package com.study.springboot.bean;

public class PrinterB implements Printer {
	@Override
	public void print(String message) {
		System.out.println("Printer B : "+message);
	}
}

```

```java
package com.study.springboot.bean;

public class Member {
	private String name;
	private String nickname;
	private Printer printer;
	
	public Member() {
	}
	
	public Member(String name, String nickname, Printer printer) {
		this.name = name;
		this.nickname = nickname;
		this.printer = printer;
	}

	public void setName(String name) {
		this.name = name;
	}

	public void setNickname(String nickname) {
		this.nickname = nickname;
	}

	public void setPrinter(Printer printer) {
		this.printer = printer;
	}

	public void print() {
		printer.print("Hello " +name+ ":"+nickname);
	}
	
}

```

```java
package com.study.springboot.bean;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration //해당 어노테이션이 붙은 클래스는 스프링 설정으로 사용됨
public class Config {
	//bean : 스프링이 IoC 방식으로 관리하는 객체
	//BeanFactory  : 스프링의 IoC를 담당하는 핵심 컨테이너
	//ApplicationContext : BeanFactory를 확장한 IoC컨테이너
	
	@Bean // 어노테이션이 붙은 메서드의 리턴값은 빈 객체로 사용됨
	//메서드의 이름(member1)으로 빈 등록
	public Member member1() {
		// Setter Injection  - Setter 메서드를 이용한 의존주입
		Member member1 = new Member();
		member1.setName("홍길동");
		member1.setNickname("도사");
		member1.setPrinter(new PrinterA());
		
		return member1;
	}
	
	//hello라는 이름으로 빈 등록
	@Bean(name =  "hello")
	public Member member2() {
		// Constructor Injection - 생성자를 이용한 의존주입
		return new Member("전우치", "도사", new PrinterA());
	}
	
	@Bean
	public PrinterA printerA() {
		return new PrinterA();
	}
	
	@Bean
	public PrinterB printerB() {
		return new PrinterB();
	}
	
}

```

```java
package com.study.springboot;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.study.springboot.bean.Config;
import com.study.springboot.bean.Member;
import com.study.springboot.bean.Printer;

//자동등록 막음
//@SpringBootApplication - 자동으로 설정이 이루어지고 컴포넌트가 등록 , 
public class Ex02JavaCodeDiApplication {

	public static void main(String[] args) {
		//SpringApplication.run(Ex02JavaCodeDiApplication.class, args);
		
		//IoC 컨테이너 생성
		ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
	
		//Member Bean 가져오기 - member1
		//의존 주입
		Member member1 = (Member) context.getBean("member1");
		member1.print();
		
		// Member Bean 가져오기 - hello
		//의존 주입
		Member member2 = (Member) context.getBean("hello",Member.class);
		member2.print();
		
		//4 PrinterB bean 가져오기
		//미리 형을 지정하여 빈을 리턴
		Printer printer = context.getBean("printerB",Printer.class);
		member1.setPrinter(printer);
		member1.print();
		
		// 싱글톤인지 확인
		if(member1 == member2) {
			System.out.println("동일한 객체입니다.");
		}else {
			System.out.println("서로 다른 객체 입니다.");
		}
	}

}

```

#### 어노테이션으로 DI 사용하기

```JAVA
package com.study.springboot.bean;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component // Member 클래스를 빈으로 등록
public class Member {
	//빈이 생성될 때 기본값
	@Value("홍길동")
	private String name;
	
	//빈이 생성될 때 기본값
	@Value("도사")
	private String nickname;
	
	@Autowired // 빈이 생성될 때 printer 변수가 참조할 객체를 자동으로 찾아온다
	@Qualifier("printerA") // 유사한 객체가 여러 개일때 빈의 이름으로 정확하게 지정
	private Printer printer;
	
	public Member() {
	}
	
	public Member(String name, String nickname, Printer printer) {
		this.name = name;
		this.nickname = nickname;
		this.printer = printer;
	}

	public void setName(String name) {
		this.name = name;
	}

	public void setNickname(String nickname) {
		this.nickname = nickname;
	}

	public void setPrinter(Printer printer) {
		this.printer = printer;
	}

	public void print() {
		printer.print("Hello " +name+ ":"+nickname);
	}
	
}

```

```java
package com.study.springboot.bean;

import org.springframework.stereotype.Component;

//printerA라는 이름으로 빈 등록
@Component("printerA")
public class PrinterA implements Printer{

	@Override
	public void print(String message) {
		System.out.println("Printer A : "+message);
	}
	
}

```

```java
package com.study.springboot.bean;

import org.springframework.stereotype.Component;

//printerB라는 이름으로 빈 등록
@Component("printerB")
public class PrinterB implements Printer {
	@Override
	public void print(String message) {
		System.out.println("Printer B : "+message);
	}
}

```

```java
package com.study.springboot;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


/*
 *  @SpringBootApplication  = @Configuration + @EnableAutoConfiguration + @ComponnentScan
 *  @Configuration : Bean을 생성할 때 Singletone으로 한 번만 생성
 *  @EnableAutoConfiguration : 스프링 어플리케이션 컨텍스트를 만들 때 자동으로 설정하는 기능
 *  @ComponnentScan : @Component와 @Configuration이 붙은 클래스를 스캔해서 빈으로 등록
 */
@SpringBootApplication  // 1. 자동으로 빈을 검색하고 등록한 후
public class Ex03AnnotationDiApplication {

	public static void main(String[] args) {
		//2. 내장톰캣을 실행한 후, 자동으로 WebApplicationContext를 생성
		SpringApplication.run(Ex03AnnotationDiApplication.class, args);
	}

}

```

```java
package com.study.springboot.bean;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller // 빈으로 등록
public class MyController {
	//Member 클래스 타입으로 등록된 빈이 하나밖에 없으므로 추가 정보가 없어도 찾아온다.
	@Autowired
	Member member1;
	
	//printerA , printerB중에 printerB를 주입
	@Autowired
	@Qualifier("printerB")
	Printer printer;
	
	@Autowired
	Member member2;
	
	@RequestMapping("/")
	public @ResponseBody String root() {
		// Member bean 가져오기
		member1.print();
		
		// PrinterB bean 가져오기
		member1.setPrinter(printer);
		member1.print();
		
		//싱글톤확인
		if(member1 == member2) {
			System.out.println("동일한 객체입니다.");
		}else {
			System.out.println("서로 다른 객체입니다.");
		}
	
		return "Annotation 사용하기";
	}
}

```

