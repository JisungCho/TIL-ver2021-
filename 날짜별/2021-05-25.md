# 2021-05-25

## 알고리즘 - Sorting and Searching, Recursive, Tree, Graph

### 10. 마구간 정하기 (결정알고리즘)

- lt ,rt를 결정 
  - lt는 1
  - rt는 배열의 끝값
- mid값을 이용해서 가장 가까운 두 말의 거리를 체크 입력한 마리가 배치되는지 확인

```java
package sec06;

import java.util.Arrays;
import java.util.Scanner;

public class Sol10 {
	public static int count(int[] arr,int dist) { 
		int cnt = 1 ; //말의 마리수
		int ep = arr[0]; // 말의 마지막 좌표 , 처음은 맨 처음
		for(int i=1 ; i<arr.length;i++) {
			if(arr[i] - ep >= dist) {
				cnt ++;
				ep = arr[i];
			}
		}
		return cnt;
	}
	public static int solution(int n, int c, int[] arr) {
		int answer = 0;
		//좌표를 정렬
		Arrays.sort(arr);
		
		int lt = 1 ; 
		int rt = arr[n-1];
		while(lt <= rt) {
			int mid = (lt+rt) / 2;
			if(count(arr, mid) >= c) {
				answer = mid;
				lt = mid + 1;
			}else {
				rt = mid - 1;
			}
		}
		return answer;
	}

	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);

		int n = kb.nextInt(); // 마굿간 갯수
		int c = kb.nextInt(); // 말마리수
		int[] arr = new int[n];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = kb.nextInt();
		}
		System.out.println(solution(n, c, arr));
	}
}

```

### 1. 재귀함수(스택프레임)

- 재귀함수 : 자기가 자기 자신을 호출
- 재귀함수를 쓸 때 if-else를 사용
- 재귀함수는 Stack Frame을 사용하기 때문에 반복문보다 느림
- stack Frame에 함수에는 매개변수 , 지역변수 , 복귀주소 등이 들어가 있다.

```java
package sec07;

public class Sol01 {
	public static void DFS(int n) {
		if(n ==0) {
			return; //void형에서는 호출된 함수 종료
		}else {
			DFS(n-1);
			System.out.print(n+" "); 
		}
		
	}
	public static void main(String[] args) {
		DFS(3);
	}
}

```

### 2. 이진출력 (재귀)

```java
package sec07;

public class Ex02 {
	public static void DFS(int n) {
		if(n ==0) {
			return; //void형에서는 호출된 함수 종료
		}else {
			DFS(n/2);
			System.out.print(n%2+" ");
		}
		
	}
	public static void main(String[] args) {
		DFS(11);
	}
}

```

### 3. 팩토리얼

```java
package sec07;

public class Ex03 {
	public static int DFS(int n) {
		if(n ==1) {
			return 1; //void형에서는 호출된 함수 종료
		}else {
			return n*DFS(n-1);
		}
		
	}
	public static void main(String[] args) {
		System.out.println(DFS(5));
	}
}

```

### 4. 피보나치 재귀(메모리제이션)

- 1번풀이

  ```java
  package sec07;
  
  public class Ex04 {
  	public static int DFS(int n) {
  		if(n == 1) { //
  			return 1;
  		}else if(n==2){//
  			return 1;
  		}else {
  			return DFS(n-2)+DFS(n-1);      
  		}
  	}
  	public static void main(String[] args) {
  		int n = 7;
  		//좋지않은 방법.. 재귀가 너무 많이 호출됨
  		for(int i=1;i<=n ; i++) {
  			System.out.print(DFS(i)+" ");
  		}
  	}
  }
  
  ```

- 2번 풀이

  ```java
  package sec07;
  
  public class Sol04 {
  	static int[] fibo;
  	
  	public static int DFS(int n) {
  		
  		if(n == 1) { //
  			return fibo[n] = 1;
  		}else if(n==2){//
  			return fibo[n] = 1;
  		}else {
  			return fibo[n] = DFS(n-2)+DFS(n-1);      
  		}
  	}
  	public static void main(String[] args) {
  		int n = 45;
  		fibo = new int[n+1]; // 1번부터 사용
  		DFS(n);
  		//속도가 빨라지기는 했지만 아직도 조금 느림
  		for(int i=1;i<=n ; i++) {
  			System.out.print(fibo[i]+" ");
  		}
  	}
  }
  
  ```

- 3번 풀이

  ```java
  package sec07;
  
  public class Sol04_2 {
  	static int[] fibo;
  	
  	public static int DFS(int n) {
  		//기존에 fibo에 있으면 재귀를 뻗지않고 바로 리턴
  		if(fibo[n] > 0) {
  			return fibo[n];
  		}
  		if(n == 1) { //
  			return fibo[n] = 1;
  		}else if(n==2){//
  			return fibo[n] = 1;
  		}else {
  			return fibo[n] = DFS(n-2)+DFS(n-1);      
  		}
  	}
  	public static void main(String[] args) {
  		int n = 45;
  		fibo = new int[n+1]; // 1번부터 사용
  		DFS(n);
  		for(int i=1;i<=n ; i++) {
  			System.out.print(fibo[i]+" ");
  		}
  	}
  }
  
  ```

## Todo List 프로젝트

- 오늘 한 것
  - todolist 에서 Filter를 적용할 시 ajax로 보내주고 응답을 받으면 적용되게하고 active, completed 각 상황에 맞게 나오는게 다르게 설정
- 앞으로 할 일
  - 로그인
  - 로그인이 되면 스케쥴을 돌려서 만료된 일정이 있는지 alert

소스는 git에 업로드

## SQL - 016~023

### 16. 대소문자 변환 함수 배우기 (UPPER , LOWER , INITCAP)

- UPPER : 대문자로 출력
- LOWER : 소문자로 출력
- INITCAP : 첫글자만 대문자 나머지는 소문자

```SQL
SELECT UPPER(ename) , LOWER(ename), INITCAP(ename)
    FROM emp;

SELECT ename, sal 
    FROM emp
    WHERE LOWER(ename) = 'scott';
```

### 17. 문자에서 특정 철자 추출하기 (SUBSTR)

- 문자에서 특정 위치의 문자열을 추출
- SUBSTR (문자, 위치 , 갯수)

```SQL
SELECT SUBSTR('SMITH',1,3)
    FROM DUAL;

/*-3(I)부터 2개*/
SELECT SUBSTR('SMITH',-3,2)
    FROM DUAL;

/*두번째 글자부터 끝까지*/
SELECT SUBSTR('SMITH',2)
    FROM DUAL;    
```

### 18. 문자열의 길이를 출력하기 (LENGTH)

- LENGTH() : 문자열의 길이를 출력하는 함수
- 한글도 마찬가지로 문자의 길이가 출력
- LENGTHB() : 바이트의 길이를 반환

```SQL
SELECT ename , LENGTH(ename)
    FROM emp;
    
SELECT LENGTH('가나다라마')
    FROM DUAL;
    
SELECT LENGTHB('가나다라마')
    FROM DUAL;    
```

### 19. 문자에서 특정 철자의 위치 출력하기 (INSTR)

- INSTR() : 문자에서 특정 철자의 위치를 출력

```SQL
/* 2 */
SELECT INSTR('SMITH' ,'M')
    FROM DUAL;

/* 8 */
SELECT INSTR('abcdefg@naver.com','@')
    FROM DUAL;

/*naver.com출력*/
SELECT SUBSTR('abcdefg@naver.com',INSTR('abcdefg@naver.com','@')+1)
    FROM DUAL;

/*naver 출력*/
SELECT RTRIM(SUBSTR('abcdefg@naver.com',INSTR('abcdefg@naver.com','@')+1),'.com')
    FROM DUAL;
```

### 20. 특정 철자를 다른 철자로 변경하기 (REPLACE)

- REPLACE : 특정 철자를 다른 철자로 변경하는 문자함수
- REGEXP_REPLACE : 정규식을 통해 문자를 변경

```SQL
/*sal에서 0을 *로 바꿈 */
SELECT ename , REPLACE(sal , 0 ,'*')
    FROM emp;

/* 0부터 3을 *로 표현*/
SELECT ename , REGEXP_REPLACE(sal , '[0-3]','*') as SALARY
    FROM emp;
    
CREATE TABLE TEST_ENAME(
    ENAME VARCHAR2(10)
);

INSERT INTO TEST_ENAME VALUES ('김인호');
INSERT INTO TEST_ENAME VALUES ('안상수');
INSERT INTO TEST_ENAME VALUES ('최영희');

/*ename의 2번째 글자를 가져와서 그 글자를 *로 바꿈*/
SELECT REPLACE(ENAME,SUBSTR(ENAME,2,1),'*') AS 전광판_이름
    FROM test_ename;
```

### 21. 특정 철자를 N개 만큼 채우기(LPAD,RPAD)

- LPAD : 왼쪽으로 채움
- RPAD : 오른쪽으로 채움

```SQL
/* 이름과 월급을 출력 , 자릿수를 10자리로 하고 sal 값을 넣고 나머지 빈공간은 *로 채움*/
SELECT ename, LPAD(SAL,10,'*') as salary1 , RPAD(sal,10,'*') as salary2
    FROM emp;

/*반올림한 갯수만큼 자릿수로하고 ■를 하나 출력하고 나머지 자리를 ■로 출력*/
SELECT ename , sal , LPAD('■',round(sal/100) , '■') as bar_chart
    FROM emp;
```

### 22. 특정 철자 잘라내기(TRIM , RTRIM ,LTRIM)

```SQL
/*
LTRIM('smiths','s') : 왼쪽 철자 s를 잘라서출력
RTRIM('hmith','h') : 오른쪽 철자 h를 잘라서 출력
 TRIM('s' from 'smiths') : 양쪽의 s를 잘라서 출력
*/
SELECT 'smith' , LTRIM('sssmiths','s') , RTRIM('hmithh','h') , TRIM('s' from 'ssmithss')
    FROM DUAL;

/*공백으로 이름추가*/    
INSERT INTO emp(empno,ename,sal,job,deptno) VALUES(8291 , 'JACK     ' , 3000,'SALSESMAN',30);
COMMIT;

/*아무것도 출력되지 않음*/
SELECT ename, sal
    FROM emp
    WHERE ename ='JACK';

/*오른쪽 공백을 제거하고 검색*/    
SELECT ename , sal
    FROM emp
    WHERE RTRIM(ename) = 'JACK';
```

### 23. 반올림해서 출력하기(ROUND)

```SQL
/*소수점 두 번째 자리*/
SELECT 876.567 AS 숫자 , ROUND(876.567,1) 
    FROM DUAL;

/*소수점 이전 일의 자리*/
SELECT 876.567 AS 숫자 , ROUND(876.567,-1) 
    FROM DUAL;

/*소수점 자리에서 반올림*/
SELECT 876.567 AS 숫자 , ROUND(876.567,0), ROUND(876.567)
    FROM DUAL;
```

## 스프링 입문을 위한 자바 객체지향의 원리와 이해

### 상속과 인터페이스

- 상속은 is a kind of 관계
- 인터페이스 
  - 구현 클래스 is able to 인터페이스
  - 구현 클래스는 인터페이스할 수 있다.
  - 고래는 헤엄칠 수 있다.
  - 상위클래스는 물려줄 특성이 풍성할수록 좋고, 인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋다.

```java
package inheritance02;

public class 동물 {
	String myClass;
	
	public 동물() {
		myClass = "동물";
	}
	
	void showMe() {
		System.out.println(myClass);
	}
}

```

```java
package inheritance02;

public interface 날수있는 {
	void fly();
}

```

```java
package inheritance02;

public interface 헤엄칠수있는 {
	void swim();
}

```

```java
package inheritance02;

public class 포유류 extends 동물{
	public 포유류() {
		myClass = "포유류";
	}
}	

```

```java
package inheritance02;

public class 조류 extends 동물{
	public 조류() {
		myClass = "조류";
	}
}

```

```java
package inheritance02;

public class 고래 extends 포유류 implements 헤엄칠수있는 {
	public 고래() {
		myClass = "고래";
	}
	@Override
	public void swim() {
		System.out.println(myClass +" 수영 중 . 어프 어프");
	}
}

```

```java
package inheritance02;

public class 박쥐 extends 조류 implements 날수있는 {
	public 박쥐() {
		myClass = "박쥐";
	}	
	@Override
	public void fly() {
		System.out.println(myClass +" 날고 있다.");
	}
}

```

```java
package inheritance02;

public class 참새 extends 조류 implements 날수있는{
	public 참새() {
		myClass = "참새";
	}
	@Override
	public void fly() {
		System.out.println(myClass+" 날고있는중이랑께");
	}
}

```

```java
package inheritance02;

public class 펭귄 extends 조류 implements 헤엄칠수있는{
	public 펭귄() {
		myClass = "펭귄";
	}
	@Override
	public void swim() {
		System.out.println(myClass+ " 수영 중 푸악푸악");
	}
}

```

```java
package inheritance02;

public class Driver {
	public static void main(String[] args) {
		날수있는 날라리1 = new 박쥐();
		날라리1.fly();
		
		날수있는 날라리2 = new 참새();
		날라리2.fly();
		
		헤엄칠수있는[] 맥주병들 = new 헤엄칠수있는[2];
		맥주병들[0] = new 고래();
		맥주병들[1] = new 펭귄();
		
		for(헤엄칠수있는 맥주병 :  맥주병들) {
			맥주병.swim();
		}
	}
}

```

### 상속과 T메모리

```java
package inheritance03;

public class Animal {
	 public String name;
	 
	 public void showName() {
		 System.out.printf("안녕 나는 %s야 반가워\n",name);
	 }
}

```

```java
package inheritance03;

public class Penguin extends Animal{
	public String habitat;
	
	public void showHabitat() {
		System.out.printf("%s는 %s에 살아\n",name,habitat);
	}
}

```

```java
package inheritance03;

public class Driver {
	public static void main(String[] args) {
		Penguin pororo = new Penguin();
		
		pororo.name = "뽀로로";
		pororo.habitat = "남극";
		
		pororo.showName();
		pororo.showHabitat();
		
		Animal pingu = new Penguin();
		
		pingu.name = "핑구";
		//pingu.habitat = "EBS";
		
		pingu.showName();
		//pingu.showHabitat();
		
		//Penguin happyfeet = new Animal();
	}
}

```

- 5번 째 줄 까지 실행

  ![Screenshot](https://sehun-kim.github.io/sehun/assets/images/extends2.PNG)

  - 하위클래스의 인스턴스가 생성될 때 상위클래스의 인스턴스도 함께 생성
  - 모든 클래스의 최상위 클래스인 Object 클래스의 인스턴스도 함께 생성 ,  생략함

- 13번째 실행 후

  - pingu 객체 참조 변수가 가리키고 있는 것은 Penguin인스턴스가 아닌 Animal인스턴스이다.

    따라서 Penguin에 있는 속성과 메서드를 사용할 수 없다.

- 21번째가 실행 되지 않는 이유

  - Animal 인스턴스를 Penguin형으로 가리키는것 자체가 말이 되지 않는다.