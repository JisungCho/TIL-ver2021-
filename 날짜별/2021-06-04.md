# 2021-06-04

## Todo 프로젝트

- 로그인 계속 진행하기
- 시큐리티 정리하기

## 코딩테스트 - DFS, BFS

### 6. 순열 구하기(채점지원안됨)

![image](https://user-images.githubusercontent.com/52770718/120756124-d1519000-c549-11eb-9872-9723affa5dce.png)

```java
package sec08;

import java.util.Scanner;

public class Ex06 {
	static int[] pm ,arr,ch;
	static int m,n;
	public static void DFS(int L) {
		if(L == m) { //m번 뽑았으면
			for(int i=0;i<m;i++) { //pm에 있는 것 출력
				System.out.print(pm[i]+" ");
			}
			System.out.println();
			return;
		}else {
			for(int i=0;i<n;i++) { // n개의 자연수
				if(ch[i] ==0) { // 사용하지 않았으면
					ch[i] = 1; //사용했다고 체크
					pm[L] = arr[i]; // pm에 넣어줌
					DFS(L+1); 
					ch[i] = 0; //사용해제
				}
			}
		}
		
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		n = kb.nextInt(); // 10이하 자연수 갯수
		m = kb.nextInt(); // 몇개 뽑을 건지 
		arr = new int[n]; //n개의 자연수
		ch = new int[n];
		for(int i=0;i<n;i++) {
			arr[i] = kb.nextInt();
		}
		pm = new int[m]; // 뽑는 경우
		DFS(0);
	}
}

```

### 7. 조합수(메모리제이션)

![image](https://user-images.githubusercontent.com/52770718/120762441-38267780-c551-11eb-94e0-be641e693228.png)

```java
package sec08;

import java.util.Scanner;

public class Ex07 {
	public static int[][] fibo;
	
	public static int DFS(int n,int r) {
		if(fibo[n][r] >0 ) {
			return fibo[n][r];
		}
		if(n==r) {
			return fibo[n][r] = 1;
		}
		if(r == 0) {
			return fibo[n][r] = 1;
		}else {
			return fibo[n][r] = DFS(n-1, r-1) + DFS(n-1, r);
		}
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt(); // 갯수
		int r = kb.nextInt(); // 몇개 뽑을 지
		fibo = new int[n+1][n+1];
		System.out.println(DFS(n, r));
	}
}

```

### 8.  수열 추측하기

- 진짜로 시물레이션을 다 더해보는게 아니라
- 규칙성을 통해서 푼다
  -  ex) 5가 들어오면 4C0 부터 4C4까지 저장

![image](https://user-images.githubusercontent.com/52770718/120766159-ea137300-c554-11eb-8f31-93f5f9635ca3.png)

![image](https://user-images.githubusercontent.com/52770718/120763900-a455ab00-c552-11eb-9845-febdcbcd6eaf.png)

```java
package sec08;

import java.util.Scanner;

public class Ex08 {
	static int[] b ,p,ch;
	static int f,n;
	static boolean flag= false;
	static int[][] fibo  = new int[35][35];
	
	public static  int combi(int n,int r) {
		if(fibo[n][r] >0 ) {
			return fibo[n][r];
		}
		if(n==r) {
			return fibo[n][r] = 1;
		}
		if(r == 0) {
			return fibo[n][r] = 1;
		}else {
			return fibo[n][r] = combi(n-1, r-1) + combi(n-1, r);
		}
	}
	
	public static void DFS(int L,int sum) {
		if(flag) {
			return;
		}
		if(L == n) { //n번만큼 뽑으면
			if(sum == f) { // 밑단 숫자와 같으면
				for(int x : p) {
					System.out.print(x+" ");
				}
				flag = true; //스택에 쌓여있는 재귀들은 실행안함
			}
		}else {
			for(int i=1;i<=n;i++) {
				if(ch[i] == 0) {
					ch[i] = 1;
					p[L] = i;
					DFS(L+1, sum+(p[L] * b[L]));
					ch[i] = 0;
				}
			}
		}
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		n = kb.nextInt(); // 1부터 n까지  ex) 4 
		f = kb.nextInt(); // 가장 밑줄의 숫자
		b = new int[n]; // nCr의 결과를 저장
		p = new int[n]; // 수열을 저장
		ch = new int[n+1]; // 체크를 1부터 사용
		for(int i=0;i<n;i++) {
			b[i] = combi(n-1, i); // ex) 3c0 부터 3c3 까지구함
		}
		DFS(0,0);
	}
}

```

### 9. 조합 구하기

![image](https://user-images.githubusercontent.com/52770718/120775443-29928d00-c55e-11eb-8aed-d56ef37ced6b.png)

```java
package sec08;

import java.util.Scanner;

public class Ex09 {
	static int[] combi;
	static int m,n;
	
	public static void DFS(int L,int start) {
		if(L == m) {
			for(int x : combi) {
				System.out.print(x+" ");
			}
			System.out.println();
		}else {
			for(int i=start;i<=n;i++) {
				combi[L] = i;
				DFS(L+1, i+1);
			}
		}
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		n = kb.nextInt(); // 1부터 n까지  ex) 4 
		m = kb.nextInt(); // 뽑을 숫자의 갯수
		combi = new int[m];
		DFS(0,1);
	}
}

```

## 스프링 입문을 위한 자바 객체지향 원리의 이해

### 클래시 생성 시 실행 블록, static 블록

- 클래스는 생성자는 존재하지 않는다, 그대신 클래스가 static 영역에 배치될 때 실행되는 코드블록 static블록이 있다

```java
package staticBlock;

public class 동물 {
	public static int age = 20;
	static {
		System.out.println("동물 클래스 레디 온!");
	}
}

```

```java
package staticBlock;

public class Driver01 {
	public static void main(String[] args) {
		동물 뽀로로 = new 동물();
	}
}
//동물 클래스 레디 온! 
```

```java
package staticBlock;

public class Driver02 {
	public static void main(String[] args) {
		System.out.println("main메서드 시작");
	}
}
//main메서드 시작 
```

- main 메서드 시작만 출력되는 이유는 실제로 **스태틱 영역에 로딩되는 순간은 실제로 클래스가 처음으로 사용될 때 로딩됨**

```java
package staticBlock;

public class Driver03 {
	public static void main(String[] args) {
		System.out.println("main메서드 시작");
		동물 뽀로로 = new 동물();
	}
}
/*
main메서드 시작
동물 클래스 레디 온!
*/
```

```java
package staticBlock;

public class Driver04 {
	public static void main(String[] args) {
		System.out.println("main메서드 시작");
		동물 뽀로로 = new 동물();
		동물 피카츄 = new 동물();
	}
}
/*
main메서드 시작
동물 클래스 레디 온!
*/
```

- 클래스의 인스턴스를 여러 개 만들어도 결국 static 블록은 단 한번만 실행

```java
package staticBlock;

public class Driver05 {
	public static void main(String[] args) {
		System.out.println("main메서드 시작");
		System.out.println(동물.age);
	}
}
/*
main메서드 시작
동물 클래스 레디 온!
20
*/
```

- 클래스의 정적 속성을 사용 했을때 실행

#### 정리

- 클래스 정보는 해당 클래스가 코드에서 맨 처음 사용될 때 T메모리의 스태틱 영역에 로딩
  - 처음 사용되는 경우
    1. 클래스의 정적 속성을 사용
    2. 클래스의 정적 메서드 사용
    3. 클래스의 인스턴스를 최초로 만들 때

### final 키워드

- final 키워드가 나타날 수 있는 곳
  - 클래스
  - 변수
  - 메서드

#### final과 클래스

- 상속을 허락하지 않겠다

  ```java
  package finalClass;
  
  public final class 고양이 {
  	
  }
  
  ```

  ```java
  package finalClass;
  
  //에러
  public class 길고양이 extends 고양이 {
  
  }
  
  ```

#### final과 변수

- 변경 불가능한 상수

  - 정적 상수 :  선언 시에, 또는 정적 생성자에 해당하는 static 블록 내부에서 초기화 가능
  - 객체 상수 :  선언 시에,또는 객체 생성자 또는 인스턴스 블록에서 초기화
  - 지역 상수 : 선언 시 또는 최초 한 번만 초기화

  ```java
  package finalVariable;
  
  public class 고양이 {
  	final static int 정적상수1 = 1;
  	final static int 정적상수2;
  	
  	final int 객체상수1 = 1;
  	final int 객체상수2;
  	
  	static {
  		정적상수2 = 2;
  		
  		//상수는 한번 초기화 되면 값을 변경할 수 없다
  		//정적상수2 =4;
  	}
  	
  	public 고양이() {
  		객체상수2 = 2;
  		
  		//상수는 한번 초기화 되면 값을 변경할 수 없다
  		//객체상수2 =4;
  		
  		final int 지역상수1 = 1;
  		final int 지역상수2;
  		
  		지역상수2 = 2;
  	}
  }
  
  ```

#### final과 메서드

- 재정의, 즉 오버라이딩을 금지

```java
package finalMethod;

public class 동물 {
	final void 숨쉬다() {
		System.out.println("호흡 중");
	}
}
class 포유류 extends 동물{
	
	//오버라이드 안됨
	//void 숨쉬다() {
		
	//}
}

```

### instanceof 연산자

- **만들어진 객체가 틀정 클래스의 인스턴스인지 물어보는 연산자**
- **instanceof 연산자는 결과로 true 또는 false를 반환**
- **객체참조변수 instanceof 클래스명**
  - 객체참조변수를 클래스명으로 나타낼수 있니?
- **객체 참조 변수의 타입이 아닌 실제 객체의 타입에 의해 처리**
- 인터페이스의 구현 관계에서도 동일하게 적용

```java
package instance01;
class 동물{
	
}
class 조류 extends 동물{
	
}
class 펭귄 extends 조류{
	
}
public class Driver {
	public static void main(String[] args) {
		동물 동물객체 = new 동물();
		조류 조류객체 = new 조류();
		펭귄 펭귄객체 = new 펭귄();
		
		System.out.println(동물객체 instanceof 동물);   //true
		
		System.out.println(조류객체 instanceof 동물); //true
		System.out.println(조류객체 instanceof 조류); //true
		
		System.out.println(펭귄객체 instanceof 동물); //true
		System.out.println(펭귄객체 instanceof 조류); //true
		System.out.println(펭귄객체 instanceof 펭귄); //true
		
		System.out.println(펭귄객체 instanceof Object); //true
	}
}

```

```java
package instanceof02;
class 동물{
	
}
class 조류 extends 동물{
	
}
class 펭귄 extends 조류{
	
}
public class Driver {
	public static void main(String[] args) {
		동물 동물객체 = new 동물();
		동물 조류객체 = new 조류();
		동물 펭귄객체 = new 펭귄();
		
		System.out.println(동물객체 instanceof 동물);   //true
		
		System.out.println(조류객체 instanceof 동물); //true
		System.out.println(조류객체 instanceof 조류); //true
		
		System.out.println(펭귄객체 instanceof 동물); //true
		System.out.println(펭귄객체 instanceof 조류); //true
		System.out.println(펭귄객체 instanceof 펭귄); //true
		
		System.out.println(펭귄객체 instanceof Object); //true
	}
}

```

```java
package instanceof03;
interface 날수있는{
	
}
class 박쥐 implements 날수있는{
	
}
class 참새 implements 날수있는{
	
}
public class Driver {
	public static void main(String[] args) {
		날수있는 박쥐객체 = new 박쥐();
		날수있는 참새객체 = new 참새();
		
		System.out.println(박쥐객체 instanceof 날수있는); // T
		System.out.println(박쥐객체 instanceof 박쥐); // T
		
		System.out.println(참새객체 instanceof 날수있는); // T
		System.out.println(참새객체 instanceof 참새); // T
	}
}

```

### package 키워드

- 네임스페이스를 만들어주는 역활
- 즉 package는 일종의 소유자라고 할 수 있다.

### interface 키워드와 implements 키워드

- 인터페이스는 public 추상 메서드와 public 정적 상수만 가질 수 있다.
- 인터페이스는 추상 메서드와 정적 상수만 가질 수 있기에 따로 메서드에 public과 abstract, 속성에 public과 static , final을 붙이지 않아도 자동으로 자바가 알아서 붙여준다.

```java
package interface02;

interface Speakable{
	/*public static final*/ double PI = 3.14159;
	/*public static final*/ double absoluteZeroPoint = -275.15;

	/*public abstract*/ void sayYes(); //몸체가 없는 메서드
}

class Speaker implements Speakable{

	@Override
	public void sayYes() {
		System.out.println("i say no");
	}
	
}

public class Driver {
	public static void main(String[] args) {
		System.out.println(Speakable.absoluteZeroPoint);
		System.err.println(Speakable.PI);
		
		Speaker s1 = new Speaker();
		s1.sayYes();
	}
}

```

### this 키워드

```java
package This;

class 펭귄{
	int var = 10; //객체 변수
	void test() {
		int var = 20;
		
		System.out.println(var); // 20 , test()메서드 내부의 지역 변수 var에 우선권
		System.out.println(this.var); //10 , 객체 변수 var를 출력
	}
}


public class Driver {
	public static void main(String[] args) {
		펭귄 뽀로로 = new 펭귄();
		뽀로로.test();
	}
}

```

#### 정리

- this는 객체가 자기 자신을 지칠할 때 사용

- **지역 변수와 속성(객체변수,정적변수) 이름이 같은 경우 지역 변수가 우선시 된다**

- **객체 변수와 이름이 같은 지역 변수가 있는 경우 객체 변수를 사용하려면 this를 접두사로 사용**
- **정적 변수와 이름이 같은 지역 변수가 있는 경우 정적 변수를 사용하려면 클래스명을 접두사로 사용**

### super 키워드

- **super는 바로 위 상위 클래스의 인스턴스를 지칭하는 키워드**

```java
package Super;

class 동물 {
	void method() {
		System.out.println("동물");
	}
}

class 조류 extends 동물{

	@Override
	void method() {
		super.method(); // 상위 클래스의 인스턴스의 method()
		System.out.println("조류");
	}
}

class 펭귄 extends 조류{

	@Override
	void method() {
		super.method(); // 상위 클래스의 인스턴스의 method()
		System.out.println("펭귄");
	}
}


public class Driver {
	public static void main(String[] args) {
		펭귄 뽀로로 = new 펭귄(); //상위클래스의 인스턴스를 다 만듬
		뽀로로.method(); 
	}
}
/*
동물
조류
펭귄
*/
```

