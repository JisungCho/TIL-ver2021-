# 2021-05-20

## 스프링 입문을 위한 객체지향의 원리와 이해

### 상속 : 재사용 + 확장

- 객체지향의 상속은 재사용과 확장으로 이해

- **객체 지향에서의 상속은 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용**

- 부모 - 자식 (x) 

- 상위 클래스 - 하위 클래스 (o) , 슈퍼클래스 - 서브클래스 (o)

- 상위 클래스 쪽으로 갈수록 추상화, 일반화 

  하위 클래스 쪽으로 갈수록 구체화 , 특수화

- 하위 클래스는 상위 클래스다

  - 아버지는 할아버지다??

    아들은 아버지다??

    딸은 아버지다??  

  - 포유류는 동물이다

    고래는 포유류다.

    고래는 동물이다.

- 동물 뽀로로  = new 펭귄()

  펭귄을 낳으니 동물 역활을 하는 뽀로로라 이름을 지엇다.

#### 상속의 강력함

- 클래스명은 분류스럽게, 객체 참조 변수명은 유일무이한 사물처럼 작명

```java
package inheritance01;

public class 동물 {
	String myClass;
	
	public 동물() {
		myClass = "동물";
	}
	
	void showMe() {
		System.out.println(myClass);
	}ㅓ
}

```

```java
package inheritance01;

public class 포유류 extends 동물{
	public 포유류() {
		myClass = "포유류";
	}
}

```

```java
package inheritance01;

public class 조류 extends 동물 {
	public 조류() {
		myClass = "조류";
	}
}

```

```java
package inheritance01;
	
public class 고래 extends 포유류{
	public 고래() {
		myClass = "고래";
	}
}

```

```java
package inheritance01;
	
public class 박쥐 extends 포유류{
	public 박쥐() {
		myClass = "박쥐";
	}
}

```

```java
package inheritance01;

public class 참새 extends 조류{
	public 참새() {
		myClass = "참새";
	}
}

```

```java
package inheritance01;

public class 펭귄 extends 조류{
	public 펭귄() {
		myClass= "펭귄";
	}
}

```

```java
package inheritance01;

public class Driver01 {
	public static void main(String[] args) {
		동물 animal = new 동물();
		포유류 mammalia = new 포유류();
		조류 bird = new 조류();
		고래 whale = new 고래();
		박쥐 bat = new 박쥐();
		참새 sparrow = new 참새();
		펭귄 penguin = new 펭귄();
		
		animal.showMe();
		mammalia.showMe();
		bird.showMe();
		whale.showMe();
		bat.showMe();
		sparrow.showMe();
		penguin.showMe();
	}
}

```

```java
package inheritance01;

public class Driver02 {
	public static void main(String[] args) {
		동물[] animals = new 동물[7];
		
		animals[0] = new 동물();
		animals[1] = new 포유류();
		animals[2] = new 조류();
		animals[3] = new 고래();
		animals[4] = new 박쥐();
		animals[5] = new 참새();
		animals[6] = new 펭귄();
	
		for(int i = 0;i<animals.length;i++) {
			animals[i].showMe();
		}
	}
}

```

```java
package inheritance01;

public class Driver03 {
	public static void main(String[] args) {
		동물 animal = new 동물();
		동물 mammalia = new 포유류();
		동물 bird = new 조류();
		동물 whale = new 고래();
		동물 bat = new 박쥐();
		동물 sparrow = new 참새();
		동물 penguin = new 펭귄();
		
		animal.showMe();
		mammalia.showMe();
		bird.showMe();
		whale.showMe();
		bat.showMe();
		sparrow.showMe();
		penguin.showMe();
	}
}

```

#### 상속은 is a 관계를 만족해야 한다?

- 하위클래스 is a 상위클래스??
  - 하위 클래스는 하나의 상위 클래스이다? => 말이 이상하다
  - 김연아 is a 사람
- 상속은 is a kind of 관계이다
  - 하위클래스 is a kind of 상위클래스
  - 김연아 is a kind of 사람
- **객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.**
- **객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.**
- **객체 지향의 상속은 is a kind of 관계를 만족해야한다.**

#### 다중 상속과 자바

- 자바는 다중 상속을 지원하지 않는다.

  ex ) 상위클래스 - 사람 , 물고기

  ​		하위클래스 - 인어

  인어에게 수영해라고한다면 사람처럼 수영해야하는지 물고기 처럼 수용해야하는지 문제가 발생

  이 문제를 다이아몬드 문제라고 함



## SQL 200제

### 11.비교연산자 배우기(BETWEEN AND)

- BETWEEN 하한값 AND 상한값

```SQL
SELECT ename,sal
    FROM emp
    WHERE sal BETWEEN 1000 AND 3000;
    
    
SELECT ename,sal
    FROM emp
    WHERE (sal >= 1000 AND sal <= 3000);
    
SELECT ename, sal
    FROM emp
    WHERE sal NOT BETWEEN 1000 AND 3000; /*속하지 않은 값 출력*/

SELECT ename,sal
    FROM emp
    WHERE (sal <1000 OR sal > 3000);
    
SELECT ename, hiredate
    FROM emp
    WHERE hiredate BETWEEN '1982/01/01' AND '1982/12/31';
    
```

### 12. 비교 연산자 배우기 (LIKE)

- % 는 와일드카드 , 이 자리에 어떠한 철자가 와도 상관 없고 철자의 개수가 몇 개가 되든 관계 없다.
- %가 특수문자 퍼센트가 아니라 와일드 카드가 되려면 이퀄 연산자가 아닌 LIKE 연산자를 이용
- _ 언더바는 어떠한 철자가 와도 관계없으나 자리수는 한 자리여야 된다

```SQL
SELECT ename, sal
    FROM emp
    WHERE ename LIKE 'S%';

SELECT ename
    FROM emp
    WHERE ename LIKE '_M%';
    
SELECT ename
    FROM emp
    WHERE ename LIKE '%T';
    
SELECT ename
    FROM emp
    WHERE ename LIKE '%A%';
```

### 13. 비교 연산자 배우기 (IS NULL)

- NULL 값은 데이터가 할당되지 않은 상태, 알 수 없는 값
- 알수없는 값이기 때문에 이퀄 연산자로는 비교할 수 없다
- IS NULL 연산자를 사용

```SQL
SELECT ename , comm
    FROM emp
    WHERE comm is null;
```

### 14. 비교 연산자 배우기 (IN)

- IN 연산자는 여러 리스트를 조회할 수 있다.
  - 이퀄 연산자는 하나의 값만 조회

```SQL
/*JOB이 SALESMAN ANALYST MANAGER인 사람들 출력 */
SELECT ename, sal , job
    FROM emp
    WHERE job in ('SALESMAN','ANALYST','MANAGER');
    
/*위와 같은 쿼리문*/
SELECT ename, sal , job
    FROM emp
    WHERE (job = 'SALESMAN' or job='ANALYST' or job = 'MANAGER');
    
/*JOB이 SALESMAN ANALYST MANAGER이 아닌 사람들 출력 */
SELECT ename, sal , job
    FROM emp
    WHERE job NOT in ('SALESMAN','ANALYST','MANAGER'); 
    
/*위와 같은 쿼리문*/
SELECT ename, sal , job
    FROM emp
    WHERE (job != 'SALESMAN' and job != 'ANALYST' and job != 'MANAGER');    
```

### 15. 논리 연산자 배우기 (AND OR NOT)

- NULL이 있다면 반환값은 NULL

```JAVA
SELECT ename, sal ,job
    FROM emp
    WHERE job = 'SALESMAN' AND sal >= 1200;

/*FALSE이므로 출력안됨*/   
SELECT ename , sal , job
    FROM emp
    WHERE job = 'ABCDEFG' AND sal >= 1200;
```

