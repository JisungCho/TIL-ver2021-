# 2021-06-18

## 코딩테스트 - String 6,7,8,9,10

### 6.  중복문자제거

- IndexOf이용

```java
package sec01;

import java.util.Scanner;

public class Ex06 {
	public static String solution(String msg) {
		//indexOf(int)는 int 타입으로 전달된 아스키 값을 문자열에서 찾고 index를 리턴해줍니다.
		String answer = "";
		for(int i=0;i<msg.length();i++) {
			//해당 문자가 나타나는 처음 인덱스 == 내가 조사할 인덱스
			if(msg.indexOf(msg.charAt(i)) == i) {
				answer += msg.charAt(i);
			}
		}
		return answer;
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		String msg = kb.next();
		System.out.println(solution(msg));
		
	}
}

```

### 7. 회문 문자열

- StringBuilder reverse이용

```java
package sec01;

import java.util.Scanner;

//reverse로 돌려서 같은 문자열인지확인
public class Ex07 {
	public static String solution(String s) {
		StringBuffer sb = new StringBuffer(s);
		sb.reverse();
		
		if(s.equalsIgnoreCase(s.toString())) {
			return "YES";
		}
		
		return "NO";
	}
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		String s = kb.next();
		System.out.println(solution(s));
	}
}

```

### 8. 유효한 팰린드롬

- replaceAll을 이용해 정규표현식을 사용하여 특수문자제거

```java
package sec01;

import java.util.Scanner;

//영문자 대소문자와 숫자로만 구성 /[a-zA-Z0-9]/
/*
 * 7번 문제와 동일 
 */
public class Ex08 {
	public static String solution(String s) {
		s = s.replaceAll("[^A-Z]", "");
		StringBuilder sb = new StringBuilder(s);
		String str = sb.reverse().toString();
		if(s.equals(str)) {
			return "YES";
		}
		return "NO";
	}
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		String s = kb.nextLine().toUpperCase();
		System.out.println(solution(s));
	}
}

```

### 9. 숫자만 추출

 *  Character.isDigit를 이용해서 숫자인지 판단 
 *  숫자이면 answer에다가 추가해주고
 *  String을 Integer로 변경

```java
package sec01;

import java.util.Scanner;

/*
 *  Character.isDigit를 이용해서 숫자인지 판단 
 *  숫자이면 answer에다가 추가해주고
 *  String을 Integer로 변경
 */
public class Ex09 {
	public static int solution(String s) {
		String answer= "";
		char[] arr = s.toCharArray();
		for(char c : arr) {
			if(Character.isDigit(c)) {
				answer += c;
			}
		}
		
		return Integer.valueOf(answer);
	}
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		String s = kb.nextLine().toUpperCase();
		System.out.println(solution(s));
	}
}

```

### 10. 가장 짧은 문자거리

- 처음 거리는 가장 크게 설정
- 왼쪽에서 오른쪽 , 오른쪽에서 왼쪽으로 탐색

```java
package sec01;

import java.util.Scanner;


public class Ex10 {
	public static int[] solution(String str,char c) {
		// 정담을 담을 배열
		int[] answer =new int[str.length()];
		int p = 1000; //처음 거리
		
		//왼쪽에서 오른쪽
		for(int i=0;i<str.length();i++) {
			if(str.charAt(i) == c ) { //조사할 문자랑 같으면
				p=0; 
				answer[i] = p;
			}else {
				p++; 
				answer[i] = p;
			}
		}
		
		p = 1000;
		
		//오른쪽에서 왼쪽
		for(int i=str.length()-1;i>=0;i--) {
			if(str.charAt(i) == c ) { //조사할 문자랑 같으면
				p=0;
			}else {
				p++;
				//둘중에서 작은 값으로
				answer[i] = Math.min(answer[i], p);
			}
		}
		
		return answer;
	}

	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		String s = kb.next();
		char c = kb.next().charAt(0);
		for(int i : solution(s, c)) {
			System.out.print(i+" ");
		}
	}
}

```

## 예제로 배우는 스프링 부트

### Validator 사용하기

폼 데이터의 유효성 검증은 파라미터가 데이터로 사용 가능한지 파악하는 것을 의미한다.

#### 폼 데이터 유효성 검증 단계

1. 클라이언트인 html 페이지에서 자바스크립트를 통한 검증
   - 데이터의 유효성이 검증되지 않았다면 서버로 데이터를 보내지 않아 네트워크의 트래픽 낭비를 막을 수 있게 된다.
2. 서버 페이지인 JSP/Servlet에서 파라미터로 받은 후 검증
   - 클라이언트에서 검증을 했더라도 악의적인 url호출에 방어해야 하므로 서버에서도 반드시 확인

=> 스프링에서는 Validator 인터페이스를 제공해서 일관된 방식의 코드를 만들 수 있도록 방향을 제시

#### 스프링의 폼 데이터 유효성 검증 예제

```java
package com.study.springboot;

import lombok.Data;

@Data //롬복
public class ContentDTO {
	private int id;
	private String writer;
	private String content;
}

```

```java
package com.study.springboot;

import org.springframework.validation.Errors;
import org.springframework.validation.Validator;

//Validator 인터페이스를 구현하기 위해서는 support 메서드와 validate 메서드 반드시 구현
public class ContentValidator implements Validator{

	@Override
	public boolean supports(Class<?> clazz) { 
		return ContentDTO.class.isAssignableFrom(clazz); //검증할 객체의 클래스 타입 정보
	}

	//데이터의 유효성을 검증학 위한 본인의 코드를 작성
	@Override
	//Obj 에 CotentDTO 객체가 주입됨
	public void validate(Object obj, Errors errors) {
		
		//다운캐스팅
		ContentDTO dto = (ContentDTO) obj;
		
		String sWriter = dto.getWriter();
		if(sWriter == null || sWriter.trim().isEmpty()) {
			System.out.println("Writer is null or empty");
			errors.rejectValue("writer", "trouble");//유효성 검사를 통과하지 못했다면 errors 객체 변수에에러 내용을 닫는다.
			//errors에 값을 넘어주면 다른곳에서도 이 에러 내용을 이용할 수 있게 된다.
		}
		
		String sContent = dto.getContent();
		if(sContent == null || sContent.trim().isEmpty()) {
			System.out.println("Content is null or empty");
			errors.rejectValue("content", "trouble"); //유효성 검사를 통과하지 못했다면 errors 객체 변수에에러 내용을 닫는다.
			//errors에 값을 넘어주면 다른곳에서도 이 에러 내용을 이용할 수 있게 된다.
		}
		
	}

}

```

```java
package com.study.springboot;

import org.springframework.stereotype.Controller;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class MyController {

	@RequestMapping("/")
	@ResponseBody
	public String root() throws Exception {
		return "Validator(1)";
	}
	
	@RequestMapping("/insertForm")
	public String insert1() {
		return "createPage"; // createPage.jsp 리턴
	} 
	
	@RequestMapping("/create")
	public String insert2(@ModelAttribute("dto") ContentDTO contentDto,BindingResult result) {
		String page = "createDonePage";
		System.out.println(contentDto);
		
		ContentValidator validator = new ContentValidator(); // 강한 결합 
		validator.validate(contentDto, result); //유효성 검증
		
		//에러가 있다면 result에 값이 있음
		if(result.hasErrors()) {
			page = "createPage";
		}
		
		return page;
	}
}

```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
createPage.jsp <br>


<form action="/create">
	작성자 : <input type="text" name="writer" value="${dto.writer }"> <br/>
	내용 : <input type="text" name="content" value="${dto.content }"> <br/>
	<input type="submit" value="전송">
</form>

</body>
</html>
```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
    <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
createDone.jsp <br>

이름 : ${dto.writer } <br/>
내용 : ${dto.content }

</body>
</html>
```

### ValidationUtils 사용하기

데이터의 유효성을 검증할 때 값이 널인지 공백인지 비교해서 처리하는 부분을 스프링에서 API 메서드로 제공

```JAVA
package com.study.springboot;

import org.springframework.validation.Errors;
import org.springframework.validation.ValidationUtils;
import org.springframework.validation.Validator;

public class ContentValidator implements Validator{

	@Override
	public boolean supports(Class<?> clazz) { 
		return ContentDTO.class.isAssignableFrom(clazz); //검증할 객체의 클래스 타입 정보
	}

	@Override
	public void validate(Object obj, Errors errors) {
		
		ContentDTO dto = (ContentDTO) obj;
		
		//spring에서 제공하는 API 메서드
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "writer", "writer is empty");

		String sWriter = dto.getContent();
		if(sWriter.length() < 3) {
			errors.reject("writer","writer is too short");
		}
	
		String sContent = dto.getContent();
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "content", "content is empty");
	}

}

```

```JAVA
package com.study.springboot;

import org.springframework.stereotype.Controller;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class MyController {

	@RequestMapping("/")
	@ResponseBody
	public String root() throws Exception {
		return "Validator(2)";
	}
	
	@RequestMapping("/insertForm")
	public String insert1() {
		return "createPage"; // createPage.jsp 리턴
	} 
	
	@RequestMapping("/create")
	public String insert2(@ModelAttribute("dto") ContentDTO contentDto,BindingResult result) {
		String page = "createDonePage";
		System.out.println(contentDto);
		
		ContentValidator validator = new ContentValidator();
		validator.validate(contentDto, result); //검증
		if(result.hasErrors()) {
			System.out.println("getAllErros : "+ result.getAllErrors() );
			
			if(result.getFieldError("writer") != null) {
				System.out.println("1:"+result.getFieldError("writer").getCode());
			}
			if(result.getFieldError("content") != null) {
				System.out.println("2:"+result.getFieldError("content").getCode());
			}
			
			page = "createPage";
		}
		
		return page;
	}
}

```

### initBinder 사용하기

구조상 검증이 필요할 때마다 검증용 클래스를 new해서 사용해야 하는 강한 결합을 약한 결합으로 만든다

```xml
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
```

- @InitBinder 어노테이션을 지정하여 해당 메서드를 프로젝트가 시작할 때 먼저 실행 
- WebDataBinder 타입 변수에 우리가 사용할 유효성 검증 클래스가 프로젝트가 시작할 때 등록
- 개별적으로 생성할 필요없이 유효성 검증이 필요하면 binder 변수에서 꺼내서 사용
- @Valid 어노테이션으로 contentDTO 객체 변수에 대한 유효성 검증을 하겠다고 표시
- 파라미터로 객체 변수가 들어오면 스프링이 binder 변수에 저장된 객체를 통해서 즉시 유효성 검사를 하고 에러가 있다면 result변수에 담아둔다.

```java
package com.study.springboot;

import javax.validation.Valid;

import org.springframework.stereotype.Controller;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class MyController {

	@RequestMapping("/")
	@ResponseBody
	public String root() throws Exception {
		return "Validator(3)";
	}
	
	@RequestMapping("/insertForm")
	public String insert1() {
		return "createPage"; // createPage.jsp 리턴
	} 
	
	//new 하지 않고 약한 결합을 사용
    //@Valid 어노테이셔
	@RequestMapping("/create")
	public String insert2(@ModelAttribute("dto") @Valid ContentDTO contentDto,BindingResult result) {
		String page = "createDonePage";
		System.out.println(contentDto);
		
		if(result.hasErrors()) {
			System.out.println("getAllErros : "+ result.getAllErrors() );
			
			if(result.getFieldError("writer") != null) {
				System.out.println("1:"+result.getFieldError("writer").getCode());
			}
			if(result.getFieldError("content") != null) {
				System.out.println("2:"+result.getFieldError("content").getCode());
			}
			
			page = "createPage";
		}
		return page;
	}
	
	@InitBinder
	protected void initBinder(WebDataBinder binder) {
		binder.setValidator(new ContentValidator());
	}
}

```

### Valid 어노테이션 사용하기

- 어노테이션을 이용한 데이터 유효성 검사방법
- 유효성 검증 클래스 필요없음 (ContentValidator)

```java
package com.study.springboot;

import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

import lombok.Data;

@Data
public class ContentDTO {
	private int id;
	@NotNull(message = "writer is null")
	@NotEmpty(message = "writer is empty")
	@Size(min = 3,max=10,message = "writer min 3, max 10")
	private String writer;

	@NotNull(message = "content is null")
	@NotEmpty(message = "content is empty")
	private String content;
}

```

```java
package com.study.springboot;

import javax.validation.Valid;

import org.springframework.stereotype.Controller;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class MyController {

	@RequestMapping("/")
	@ResponseBody
	public String root() throws Exception {
		return "Validator(4)";
	}
	
	@RequestMapping("/insertForm")
	public String insert1() {
		return "createPage"; // createPage.jsp 리턴
	} 
	
	@RequestMapping("/create")
	public String insert2(@ModelAttribute("dto") @Valid ContentDTO contentDto,BindingResult result) {
		String page = "createDonePage";
		System.out.println(contentDto);
		
		if(result.hasErrors()) {
			if(result.getFieldError("writer") != null) {
				System.out.println("1:"+result.getFieldError("writer").getDefaultMessage());
			}
			if(result.getFieldError("content") != null) {
				System.out.println("2:"+result.getFieldError("content").getDefaultMessage());
			}
			
			page = "createPage";
		}
		return page;
	}
}

```

## SQL200제 63번 - 69번

### 63. 여러 테이블의 데이터를 조인해서 출력하기 (USING절)

WHERE절 대신 USING 절을 사용하여 조인하려면 ANSI 문법 사용

- USING 
  - 두 개의 테이블이 내부 조인으로 조인 될 때 조인하고자 하는 두 테이블의 컬럼명이 같을 경우 조인 조건을 길게 적지 않고 간단하게 적을 수 있도록 하는 역할
  - 괄호를 반드시 사용 안쓰면 에러 발생
  - 괄호안에는 테이블명이나 테이블 별칭을 사용할 수 없음

```SQL
SELECT e.ename as 이름 , e.job as 직업 , e.sal as 월급 , d.loc as 부서위치
        FROM emp e
        JOIN dept d
        USING(deptno)
        WHERE e.job = 'SALESMAN';
        
--여러개 jOIN
SELECT e.ename, d.loc , s.grade
    FROM emp e
    JOIN dept d USING (deptno)
    JOIN salgrade s ON (e.sal BETWEEN s.losal and s.hisal);  
```

### 64. 여러 테이블의 데이터를 조인해서 출력하기 (NATURAL JOIN)

조인 조건을 주지 않고 EQUI 조인을 하려면 NATURAL 조인을 사용

두 테이블에 둘 다 존재하는 동일한 컬럼을 기반으로 암시적인 조인을 수행

```SQL
--두 테이블 모두 가지고 있는 deptno를 사용해서 조인
SELECT e.ename as 이름 , e.job as 직업 , e.sal as 월급 , d.loc as 부서위치
    FROM emp e NATURAL JOIN dept d
    WHERE e.job = 'SALESMAN';

--WHERE절에 DEPTNO를 사용할 경우 테이블명이나 테이블별칭이 오면 안된다.
SELECT e.ename as 이름 , e.job as 직업 , e.sal as 월급 , d.loc as 부서위치
    FROM emp e NATURAL JOIN dept d
    WHERE e.job = 'SALESMAN' AND deptno = 30;
```

### 65. 여러 테이블의 데이터를 조인해서 출력하기 (LEFT/RIGHT OUTER JOIN)

![2454314856E6706C01](https://user-images.githubusercontent.com/52770718/122549708-c29cca00-d06d-11eb-8ab4-71a8510b8a56.png)

```SQL
--오른쪽 테이블 DEPT의 모든 내용도 출력
SELECT e.ename as 이름 , e.job as 직업 , e.sal as 월급 , d.loc as 부서위치
    FROM emp e RIGHT OUTER JOIN dept d
    ON (e.deptno = d.deptno);
    
--왼쪽 EMP의 모든 내용도 출력
SELECT e.ename as 이름 , e.job as 직업 , e.sal as 월급 , d.loc as 부서위치
    FROM emp e LEFT OUTER JOIN dept d
    ON (e.deptno = d.deptno);
```

### 66. 여러 테이블의 데이터를 조인해서 출력하기 (FULL OUTER JOIN)

![SQL Full JOIN, FULL OUTER JOIN Syntax - with Examples - Dofactory](https://www.dofactory.com/img/sql/sql-full-join.png)

```SQL
SELECT e.ename as 이름 , e.job as 직업 , e.sal as 월급 , d.loc as 부서위치
    FROM emp e FULL OUTER JOIN dept d
    ON (e.deptno = d.deptno);
```

### 67. 집합 연산자로 데이터를 위아래로 연결하기 (UNION ALL)

여러 개의 쿼리 결과 데이터를 위아래로 하나의 결과로 출력할 때 사용

![mysql_union_all](https://myservername.com/img/other/41/mysql-union-comprehensive-tutorial-with-union-examples-3.jpg)

- 집합 연산자 작성 시 주의사항
  1. UNION ALL 위쪽 쿼리와 아래쪽 쿼리 컬럼의 개수가 동일
  2. UNION ALL 위쪽 쿼리와 아래쪽 쿼리 컬럼의 데이터 타입이 동일
  3. 결과로 출력되는 컬럼명은 위쪽 쿼리의 컬럼명으로 추력
  4. ORDER BY 절은 제일 아래쪽 쿼리에만 작성
- 위쪽 쿼리 결과 데이터와 아래쪽 쿼리 결과 데이터 중 동일한 데이터가 있어도 중복을 제거하지 않고 그대로 출력

```SQL
--부서 번호와 부서 번호별 토탈 월급을 출력하는 쿼리
SELECT deptno ,sum(sal)
    FROM emp
    GROUP BY deptno
UNION ALL
--전체 토탈 월급을 출력하는 아래쪽 쿼리
SELECT TO_NUMBER(NULL) as deptno , sum(sal)
    FROM EMP;
```

### 68. 집합 연산자로 데이터를 위아래로 연결하기 (UNION)

![mysql_union](https://myservername.com/img/other/41/mysql-union-comprehensive-tutorial-with-union-examples.jpg)

- UNION 과 UNION ALL 의 차이점
  1. 중복된 데이터를 하나의 고유한 값으로 출력
  2. 첫 번째 컬럼의 데이터를 기준으로 내림차순으로 정렬하여 출력

```SQL
--부서 번호와 부서 번호별 토탈 월급을 출력하는 쿼리
SELECT deptno ,sum(sal)
    FROM emp
    GROUP BY deptno
UNION
--전체 토탈 월급을 출력하는 아래쪽 쿼리
SELECT NULL as deptno , sum(sal)
    FROM EMP;
```

### 69. 집합 연산자로 데이터의 교집합 출력하기 (INTERSECT)

두 테이블 간에 교집합 데이터를 출력하기 위해서는 INTERSECT를 사용합니다.

![SQL Server INTERSECT Explained By Practical Examples](https://www.sqlservertutorial.net/wp-content/uploads/SQL-Server-INTERSECT-Illustration.png)

```SQL
--부서 번호 10번과 20번인 사원들의 데이터
SELECT ename , sal , job , deptno
    FROM emp
    WHERE deptno IN (10,20)
INTERSECT -- 교집합인 20번 데이터를 출력
--부서 번호 20번과 30번인 사원들의 데이터
SELECT ename , sal , job ,deptno
    FROM emp
    WHERE deptno IN (20,30);
```

