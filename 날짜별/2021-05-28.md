# 2021-05-28

## 코팅테스트 - Recursive, Tree, Graph(DFS, BFS 기초 ,활용)

### 14. 그래프 최단거리(BFS)

![image](https://user-images.githubusercontent.com/52770718/119921250-a050e880-bfa8-11eb-9f15-cabd0e96100b.png)

```java
package sec07;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Sol14 {
	static int n,m,answer = 0;
	static ArrayList<ArrayList<Integer>> graph;
	static int[] ch , dis;

	public static void BFS(int v) { 
		Queue<Integer> queue = new LinkedList<>();
		ch[v] = 1; // 내 자신 체크
		dis[v] = 0; //1에서 1로가는 최단거리
		queue.offer(v);
		while(!queue.isEmpty()) {
			int cv = queue.poll(); 
			for(int nv : graph.get(cv)) { //인접리스트가져옴
				if(ch[nv] == 0) { // 간적이 없는 노드
					ch[nv] = 1;
					queue.offer(nv);
					dis[nv] = dis[cv] +1; // 최단거리 구하기
				}
			}
		}
	}

	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		n= kb.nextInt(); // 노드의 갯수
		m=kb.nextInt(); //간선 수
		graph = new ArrayList<ArrayList<Integer>>();
		for(int i=0;i<=n;i++) {
			graph.add(new ArrayList<Integer>());
		}
		ch = new int[n+1];
		dis = new int[n+1];
		for(int i=0;i<m;i++) {
			int a = kb.nextInt();
			int b = kb.nextInt();
			graph.get(a).add(b);
		}
		BFS(1);
		for(int i=2;i<=n;i++) {
			System.out.println(i+ " : "+dis[i]);
		}
	}
}

```

- 숙제

  ![image](https://user-images.githubusercontent.com/52770718/119922068-08ec9500-bfaa-11eb-95bd-99d08de4b72c.png)

  ```java
  package sec07;
  
  import java.util.ArrayList;
  import java.util.LinkedList;
  import java.util.Queue;
  import java.util.Scanner;
  
  public class Sol14_1 {
  	static int n,m,answer = 0;
  	static ArrayList<ArrayList<Integer>> graph;
  	static int[] ch ,dist;
  
  	public static void BFS(int v) { 
  		Queue<Integer> queue = new LinkedList<>();
  		ch[v] = 1; // 내 자신 체크
  		queue.offer(v);
  		int L = 0;
  		while(!queue.isEmpty()) {
  			int len = queue.size();
  			for(int i=0;i<len;i++) {
  				int cv = queue.poll();
  				for(int nv : graph.get(cv)) {
  					if(ch[nv] == 0) {
  						ch[nv] = 1;
  						queue.offer(nv);
  					}
  				}
  				System.out.println(cv +" : "+L);
  			}
  			L++;
  		}
  	}
  
  	public static void main(String[] args) {
  		Scanner kb = new Scanner(System.in);
  		
  		n= kb.nextInt(); // 노드의 갯수
  		m=kb.nextInt(); //간선 수
  		graph = new ArrayList<ArrayList<Integer>>();
  		for(int i=0;i<=n;i++) {
  			graph.add(new ArrayList<Integer>());
  		}
  		ch = new int[n+1];
  		dist = new int[n+1];
  		for(int i=0;i<m;i++) {
  			int a = kb.nextInt();
  			int b = kb.nextInt();
  			graph.get(a).add(b);
  		}
  		BFS(1 );
  	}
  }
  
  ```

### 1. 합이 같은 부분집합(DFS : 아마존 인터뷰)

- 인덱스를 사용한단다 안한다를 기준으로 이진검색 작성

![image](https://user-images.githubusercontent.com/52770718/119943328-dce30b00-bfcd-11eb-91d3-042faf0cfe96.png)

```java
package sec08;

import java.util.Scanner;

public class Ex01 {
	static String answer = "NO";
	static int n, total = 0;
	static boolean flag = false; //정답이 발견되면 재귀들 모두 리턴
	
	public static void DFS(int L , int sum,int[] arr) {
		if(flag) return; // flag가 true이면 전부 리턴
		if(sum > total/2) return; //sum이 절반값보다 커지면 이미 불가능
		if(L == n) { // L은 5번까지 돌고나서 돌아오면 6이 되어있으니까 
			if((total-sum) == sum) {
				answer = "YES";
				flag = true;
			}
		}else {
			DFS(L+1,sum+arr[L],arr); //인덱스 L의 값을 부분집합의 값으로 사용한다
			DFS(L+1,sum,arr); //인덱스 L의 값을 부분집합의 값으로 사용하지 않는다.
		}
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		n = kb.nextInt(); // 원소의 개수
		int[] arr = new int[n];
		for(int i=0;i<n;i++) {
			arr[i] = kb.nextInt();
			total += arr[i];
		}
		DFS(0,0,arr);
		System.out.println(answer);
	}
}

```

### 2. 바둑이 승차(DFS)

![image](https://user-images.githubusercontent.com/52770718/119947671-f5a1ef80-bfd2-11eb-8a36-b10d877cbae7.png)

- 내 풀이

  ```JAVA
  package sec08;
  
  import java.util.Scanner;
  
  public class Ex02 {
  	static int  c , n ,sum,max;
  	public static void DFS(int L , int sum,int[] arr) {
  		if(sum > c) return;
  		if(L == n) {
  			if(sum > max) {
  				max = sum;
  			}
  		}else {
  			DFS(L+1, sum+arr[L], arr);
  			DFS(L+1, sum, arr);
  		}
  	}
  	
  	public static void main(String[] args) {
  		Scanner kb = new Scanner(System.in);
  		
  		c = kb.nextInt(); // 트럭의최대 무게
  		n = kb.nextInt(); // 바둑이의 마리수
  		int[] arr = new int[n];
  		for(int i=0;i<n;i++) {
  			arr[i] = kb.nextInt(); // 바둑이당 무게
  		}
  		DFS(0,0,arr);
  		System.out.println(max);
  	}
  }
  
  ```

- 풀이

  ```JAVA
  package sec08;
  
  import java.util.Scanner;
  
  public class Sol02 {
  	static int  c , n ,answer=Integer.MIN_VALUE;
  	
  	public static void DFS(int L , int sum,int[] arr) {
  		if(sum > c) return;
  		if(L == n) { //부분집합 완성
  			answer = Math.max(answer, sum);
  		}else { //부분집합 완성 x
  			DFS(L+1, sum+arr[L], arr);
  			DFS(L+1, sum, arr);
  		}
  	}
  	
  	public static void main(String[] args) {
  		Scanner kb = new Scanner(System.in);
  		
  		c = kb.nextInt(); // 트럭의최대 무게
  		n = kb.nextInt(); // 바둑이의 마리수
  		int[] arr = new int[n];
  		for(int i=0;i<n;i++) {
  			arr[i] = kb.nextInt(); // 바둑이당 무게
  		}
  		DFS(0,0,arr);
  		System.out.println(answer);
  	}
  }
  
  ```


## Spring 프로젝트 ( todolist)

- 오늘 한일 
  - completed 상황에서도 지울 수 있게 설정
  - 기한이 지나면 스케쥴러를 통해서 매일 자정에 todo_state가 변할 수 있게끔 만듬
- 내일 할일
  - todo_state가 'HAS-DUE-DATE' 일때 프론트 부분 , 백엔드 부분 처리
  - 실제로 테스트 해보기

## 스프링 입문을 위한 자바 객체지향 원리와 이해

### 참조 변수의 복사

```java
package reference;

public class CallByValue {
	public static void main(String[] args) {
		int a = 10;
		int b = a; //값이 복사됨
		
		b= 20;
		
		System.out.println(a); // 10
		System.out.println(b); // 20
	}
}

```

```java
package reference;

class Animal{
	int age;
}
public class CallByReference {
	public static void main(String[] args) {
		Animal ref_a = new Animal();
		Animal ref_b = ref_a;
		
		ref_a.age = 10;
		ref_b.age = 20;
		
		System.out.println(ref_a.age); //20
		System.out.println(ref_b.age); // 20
	}
}

```

- CallByValue (값에 의한 호출)에 의해 그 값이 복사되며 두 개의 변수는 서로에게 영향을 주지 않는다
- CBV  와 CBR 의 차이점
  - 기본 자료형 변수는 저장하고 있는 값을 그 값 자체로 해석
  - 객체 참조 변수는 저장하고 있는 값을 주소로 해석
- 정리
  - **기본 자료형 변수는 값을 값 자체로 판단**
  - **참조 자료형 변수는 값을 주소, 즉 포인터로 판다**
  - **기본 자료형 변수를 복사할 때 , 참조 자료형 변수를 복사할 때 일어나는 일은 같다.**
    **즉 가지고 있는 값을 그대로 복사해서 넘겨준다**

### abstract 키워드 - 추상 메서드와 추상 클래스

```java
package abstractMethod1;

public class 동물 {
	void 울어보세요() {
		System.out.println("나는 동물.. 어떻게 울어야하나요");
	}
}

```

```java
package abstractMethod1;

public class 고양이  extends 동물{

	@Override
	void 울어보세요() {
		System.out.println("야옹");
	}
	
}

```

```java
package abstractMethod1;

public class 쥐  extends 동물{

	@Override
	void 울어보세요() {
		System.out.println("찍찍");
	}
	
}

```

```java
package abstractMethod1;

public class 병아리  extends 동물{

	@Override
	void 울어보세요() {
		System.out.println("삐약삐약");
	}
	
}

```

```java
package abstractMethod1;

public class Driver {
	public static void main(String[] args) {
		동물[] 동물들 = new 동물[3];
		
		동물들[0] = new 쥐();
		동물들[1] = new 고양이();
		동물들[2] = new 병아리();
		
		for(동물 동물 : 동물들) {
			동물.울어보세요();
		}
	}
}

```

- 동물 클래스 인스턴스는 어떻게 울어야 하나?
- 동물 클래스를 안만들면 울어보세요를 호출할 수없다..
- 실수로 동물 객체를 만들어서 호출하면 어떻게 하나?

=> **추상 메서드를 이용해서 메서드 선언은 있으되 몸체는 없는 형태로 만들어 놓음**

```java
package abstractMethod2;

public abstract class 동물 {
	abstract void 울어보세요();
}

```

```java
package abstractMethod2;

public class Driver {
	public static void main(String[] args) {
		동물[] 동물들 = new 동물[3];
		
		동물들[0] = new 쥐();
		동물들[1] = new 고양이();
		동물들[2] = new 병아리();
		
		for(동물 동물 : 동물들) {
			동물.울어보세요();
		}
		
		//추상클래스는 객체 생성 안됨
		//동물 짐승 = new 동물();
	}
}

```

```java
package abstractMethod2;

public class 고양이  extends 동물{

	//하위 클래스에게 메서드의 구현을 강제
//	@Override
	//void 울어보세요() {
//		System.out.println("야옹");
	//}
	
}

```

- 정리
  - **추상 클래스는 인스턴스, 즉 객체를 만들 수없다. 즉 new 사용못함**
  - **추상 메서드는 하위 클래스에게 메서드의 구현을 강제 , 오버라이딩 강제**
  - **추상 메서드를 포함하는 클래스는 반드시 추상 클래스여야 한다.**

### 생성자

-  = new 클래스명() 

  - 클래스명()  도 하나의 메서드
  - 반환값이 없고 클래스명과 같은 이름을 가진 메서드를 생성자라고 한다.

- 개발자가 아무런 생성자도 만들지 않으면 자바는 인자가 없는 기본 생성자를 자동으로 만들어줌

- 인자가 있는 생성자를 하나라도 만든다면 자바는 기본 생성자를 만들어주지 않는다.

  ![image](https://user-images.githubusercontent.com/52770718/119973076-f8f6a480-bfed-11eb-8ede-47e794f05d9b.png)