# 2021-07-29

## OS 4강 프로세스 스케쥴링

### 프로세스 스케쥴링

- 컴퓨터 시스템의 성능을 높이기 위해 그 사용 순서를 결정하는 정책
- 오버헤드 최소화
- 균형있는 자원의 사용
- 무한 연기 회피

### 프로세스 스케쥴링 기법

- 비선점
  - 비효율적 
  - 비양보
  - CPU를 강제로 빼앗을 수 없고 사용이 끝날 때까지 기다려야 한다
  - 일괄 처리 ( 오버헤드 발생 X) 
  - FIFO 
  - SJF
  - HRN
- 선점(양보)
  - 양보
  - 효율적
  - CPU를 강제로 빼앗을 수 있다.
  - 대화식 시분할 처리 ( 오버헤드 발생O)
  - RR
  - SRT

### 비선점 > FIFO == FCFS

- 준비상태에서 도착한 순서에 따라 CPU 할당
- 평균 반환시간
  - 평균 실행시간 + 평균 대기시간

### 비선점 >  SJF (Shortest Job First)

- 실행 시간 추정치가 가장 작은 작업을 먼저 실행
- FIFO보다 평균 대기 시간이 작지만 긴 작업의 경우 FIFO 기법보다 더 크고 예측이 어렵다.
- 실행시간이 큰 작업은 무한연기(기근현상) 가능성 있음
  - Aging기법으로 강제 우선순위를 부여해서 해결

### 비선점 > HRN

- SJF 방식의 단점을 보완
- 우선 순위 계산식
  - (대기시간 + 서비스 시간) / 서비스 시간

### 비선점 > 그 외

- 우선순위
  - 대기 큐에서 기다리는 각 프로세스마다 우선 순위를 부여
- 기한부
  - 프로세스에게 일정한 시간을 주어 그 시간 안에 프로세스를 완료하도록 하는 기법

### 선점 > RR

- 대화식 시분할 시스템
- FIFO 방식을 선점형 기법
- 할당되는 시간이 클 경우 FCFS 기법과 같아지고 , 할당되는 시간이 작을 경우 문맥교환 및 오버헤드가 자주 발생

### 선점 > SRT

- SJF방식으로 선점형 기법
- 현재 실행중인 프로세스의 남은 시간과 준비상태 큐에 새로 도착한 프로세스의 실행 시간을 비교하여 가장 짧은 시간을 요구하는 프로세스에게 CPU를 할당

### 선점 > 그 외

- 다단계 큐
  - 우선순위에 따라 시스템 프로세스, 대화형 프로세스 , 일괄처리 프로세스 등으로 상위,중위,하위 단계의 단계별 준비 큐를 배치
- 다단계 피드백 큐
  - 여러 개의 큐를 두어 낮은 단계로 내려갈수록 프로세스의 시간 할당량을 크게함

### 문맥교환 (Context switching)

중앙처리장치를 사용하여 실행되고 있는 프로세스의 상태 정보를 저장하고, 앞으로 실행될 프로세스의 상태정보를 설정한 다음에 중앙처리장치를 할당하여 실행이 되도록 하는 작업을 의미

- 오버헤드의 가장 큰 요인 중 하나

### 노화(aging 기법)

기다린 시간에 비례하는 높은 우선 순위를 부여하여 가까운 시간 안에 자원이 할당되도록 하는 기법

- 무한 연기를 방지

## OS 5강 병행 프로세스와 교착상태

### 병행 프로세스

두 개 이상의 프로세스들이 동시에 존재하며 실행 상태에 있는 것

- 문제점
  - 한정된 자원에 대한 사용 순서 등 여러 가지 문제가 발생 할 수 있다.
- 해결책
  - 임계구역 , 상호배제 , 동기화

### 임계구역(Critical Section)

한 순간에는 반드시 하나의 프로세스에 의해서만 자원 또는 데이터가 사용되도록 함

하나의 프로세스만 자원을 이용할 수 있도록 보호된 영역

### 상호배제(Mutual Exclusion)

한 프로세스가 공유 메모리 혹은 공유 파일을 사용하고 있을 때 다른 프로세스들이 사용하지 못하도록 배제시키는 제어 기법

- 데커 알고리즘
  - 교착상태가 발생하지 않음을 보장
  - 공유 데이터에 대한 처리에 있어서 상호 배제를 보장
  - 소프트웨어 해결

### 동기화 기법 > 세마포어

- 각 프로세스에 제어 신호를 전달하여 순서대로 작업을 수행하도록 하는 기법
- 다익스트라가 제안
- P와 V라는 2개의 연산에 의해서 동기화를 유지
- P 연산은 Wait , S = S-1
- V 연산은 Signal , S = S+1
- S는 세마포어 변수(제어신호) 0(사용중) , 1(사용가능) 혹은 0과 양의 값을 가질 수 있음

### 동기화 기법 > 모니터

- 데이터와 데이터를 처리하는 프로시저로 구성됨
- 자료 추상화와 정보 은폐 개념을 기초
- 프로세스는 반드시 모니터의 진입부를 호출
- 외부의 프로세스는 직접 엑세스 할 수 없음
- 모니터에 사용되는 연산은 Wait ,  Signal이 있다

### 교착상태 : 예측 못한 다운

상호 배제에 의해 나타나는 문제점

서로 다른 프로세스가 점유하고 있는 자원을 요구하며  무한정 기다리는 현상

### 교착상태 발생 4가지 필요충부 조건( 동시 만족 시 발생)

1. 상호배제(Mutual Exclusion)
2. 점유와 대기(Hold & wait)
3. 비선점 (nonpreemption)
4. 환형대기(Circular wait)

### 교착상태 해결방안

1. 예방기법(Prevention) 
   - 교착 상태 발생의 4가지 조건 중에서 상호 배제를 제외한 어느 하나를 부정함으로써 수행
   - 해결방안 중 자원의 낭비가 가장 심함
2. 회피 기법(Avoidance)
   - 발생 가능성을 인정하고 교착상태 가능성을 피해가는 방법
   - 은행원 알고리즘이 사용됨
3. 발견기법(Detection)
4. 회복기법(Recovery)
   - 교착 상태를 일으킨 프로세스를 종료 or 할당된 자원을 선점하여 프로세스나 자원을 회복

### 은행원 알고리즘

- 다익스트라가 제안한 회피기법
- 모든 프로세스가 완료될 수 있는 상태를 안전상태
- 교착 상태가 발생할 수 있는 상태를 불안전 상태

## OS 6강 기억장치 관리기법

### 기억장치 관리 전략

- 반입 전략

  - 보조기억장치의 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지

- 배치 전략

  - 주기억장치의 어디에 위치시킬것인지

  1. 최초 적합(First fit)

     가정 처음에 가능한 공간에 배치

  2. 최적 적합(Best fit)

     남는 공간이 적도록

  3. 최악 적합(worst fit)

  - 단편화

    - 내부 단편화 

      할당 후 남은 공간

    - 외부 단편화

      할당 하지 못한 공간

- 교체 전략

  - 주기억장치의 모든 영역이 이미 사용중인 상태에서 어느 영역을 교체하여 사용할 것인지

### 단편화 해결 방법

- 통합(Coalescing) 기법
  - 인접해 있는 단편화된 공간을 하나의 공간 통합
- 집약(Compaction) 기법
  - 분산되어 있는 단편화된 빈 공간을 결합하여 하나의 큰 가용 공간을 만듬

### 주기억장치 할당 기법 > 단일분할 할당(단일 프로그래밍) > 스와핑

- 경계 레지스트
- 하나의 프로그램 전체를 주기억장치에 할당

### 주기억장치 할당 기법 > 단일분할 할당(단일 프로그래밍) > 오버레이

- 실행되어야 할 작업의 크기가 커서 사용자의 기억 공간에 수용될 수 없을 때 작업을 분할하여 필요한 부분만 교체

### 주기억장치 할당 기법 > 단중분할 할당(다중 프로그래밍) > 고정 분할

- 주기억장치를 미리 몇 개의 고정된 개수와 크기의 부분으로 분할하여 여러 개의 프로그램이 동시에 적재되어 실행되게 하는 방법

### 주기억장치 할당 기법 > 단일분할 할당(다중 프로그래밍) > 가변 분할

- 고정 분할 할당 기법의 단편화를 줄이기 위한 것으로 프로그램을 주기억장치에 적재하면서 필요한 만큼의 크기로 영역을 분한
- 외부 단편화 발생

### 가상기억장치의 개요

- 보조기억장치의 일부분을 주기억장치처럼 사용

- 용량이 적은 주기억장치를 마치 큰 용량이 있는 것 처럼 사용하는 것
- 프로그램을 여러 개의 작은 블록으로 나누어서, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당
- 주기억장치보다 용량이 큰 프로그램을 실행하기 위해 사용
- 가상기억장치의 주소를 주기억장치의 주소로 변환하는 작업이 필요 (매핑)

### 페이징 기법

- 가상기억장치에 보관되어 있는 프로그램과 주기억장츼 영역을 동일한 크기로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역 (페이지 프레임, 블록)에 적재시켜 실행

- 주소변환 ( mapping ) 

  가상주소(보조기억장치) -> 실주소(주기억장치)

- 주소 변환을 위해 페이지 맵핑 테이블이 필요 -> 기억장소 낭비

- 페이지 부재 

  P/G 실행 시 참조한 페이지가 주기억장치에 없는 현상

- 외부단편화(X) , 내부단편화(O)

- 페이지 크기가 작을 경우

  - 페이지 수 증가
  - 페이지 맵핑 테이블 커짐
  - 맵핑 속도 느려짐
  - 디스크 접근 횟수 증가
  - 전체적인 입,출력 시간 늘어남
  - 한개의 페이지를 주기억장치로 이동하는 시간이 줄어듬
  - 기억장치의 효율이 높아짐

### 세그먼테이션 기법

- 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 적재 => 메모리 절약
- 다른 세그먼트에게 할당된 영역을 침범할 수 없으며 이를 위해 기억장치 보호기가 필요함
- 외부단편화(O) , 내부단편화(X)

### 가상기억장치의 성능에 영향을 미치는 요인

1. 워킹셋

   - 일정시간동안 자주 참조하는 페이지들의 집합 
   - 주기억장치에 상주 시킴

2. 스레싱

   - 프로세스의 처리 시간보다 페이지 교체 시간이 더 많아 지는 현상
   - 페이지 부재가 크다
   - 다중 프로그래밍의 정도가 높을수록 스레싱의 발생빈도 높아짐
   - 해결방법
     - 다중 프로그래밍 정도 낮춤
     - cpu 이용률 증가
     - 워킹셋 방법 사용

3. 구역성 (Locality , 국부성)

   - 프로세스가 실행되는 동안 일부 페이지만 집중적으로 참조하는 성질

   1. 시간 구역성
      - 최근에 참조된 기억 장소가 다시 참조될 확률 높음
      -  루프 , 스택, 서브루틴, 카운팅 등ㄷ으
   2. 공간 구역성
      - 참조된 장소 근처에서 참조될 확률이 높음
      - 순차적 코드 실행 ,  배열 순회 , 같은 영역에 있는 변수 참조

## OS 7강 페이지 교체 알고리즘

### 페이지 교체 알고리즘

- 페이지 부재가 발생하였을 경우 , 가상기억장치의 필요한 페이지를 주기억장치의 어떤 페이지 프레임을 선택, 교체해야 하는가 결정

### FIFO

주기억장치 내에 가장 오래 있었던 페이지를 교체

- 벨레이디의 모순 현상
  - 페이지 프레임 수가 증가하면 페이지 부재가 더 증가

### OPT

- 사용하지 않을 페이지를 교체
- 실현가능성 없음

### LRU (Least Recently Used)

- 가장 오랫동안 사용하지 않은 페이지를 교체

### LFU(Least Frequently Used)

- 사용횟수가 가장 적은 페이지 교체

### NUR(Not Used Recently)

- 최근에 사용하지 않은 페이지를 교체
- 2개의 하드웨어 비트가 사용됨