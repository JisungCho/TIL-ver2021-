# 2021-06-28

## 코딩테스트 Array

###  제로 이동(Move Zeros) 

1. 문제분석
   1. 값이 0이 아닌값을 먼저 array에 담는다.
   2. index를 기억한다
   3. 해당 index에 0인 값을 넣는다.

```java
package sec02;

public class MoveZeros {
	public static void solve(int[] nums) {
		int n = nums.length;
		int index = 0;
		
		//2.for
		
		//3,2,8,5,0,0만들기
		
		//3.2.8.5
		for(int i=0;i<n;i++) {
			if(nums[i] != 0) {
				nums[index] = nums[i];
				index++;
			}
		}
		
		//3,2,8,5,0,0
		while(index < n) {
			nums[index] = 0;
			index++;
		}
		
		for(int i : nums) {
			System.out.print(i+" ");
		}
		System.out.println();
		
		
		
		
		// 0,0,3,2,8,5만들기
		
		// 땡,땡,3,2,8,5
		index = n-1; // 5
		for(int i = n-1 ;i>=0;i--) {
			if(nums[i] != 0 ) {
				nums[index] = nums[i];
				index--;
			}
		}
		
		//0 ,0 ,3,2,8,5
		while(index >= 0) {
			nums[index] = 0;
			index--;
		}
		
	
		for(int i : nums) {
			System.out.print(i+" ");
		}
	}
	public static void main(String[] args) {
		int[] nums = {0,3,2,0,8,5};
//		int[] nums = {0,1};
		solve(nums);
		
	}
}

```

### k번째 제일큰 원소 (Kth Largest Element In An Array)

1. 문제분석

   1번풀이

   1. 값을 소팅한다
   2.  k = 2 번째로 큰 값을 찾는다.

   2번풀이

   1. pq를 이용하여 사이즈를 유지
   2. 뽑음

```java
package sec02;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.PriorityQueue;

public class KthLargestElementInAnArray {
	public static void main(String[] args) {
		int[] nums = { 2,3,1,5,6,4};
		int k=2 ;
		
		System.out.println(solve(nums, k));
		System.out.println(sovle_pq(nums, k));
	}
	
	//sort이용
	public static int solve(int[] nums , int k) {
		Arrays.sort(nums);
		int n = nums.length;
		return nums[n-k]; // 1,2,3,4,5,6; // 4번방
	}
	
	//pq이용
	public static int sovle_pq(int[] nums,int k) {
		//default는 오름차순 , minHeap
		PriorityQueue<Integer> pq = new PriorityQueue<>();
		
		for(int i : nums) {
			pq.offer(i);
			if(pq.size() > k) {
				pq.poll();
			}
		}
		return pq.peek();
	}
}

```

### 원점에 가장 가까운 지점 (K Closest Points to Origin) 

1. 문제분석
   1. 원점으로 부터의 거리를 구한다.
   2. 원점에서 제일 작은 거리에 있는 값을 구한다.
   3. 제일 작은 값부터 저장한다 (pq이용)

```java
package sec02;

import java.util.Arrays;
import java.util.Collections;
import java.util.PriorityQueue;

public class KClosestPointstoOrigin {
	public static void main(String[] args) {
//		int[][] points = { { 1, 3 }, { -2, 2 } };
//		int k = 1;
		int[][] points = {{3,3},{5,-1},{-2,4}};
		int k =2;

		int[][] result = solve(points, k);
		print(result);
	}

	public static int[][] solve(int[][] points, int k) {
		// 1. ds
		PriorityQueue<int[]> pq = new PriorityQueue<>(
				(a, b) -> (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1]));
		
		int[][] result = new int[k][2];

		// 2. for, while
		for (int[] p : points) {
			pq.offer(p);
		}
		int index = 0;
		while (index < k) {
			result[index] = pq.poll();
			index++;
		}
		return result;
	}

	public static void print(int[][] result) {
		int m = result.length;
		int n = result[0].length;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				System.out.print(" [" + i + "][" + j + "] " + result[i][j]);
			}
			System.out.println();
		}
	}
}

```

## 스프링 입문을 위한 객체지향의 원리와 이해

### 스프링을 통한 의존성 주입 - XML 파일 사용

- 의사코드

  - 운전자가 종합 쇼핑몰에서 타이어를 구매
  - 운전자가 종합 쇼핑몰에서 자동차를 구매
  - 운전자가 자동차에 타이어를 장착

- 자바코드로 표현

  ```java
  ApplicationContext context = new FileSystemXmlApplicationContext("/src/main/java/expert002/expert.xml");
  
  Tire tire = (Tire)context.getBean("tire");
  Car car = (Car)context.getBean("car");
  
  car.setTire(tire);
  
  ```

결국 거의 대부분의 소스코드는 바꾸지 않아도되고 Spring 설정 파일만 추가해주면 끝이다.

![003](https://user-images.githubusercontent.com/52770718/123725229-b9f78f80-d8c8-11eb-952f-2b4ecfe630b7.PNG)

#### 소스

##### Driver

```java
package expert002;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.FileSystemXmlApplicationContext;

public class Driver {
 public static void main(String[] args) {
  //Spring(종합쇼핑몰)에 대한 정보
  ApplicationContext context = new FileSystemXmlApplicationContext("/src/main/java/expert002/expert.xml");
  Tire tire = (Tire)context.getBean("tire");
  Car car = (Car)context.getBean("car");
  car.setTire(tire);

  System.out.println(car.getTireBrand());
 }
}

```

##### xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd">

 <bean id="tire" class="expert002.KoreaTire"></bean>

 <bean id="americaTire" class="expert002.AmericaTire"></bean>

 <bean id="car" class="expert002.Car"></bean>
 
</beans>

```

![011A744350B2F7B107](https://user-images.githubusercontent.com/52770718/123725262-cb409c00-d8c8-11eb-98a8-903026ce5ff5.png)

#### 결론

**재컴파일 없이 xml 파일만 수정하면 프로그램의 실행 결과를 바꾸어 줄 수 있다.**

### 스프링을 통한 의존성 주입 - 스프링 설정 파일(xml)에서 속성 주입

- 의사코드
  - 운전자가 종합 쇼핑몰에서 자동차를 구매 요청한다.
  - 종합 쇼핑몰은 자동차를 생산한다.
  - 종합 쇼핑몰은 타이어를 생산한다.
  - **종합 쇼핑몰은 자동차에 타이어를 장착한다.**
  - 종합 쇼핑몰은 운전자에게 자동차를 전달한다.
- java로 표현

```java
ApplicationContext context = new FileSystemXmlApplicationContext("/src/main/java/expert003/expert.xml");
Car car = (Car)context.getBean("car");

```

- xml

```xml
<bean id="koreaTire" class="expert003.KoreaTire"></bean>
<bean id="americaTire" class="expert003.AmericaTire"></bean>
<bean id="car" class="expert003.Car">
       <property name="tire" ref="koreaTire"></property>
</bean>

```

![015BCA3350B37CD936](https://user-images.githubusercontent.com/52770718/123725349-ed3a1e80-d8c8-11eb-98ad-5c9d4f745e5d.png)

![033D254350B38D1B26](https://user-images.githubusercontent.com/52770718/123725396-00e58500-d8c9-11eb-9063-aac8338b604f.png)

### 스프링을 통한 의존성 주입 - @Autowired를 통한 속성 주입

- 의사 코드
  - 운전자가 종합 쇼핑몰에서 자동차를 구매 요청한다.
  - 종합 쇼핑몰은 자동차를 생산한다
  - 종합 쇼핑몰은 타이어를 생산한다.
  - 종합 쇼핑몰은 자동차에 타이어를 장착한다
  - 종합 쇼핑몰은 운전자에게 자동차를 전달한다

- @Autowired 어노테이션을 사용하면 get/set 접근 메서드를 더 이상 만들지 않아도 springFramework가 설정 파일을 통해서 알아서 get/set 접근 메서드 대신 일을 해준다.

#### xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xmlns:context="http://www.springframework.org/schema/context"
 xsi:schemaLocation="http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd
  http://www.springframework.org/schema/context
  http://www.springframework.org/schema/context/spring-context-3.1.xsd">

 <context:annotation-config />

 <bean id="tire" class="expert004.KoreaTire"></bean>

 <bean id="americaTire" class="expert004.AmericaTire"></bean>

 <bean id="car" class="expert004.Car"></bean>

</beans>

```

#### Car

```java
package expert004;

import org.springframework.beans.factory.annotation.Autowired;

public class Car {
@Autowired
Tire tire;

public String getTireBrand() {
return "장착된 타이어: " + tire.getBrand();
}
}

```

![200A294050B62F4337](https://user-images.githubusercontent.com/52770718/123725472-1195fb00-d8c9-11eb-95bc-a9e35acb51f3.png)

### 번외

| **Car.java**                  | **expert.xml**                                  |
| ----------------------------- | ----------------------------------------------- |
| @Autowired<br/>Tire **tire**; | < bean class="expert004.AmericaTire" >< /bean > |

| **Car.java**         | @Autowired<br/>Tire **tire**;                    |
| -------------------- | ------------------------------------------------ |
| **expert.xml**       | < bean class="expert004.AmericaTire">< /bean>    |
| **AmericaTire.java** | public class AmericaTire **implements** **Tire** |

**Spring의 마법은 type 기준 매핑이 먼저이고 , 같은 type을 구현한 여러 개의 클래스가 있다면  그 때 bean id 로 구분해서 매핑**

![203BE93F50B648210E](https://user-images.githubusercontent.com/52770718/123725505-1bb7f980-d8c9-11eb-9b38-cbeadf194e17.png)