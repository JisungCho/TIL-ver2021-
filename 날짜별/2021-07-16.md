# 2021-07-16

## 정보처리산업기사 필기 - 데이터베이스

### 8강 선형,비선형 구조

#### 자료구조 분류

1. 선형 구조 : 순차리스트(스택,큐,디큐,배열) , 연결리스트(링크드리스트)
2. 비선형 구조 : 트리 , 그래프

#### 선형 구조

1. 순차 리스트 

   - 연속적인 기억장소에 저장

   - 구조간단,

   - 기억장소 이용 효율이 높음

   - 삽입,삭제 어려움

   - 연결리스트에 비해 검색 빠름

2. 연결리스트

   - 비연속적으로 저장

   - 포인터를 이용해 저장

   - 기억장소 이용 효율이 낮음

   - 삽입,삭제 용이
   - 순차 리스트에 비해 검색 느림

##### 스택(선형구조,순차리스트)

- LIFO

- 스택 응용 분야

  - 인터럽트 처리
  - 수식의 계싼
  - 서브루틴의 복귀번지 저장
  - 함수 호출의 순서제어

  - **운영체제의 작섭 스케쥴링 (X) => 큐**

##### 큐(선형구조,순차리스트)

- FIFO
- 노드의 삽입 작업은 선형 리스트의 한쪽 끝에서, 제거 작업은 다른 쪽 끝에서 수행되는 자료 구조
- 응용분야
  - 운영체제의 작업 스케쥴링
  - 키보드 버퍼 이용 시
  - 스풀 운용 시

##### 데크(선형구조,순차리스트)

- 삽입과 삭제가 리스트의 양쪽 끝에서 발생할 수 있는 자료 구조

#### 비선형구조

##### 트리

- 노드와 간선으로 구성되어져 았고 , 사이클이 없다
- 용어
  - 노드
  - 차수 - 가지 수
  - 루트노드 : 최상위 노드
  - 노드의 차수 : 어떤 노드의 서브트리 수
  - 트리의 차수 : 노드의 차수의 최대값
  - 단말노드 : 차수가 0인 노드
  - 형제노드 : 같은 부모 노드를 가지는 노드
  - 레벨 : 노드의 깊이
- 특징
  - 연결 리스트 구조로 표현 ( 포인터 이용)

##### 트리의 종류

###### 이진 트리

- 차수가 2 이하로 구성된 트리

###### 스레드 이진 트리

- 기억 공간의 낭비 원이 되는 널 링크 부분을 트리 순회 시 이용되도록 구성한 트리
- 널 링크를 다른 노드를 가리키는 포인터로 대체
- 실제 포인터와 스레드를 구별하기가 어렵다.

###### B-트리

- 인덱스 파일에서 인덱스를 구성하는 방법 중의 하나
- 한 노드 안에 있는 키 값은 오름차순을 유지
- 모든 단노드는 같은 레벨에 있다
- 루트노드는 리프가 아닌 이상 적어도 두개의 서브트리를 갖는다.
- 탐색,추가,삭제는 루트로부터 시작
- 인덱스 파일에서 인덱스를 구성하는 방법 중 하나

##### 이진 트리 운행법

- 전위 
  -  ROOT -> L ->R
- 중위
  - L -> ROOT ->  R
- 후위
  - L -> R -> ROOT

#### 수식 표기법

- prefix 
  - 연산자 -> L피연산자 -> R피연산자
- infix
  - L피연산자 -> 연산자 ->R피연산자
- postfix
  - L피연산자 -> R피연산자 ->  연산자

##### INFIX -> POST, PRE로 바꿀때

- 연산 우선 순위 파악
  - 괄호 -> ** 거듭제곱 -> * , / -> + , - 

PREFIX -> POST , IN

- 왼쪽에서 연산자,피연산자,피연산자 구조를 찾음

POSTFIX -> PRE , IN

- 왼쪽에서 피연산자,피연산자,연산자 구조를 찾음

### 9강 정렬,검색,해싱

#### 정렬

- 내부 정렬 
  - 주기억장치 사용 (RAM)
  - 적은 데이타 빠르게 정렬
  - 선택 정렬
  - 삽입 정렬
  - 퀵 정렬
  - 버블 정렬
  - 힙 정렬
  - 쉘 정렬
  - 2-WAY 병합 정렬
  - 기수 정렬
- 외부정렬
  - 많은 데이터 정렬
  - 병합 정렬

##### 정렬 알고리즘 선택 시 고려사항

- 데이터 양
- 초기 데이터의 배열 상태
- 키 값들의 분포상태
- 소요공간 및 작업시간
- **운영체제의 종류(X)**
- **엑세스 빈도(X)**
- **증가 데이터의 배열 상태(X)**

##### 선택 정렬

- 첫 자리부터 정렬하기 (비교 , 교환)

##### 버블 정렬

- 인접 데이터 비교
- 데이터를 한쪽으로 계속 밈

##### 삽입 정렬

- 두번째 값을 KEY로 선택해서 비교 시작

##### 2-WAY 병합 정렬

- 두 개씩 묶어서 정렬

#### 검색

###### 선형 검색

- 모든 레코드들을 대상으로 순차적 검색
- 자료가 정렬되어 있지 않을 때
- 처리 속도가 느리다

###### 이진 검색

- 자료가 정렬되어 있어야 함
- 중간 값을 비교 검색
- 많은 레코드 검색 시 효율적

###### 해싱 검색

- 해싱 함수를 이용하여 자료를 검색
- 해시 테이블이라는 배열에 저장
- 신속하게 원하는 자료를 검색할 수 있는 키-주소 변환 방법
- 특징
  - DAM파일
  - 삽입,삭제 작업의 빈도가 많을 때 유리
  - 검색은 가장 빠르지만 기억공간의 낭비 발생
- 용어
  - 해싱 함수 
    - 해시 테이블의 주소를 생성해 내는 함수
  - 버킷
    - 하나의 주소를 갖는 파일의 한 구역
  - 슬롯 
    - N개의 슬롯이 모여 하나의 버킷
  - 충돌
    - 서로 다른 2개 이상의 레코드가 같은 주소를 갖는 현상
  - 시노임
    - 같은 주소를 갖는 레코드의 집합
- 해싱 함수 종류
  - 기수법 : 다른 진법으로 변환
  - 폴딩(중첩)법 : 더하거나 XOR
  - 제산법 : 나누어 나머지
  - 제곱법 : 제곱
  - 계수 분석법 : 숫자의 분포 조사
- 오버플로우 해결방법
  - 개방주소법
    - 다음 빈 버킷에 저장
  - 폐쇄주소법
    - 별도의 공간에 저장
  - 재해싱법
    - 새로운 해싱함수를 적용

### 10강 파일편성 , 인덱스

#### 순차 파일(SAM)

- 목차 없는 책
- 파일 내의 각 레코드를 논리적 순서에 따라 물리적으로 연속된 위치에 기록한 파일
- 공간낭비X
- 삽입,삭제,검색이 어려움

#### 색인 순차 파일(ISAM) 

- 목차 있는 책
- 인덱스를 통한 랜덤 처리와 데이터의 순차 처리를 병행
- 삽입,삭제,검색 용이
- 재사용이 안됨
- 재구성이 필요
- 색인 구역 + 기본 구역 + 오버플로우 구역
- 색인 영역
  - 트랙
  - 실린더
  - 마마스터

#### 직접 파일(DAM)

- 해싱 함수

#### VSAM(동적 인덱스)

- 기본 구역과 오버플로우 구역을 구분하지 않음
- 기본 구역내에 예비 공간
- 재사용 할 수 있음
- 제어 구간에 가변 길이 레코드를 쉽게 수용

#### 역 파일

- 특정 파일을 여러 개의 색인으로 만들어 항목별 특성에 맞게 작업

#### 인덱스

- 인덱스를 통해서 테이블의 레코드에 대한 엑세스를 빠르게 수행

- 인덱스는 하나 이상의 필드로 만들어도 된다.
- 레코드 삽입과 삭제가 수시로 일어나는 경우는 인덱스를 최대화

## Array 문제풀기

### 격자판 최대합

1. 문제분석
   1. 행의 합
   2. 열의 합
   3. 대각선1의 합
   4. 대각선2의 합

```java
package sec01;

import java.util.ArrayList;
import java.util.Scanner;

class Main {
	public static int solution(int n , int[][] arr){
		int max = Integer.MIN_VALUE;
		int rowtotal;
		int coltotal;
		int dia1;
		int dia2;
		
		for(int i =0;i<n;i++) {
			rowtotal = 0;
			coltotal = 0;
			for(int j=0;j<n;j++) {
				rowtotal += arr[i][j];
				coltotal += arr[j][i];
			}
			max = Math.max(max, rowtotal);
			max = Math.max(max, coltotal);
		}
		dia1 = dia2= 0;
		for(int i=0;i<n;i++) {
			dia1 += arr[i][i];
			dia2 += arr[i][n-i-1];
		}
		max = Math.max(max, dia1);
		max = Math.max(max, dia2);
		
		return max;
	}

	public static void main(String[] args){
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt();
		int[][] arr = new int[n][n];
		for(int i =0;i<n;i++) {
			for(int j=0;j<n;j++) {
				arr[i][j] = kb.nextInt();
			}
		}
		System.out.println(solution(n,arr));
	}
}
```

### 봉우리

```java
package sec01;

import java.util.Scanner;

class Main {
	public static int solution(int n , int[][] arr){
		int count = 0;
		
		
		for(int i=0;i<n;i++) {
			for(int j=0;j<n;j++) {
				boolean flag = true;
				
				
				if(i-1 >= 0 && arr[i][j] < arr[i-1][j]) { // 상
					flag = false;
				}
				if(i+1  <  n && arr[i][j] < arr[i+1][j]){ //하
					flag = false;
				}
				if( j-1 >= 0 && arr[i][j] < arr[i][j-1]){ // 좌
					flag = false;
				}
				if(j+1 < n && arr[i][j] < arr[i][j+1]){ // 우
					flag = false;
				}
				
				if(flag) {
					count++;
				}
			}
		}
		return count;
	}

	public static void main(String[] args){
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt();
		int[][] arr = new int[n][n];
		for(int i =0;i<n;i++) {
			for(int j=0;j<n;j++) {
				arr[i][j] = kb.nextInt();
			}
		}
		System.out.println(solution(n,arr));
	}
}
```

