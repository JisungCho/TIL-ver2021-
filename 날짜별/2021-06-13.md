# 2021-06-13

## 코딩테스트 - Greedy

### 탐욕 알고리즘 이란?

- Greedy algorithm 또는 탐욕 알고리즘 이라고 불리움
- 최적의 해에 가까운 값을 구하기 위해 사용됨
- 여러 경우 중 하나를 결정해야할 때마다, **매순간 최적이라고 생각되는 경우를 선택**하는 방식으로 진행해서, 최종적인 값을 구하는 방식

그리디 알고리즘은 항상 최적의 결과를 도출해내는 것은 아니지만 어느정도 최적의 해에 근접하게 구할 수 있다는 장점이 있다.

### 1. 씨름선수

```java
package sec09;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

//정렬을 하기위해 Comparable 인터페이스 구현
class Player implements Comparable<Player>{
	int height;
	int weight;
	
	public Player(int height, int weight) {
		this.height = height;
		this.weight = weight;
	}

	//내림차순 정렬
	@Override
	public int compareTo(Player o) {
		return o.height - this.height;
	}
	
}

public class Ex01 {
	public static int solutuin(ArrayList<Player> players) {
		int answer = 1;
		int max = players.get(0).weight;
		//첫번째 항목은 무조건 뽑힘
		for(int i=1;i<players.size();i++) {
			int weight = players.get(i).weight;
			if(max < weight) {
				answer++;
				max = weight;
			}
		}
		return answer;
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt(); // 지원자수
		ArrayList<Player> players = new ArrayList<Player>();
		for(int i=0;i<n;i++) {
			players.add(new Player(kb.nextInt(), kb.nextInt()));
		}
		
		Collections.sort(players);
		
		System.out.println(solutuin(players));
		
	}
}

```

### 2. 회의실 배정

```java
package sec09;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

//정렬을 하기위해 Comparable 인터페이스 구현
class Room implements Comparable<Room>{
	int start;
	int end;
	
	public Room(int start, int end) {
		this.start = start;
		this.end = end;
	}

	//음수 또는 0이면 객체의 자리가 그대로 유지되며, 양수인 경우에는 두 객체의 자리가 바뀐다.
	@Override
	public int compareTo(Room o) {
		//오름차순 정렬
		if(o.end == this.end) {
			return this.start - o.start; 
		}
		return this.end - o.end;
	}
	
}

public class Ex02 {
	public static int solution(ArrayList<Room> rooms) {
		int cnt = 0;
		Collections.sort(rooms);
		int et = 0;
		for(Room r : rooms) {
			if(r.start >= et) {
				cnt++;
				et = r.end;
			}
		}
		return cnt;
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt(); // 회의 수
		ArrayList<Room> rooms = new ArrayList<Room>();
		for(int i=0;i<n;i++) {
			rooms.add(new Room(kb.nextInt(), kb.nextInt()));
		}
		
		System.out.println(solution(rooms));
		
	}
}

```

### 3. 결혼식

```java
package sec09;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

//정렬을 하기위해 Comparable 인터페이스 구현
class Time implements Comparable<Time>{
	public int time;
	public char state;
	

	public Time(int time, char state) {
		this.time = time;
		this.state = state;
	}


	//음수 또는 0이면 객체의 자리가 그대로 유지되며, 양수인 경우에는 두 객체의 자리가 바뀐다.
	@Override
	public int compareTo(Time o) {
		if(this.time==o.time) return this.state - o.state; //
		else return this.time-o.time;
	}
	
}

public class Sol03 {
	public static int solution(ArrayList<Time> times) {
		int answer = Integer.MIN_VALUE;
		Collections.sort(times);
		int cnt =0; //그 시각 그 순간에 사람 수
		for(Time ob : times) {
			if(ob.state == 's' ) cnt++;
			else cnt --;
			answer = Math.max(answer, cnt);
		}
		return answer;
	}
	
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		
		int n = kb.nextInt(); // 회의 수
		ArrayList<Time> times = new ArrayList<Time>();
		for(int i=0;i<n;i++) {
			int sT = kb.nextInt();
			int eT =kb.nextInt();
			 times.add(new Time(sT, 's'));
			 times.add(new Time(eT, 'e'));
		}
		
		System.out.println(solution(times));
		
	}
}

```

