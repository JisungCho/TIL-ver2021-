# 2021-05-12

## 1. todolist

- Edit 버튼을 누르고 나서의 상태

  -  V,X 표시가 나오고 기존의 edit과 delete 버튼은 사라짐

  - readonly가 바뀜

    ```javascript
        //edit 버튼 클릭
        $(".to_do_list").on("click",".edit",function(){
        	var seq = $(this).data("number");
        	$('#'+seq).removeClass("bg-transparent");
        	$('#'+seq).attr("readonly",false);
        	//v , x 버튼 추가 edit , delete버튼 삭제
        	$('#todo_check'+seq).removeClass('d-none');
        	$('#todo_cancle'+seq).removeClass('d-none');
        	$("#todo_edit"+seq).addClass("d-none");
        	$("#todo_delete"+seq).addClass("d-none");
        });
    ```

  - X 를 클릭하면 edit과 delete버튼이 다시 생성

  - readonly가 바뀜

    ```js
        //수정 취소
        $(".cancle").on("click",function(){
        	var seq = $(this).data("number");
        	$('#'+seq).addClass("bg-transparent");
        	$('#'+seq).attr("readonly",true);
        	//v , x 버튼 삭제 edit , delete버튼 추가
        	$('#todo_check'+seq).addClass('d-none');
        	$('#todo_cancle'+seq).addClass('d-none');
        	$("#todo_edit"+seq).removeClass("d-none");
        	$("#todo_delete"+seq).removeClass("d-none");
        });
    ```

  - 날짜수정 

    ```js
        //날짜수정 버튼 클릭
        $(".todo_date").on("click",function(){
        	var day = $(this).next().text();
    	    $(this).datepicker({
    	        format: "yyyy/MM/dd",
    	        autoclose: true,
    	        todayHighlight: true,
    	        clearBtn : true,
    	        startDate: day,
    	        orientation: "bottom"
    	    });	
    	    
    	    $(this).datepicker("show");
        })
    ```

  - 수정완료

    ```js
        
        //수정 완료
        $(".check").on("click",function(){
        	var seq = $(this).data("number");
        	$('#'+seq).addClass("bg-transparent");
        	$('#'+seq).attr("readonly",true);
        	//v , x 버튼 삭제 edit , delete버튼 추가
        	$('#todo_check'+seq).addClass('d-none');
        	$('#todo_cancle'+seq).addClass('d-none');
        	$("#todo_edit"+seq).removeClass("d-none");
        	$("#todo_delete"+seq).removeClass("d-none");
        	
        });
    ```

- 앞으로 할일

  - edit버튼을 클릭하면 due를 바꿀 수있도록 클릭버튼이 활성화 되고 datepicker를 이용해서 due를 수정
  - 수정완료 버튼을 누르면 ajax로 수정된 내용과 수정된 날짜가 전송됨 그리고 업데이트 됨



# 코딩테스트 - Stack, Queue(2)

## 4. 후위식 연산

- 생각

  - 숫자가 나타나면 stack에 push
  - 연산기호가 나오면  pop 을 두번해서 각각의 변수에 넣음
  - 두 숫자를 연산하고 다시 stack에 push

- 풀이

  - char는 문자이기 때문에 현재 숫자는 문자인 숫자이다 따라서 '0'의 아스키값을 빼줘서 진짜 숫자가 되도록 한다.

  ```java
  package sec05;
  
  import java.util.Scanner;
  import java.util.Stack;
  
  public class Ex04 {
  	public static int solution(String s) {
  		Stack<Integer> stack = new Stack<>();
  		int answer = 0;
  		
  		for(char c : s.toCharArray()) {
  			if(Character.isDigit(c)) { // 현재 숫자는 문자이다 ex ) '5'
  				stack.push(c - 48); // 아스키코드를 빼줘서 해당숫자로 만듬 '5' -> 5
  			}else {
  				int rt = stack.pop();
  				int lt = stack.pop();
  				if(c == '+') {
  					stack.push(lt+rt);
  				}else if(c == '-') {
  					stack.push(lt-rt);
  				}else if(c == '*') {
  					stack.push(lt*rt);
  				}else {
  					stack.push(lt/rt);
  				}
  			}
  		}
  		answer = stack.get(0);
  		return answer;
  	}
  	
  	public static void main(String[] args) {
  		Scanner kb = new Scanner(System.in);
  		
  		String s = kb.nextLine();
  		System.out.println(solution(s));
  	}
  }
  
  ```

## 5. 쇠막대기

- 내 생각

  -  여는괄호를 만나면 스택에 넣기 전에 다음을 조사해서 닫는괄호면 pop
  - 문제는 닫는 괄호일때 쇠막대기인지 레이저인지 분간할 수 가 없었음

- 풀이

  - 여는 괄호면 무조건 push

  - 닫는 괄호면 레이저인지 쇠막대기의 끝인지 알아야함

    - 문자열의 앞을 조회 
      - 여는 괄호이면 레이저 따라서 stack에서 pop하고 answer에 stack의 사이즈를 더해줌
      - 닫는 괄호이면 쇠막대기 따라서 stack에서 pop하고 answer를 1증가시킴

    ```java
    package sec05;
    
    import java.util.Scanner;
    import java.util.Stack;
    
    public class Ex05 {
    	public static int solution(String s) {
    		Stack<Character> stack = new Stack<>();
    		int answer = 0;
    		
    			for(int i=0;i<s.length();i++) {
    				if(s.charAt(i) == '(') {
    					stack.push(s.charAt(i));
    				}else {
    					if(s.charAt(i-1) == '(') {
    						stack.pop();
    						answer += stack.size();
    					}else {
    						stack.pop();
    						answer++;
    					}
    				}
    			}
    			return answer;
    		}
    	
    	public static void main(String[] args) {
    		Scanner kb = new Scanner(System.in);
    		
    		String s = kb.nextLine();
    		System.out.println(solution(s));
    	}
    }
    
    ```

## 6. 공주 구하기

- 내 생각

  - queue에다가 1부터 n까지 넣어놓음
  - queue의 갯수가 1이 될때까지 반복
  - k번 반복하면서 k번 전까지는 enqueue후 dequeue , k번 일때는 dequeue 

  ```java
  package sec05;
  
  import java.util.LinkedList;
  import java.util.Queue;
  import java.util.Scanner;
  import java.util.Stack;
  
  public class Ex05 {
  	public static int solution(int n,int k) {
  		int answer = 0;
  		Queue<Integer> queue = new LinkedList<>();
  		for(int i=1;i<=n;i++) { //queue에 다 넣어줌
  			queue.add(i);
  		}
  		
  		while(queue.size() != 1) {
  			for(int i=1;i<=k;i++) {
  				if(i == k) {
  					queue.remove();
  					break;
  				}
  				int peek = queue.peek();
  				queue.offer(peek);
  				queue.remove();
  			}
  		}
  		answer = queue.remove();
  		
  		return answer;
  	}
  	
  	public static void main(String[] args) {
  		Scanner kb = new Scanner(System.in);
  		
  		int n = kb.nextInt();
  		int k = kb.nextInt();
  		System.out.println(solution(n, k));
  	}
  }
  
  ```

- 풀이

  - queue가 empty할때까지 돌다가 queue의 사이즈가 1이면 뺀값을 answer에다가 넣고 끝냄

  ```java
  package sec05;
  
  import java.util.LinkedList;
  import java.util.Queue;
  import java.util.Scanner;
  import java.util.Stack;
  
  public class Sol06 {
  	public static int solution(int n,int k) {
  		int answer = 0;
  		Queue<Integer> queue = new LinkedList<>();
  		for(int i=1;i<=n;i++) { //queue에 다 넣어줌
  			queue.add(i);
  		}
  		
  		while(!queue.isEmpty()) {
  			for(int i=1;i<k;i++) { //k-1번
  				queue.offer(queue.poll());
  			}
  			queue.poll(); //k번일때 poll
  			if(queue.size() == 1) { // 마지막 하나
  				answer = queue.poll();
  			}
  		}
  		
  		return answer;
  	}
  	
  	public static void main(String[] args) {
  		Scanner kb = new Scanner(System.in);
  		
  		int n = kb.nextInt();
  		int k = kb.nextInt();
  		System.out.println(solution(n, k));
  	}
  }
  
  ```

## 7. 교육과정설계

- 생각

  - Q에 과목계획을 넣고 비교할려고함 , 

  - Q에서 뺀다음 비교하는게 불가능함 

  - 못품

    ```java
    package sec05;
    
    import java.util.LinkedList;
    import java.util.Queue;
    import java.util.Scanner;
    
    public class Ex07 {
    	public static String solution(String n , String k) {
    		String answer = "NO";
    		Queue<Character> q = new LinkedList<>();
    		for(int i=0;i<n.length();i++) { // q에다가 필수과목 넣어줌
    			q.offer(n.charAt(i));
    		}
    		for(int i=0;i<k.length();i++) {
    			if(q.contains(k.charAt(i))){ //해당과목이 필수과목에 있는지
    				if(q.peek() == k.charAt(i)) { // 해당과목의 순서와 필수과목의 순서가 일치한지
    					q.poll();
    				}
    			}
    		}
    		if(q.size() == 0) {
    			return answer = "YES";
    		}
    		return answer ;
    	}
    	
    	public static void main(String[] args) {
    		Scanner kb = new Scanner(System.in);
    		
    		String n = kb.nextLine();
    		String k  = kb.nextLine();
    		System.out.println(solution(n, k));
    	}
    }
    
    ```

    

- 풀이

  - 필수과목을 Q에 넣음

  - 수업계획의 한글자 한글자 비교하면서 Q에 해당 과목이 있는지 확인, 해당 과목이 Q에 맨앞에 있다면 POP

    ```java
    package sec05;
    
    import java.util.LinkedList;
    import java.util.Queue;
    import java.util.Scanner;
    
    public class Sol07 {
    	public static String solution(String need , String plan) {
    		String answer = "YES";
    		Queue<Character> Q = new LinkedList<>();
    		for(char x : need.toCharArray()) {
    			Q.offer(x);
    		}
    		for(char x : plan.toCharArray()) {
    			if(Q.contains(x)) {
    				if(x != Q.poll()) { // 필수과목에는 있지만 순서가 다르다
    					return "NO";
    				}
    			}
    		}
    		if(!Q.isEmpty()) { // 필수과목을 전부 듣지 않은경우
    			return "NO";
    		}
    		return answer ;
    	}
    	
    	public static void main(String[] args) {
    		Scanner kb = new Scanner(System.in);
    		
    		String need = kb.nextLine();
    		String plan  = kb.nextLine();
    		System.out.println(solution(need, plan));
    	}
    }
    
    ```

    