# 2021-06-24

## 예제로 배우는 스프링부트 - 트랜잭션

### 서비스의 개념과 사용

#### 스프링 웹 mvc의 구조

![img](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/images/mvc.png)

- 프론트 컨트롤러

  컨트롤러 앞에 존재하는 컨트롤러를 만들어 모든 흐름의 제어를 담당

  비즈니스 로직은 개별 컨트롤러에서 각각 당당

- 테이블 하나당 DTO와 DAO를 만들어, DAO가 단일 테이블에 대한 데이터 접근 및 갱신만 처리하도록 만들면 데이터베이스의 처리가 간결해진다

- 비즈니스 로직을 처리하는 **서비스( Service )**단을 만든다

  **서비스는 여러 DAO를 호출하여 여러 번의 데이터 접근 및 갱신을 하며, 그렇게 읽은 데이터에 대한 비즈니스 로직을 수행하고 그것을 하나의 (또는 여러 개의) 트랜잭션으로 묶는다.**

  **=> 서비스가 데이터베이스의 트랜잭션 단위**

#### 서비스 적용 예제

##### ISimpleBbsService

```java
package com.study.springboot.service;

import java.util.List;
import java.util.Map;

import org.apache.ibatis.annotations.Param;

import com.study.springboot.dto.SimpleBbsDto;

public interface ISimpleBbsService {
	public List<SimpleBbsDto> list();
	public SimpleBbsDto view(String id);
	public int write(Map<String, String> map);
	public int delete(@Param("_id") String id);
	public int count();
}

```

##### SimpleBbsService

```java
package com.study.springboot.service;

import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.study.springboot.dao.ISimpleBbsDao;
import com.study.springboot.dto.SimpleBbsDto;

@Service // 빈으로 등록
public class SimpleBbsService implements ISimpleBbsService{

	@Autowired
	ISimpleBbsDao dao;
	
	@Override
	public List<SimpleBbsDto> list() {
		return dao.listDao();
	}

	@Override
	public SimpleBbsDto view(String id) {
		return dao.viewDao(id);
	}

	@Override
	public int write(Map<String, String> map) {
		int nResult = dao.writeDao(map);
		return nResult;
	}

	@Override
	public int delete(String id) {
		int nResult = dao.deleteDao(id);
		return nResult;
	}

	@Override
	public int count() {
		int nTotalCount = dao.articleCount();
		return nTotalCount;
	}

}

```

#### 프론트 컨트롤러

```java
package com.study.springboot;

import java.util.HashMap;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.study.springboot.dao.ISimpleBbsDao;
import com.study.springboot.service.ISimpleBbsService;

@Controller
public class MyController {
	
	@Autowired
	ISimpleBbsService service;
	
	@RequestMapping("/")
	public String root() throws Exception{
		return "redirect:list";
	}
	
	@RequestMapping("/list")
	public String userlistPage(Model model) {
		model.addAttribute("list",service.list());
		
		int total = service.count();
		System.out.println("Count : "+total);
		
		return "list";
	}
	
	@RequestMapping("/view")
	public String view(@RequestParam String id , Model model) {
			model.addAttribute("dto",service.view(id));
			return "view";
	}
	
	@RequestMapping("/writeForm")
	public String writeForm() {
		return "writeForm";
	}
	
	@RequestMapping("/write")
	public String write(Model model,@RequestParam String writer,@RequestParam String title,@RequestParam String content) {
		Map<String, String> map = new HashMap<String, String>();
		
		map.put("item1", writer);
		map.put("item2", title);
		map.put("item3",content);
		
		int result = service.write(map);
		//insert되었으면 1
		System.out.println("write : "+result);
		
		return "redirect:list";
	}
	
	@RequestMapping("/delete")
	public String delete(@RequestParam String id,Model model) {
		service.delete(id);
		return "redirect:list";
	}
}

```

### 트랜잭션 미적용 시 에러 상황

#### 서비스와 트랜잭션

**스프링에서의 트랜잭션 설정은 지정된 범위안에서 에러가 나면 그 범위 안에서 수행한 데이터베이스 작업의 롤백을 수행하고 , 에러가 없다면 커밋을 수행하는 작업 설정**

#### 에러 발생 상황 예제

##### DTO

```JAVA
package com.study.springboot.dto;

import lombok.Data;

@Data
public class Transaction1Dto {
	private String consumerId;
	private int amount;
}

```

```JAVA
package com.study.springboot.dto;

import lombok.Data;

@Data
public class Transaction2Dto {
	private String consumerId;
	private int amount;
}

```

##### DAO

```JAVA
package com.study.springboot.dao;

import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface ITransaction1Dao {
	public void pay(String consumerId,int amount);
}

```

```JAVA
package com.study.springboot.dao;

import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface ITransaction2Dao {
	public void pay(String consumerId,int amount);
}

```

##### mapper

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  
<mapper namespace="com.study.springboot.dao.ITransaction1Dao">
	<insert id="pay">
		INSERT INTO transaction1 (consumerId , amount) 
			VALUES (#{consumerId},#{amount})
	</insert>
</mapper>

```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  
<mapper namespace="com.study.springboot.dao.ITransaction2Dao">
	<insert id="pay">
		INSERT INTO transaction2 (consumerId , amount) 
			VALUES (#{consumerId},#{amount})
	</insert>
</mapper>

```

##### Service

```java
package com.study.springboot.service;

public interface IBuyTicketService {
	public int buy(String consumerId , int amount , String error);
}

```

```java
package com.study.springboot.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.study.springboot.dao.ITransaction1Dao;
import com.study.springboot.dao.ITransaction2Dao;

@Service
public class BuyTicketService implements IBuyTicketService{

	@Autowired
	ITransaction1Dao transaction1;
	
	@Autowired
	ITransaction2Dao transaction2;
	
	@Override
	public int buy(String consumerId, int amount, String error) {
		try {
			transaction1.pay(consumerId, amount);
			
			//의도적 에러 발생
			if(error.equals("1")) {
				int n = 10 / 0;
			}
			
			transaction2.pay(consumerId, amount);
			
			return 1;
		} catch (Exception e) {
			return 0;
		}
	}

}

```

##### 컨트롤러

```java
package com.study.springboot;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.study.springboot.service.IBuyTicketService;

@Controller
public class MyController {
	@Autowired
	IBuyTicketService buyTicket;
	
	@RequestMapping("/")
	@ResponseBody
	public String root() throws Exception{
		return "buy_ticket";
	}
	
	@RequestMapping("/buy_ticket")
	public String buy_ticket(){
		return "buy_ticket";
	}
	
	@RequestMapping("/buy_ticket_card")
	public String buy_ticket_card(@RequestParam String consumerId,@RequestParam String amount , @RequestParam String error , Model model) {
		int nResult = buyTicket.buy(consumerId, Integer.parseInt(amount), error);
		
		
		model.addAttribute("consumerId",consumerId);
		model.addAttribute("amount",amount);
		
		if(nResult == 1) {
			return "buy_ticket_end";
		}else {
			return "buy_ticket_error";
		}
	}
}

```

##### 뷰

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>BuyTicket</title>
</head>
<body>

<p>카드 결제</p>

<form action="buy_ticket_card">
    고객 아이디 : <input type="text" name="consumerId" > <br />
    티켓 구매수 : <input type="text" name="amount" > <br />
    에러 발생 여부 : <input type="text" name="error" value="0"> <br />
    <input type="submit" value="구매" > <br />
</form>

<hr>
에러 발생 여부에 1을 입력하면 에러가 발생합니다.

</body>
</html>
```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>BuyTicketEnd</title>
</head>
<body>

buy_ticket_end.jsp 입니다. <br />

${consumerId } <br />
${amount } <br />


</body>
</html>
```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>BuyTicketError</title>
</head>
<body>

buy_ticket_error.jsp 입니다. <br />

<h1>에러가 발생했습니다.</h1> <br />

${consumerId } <br />
${amount } <br />


</body>
</html>
```

##### 결론

두 개의 DAO가 정상적으로 다 끝나야 서비스의 비즈니스 로직이 정상적으로 처리되었다고 봐야할지 , 하나라도 수행되었다면 그것으로도 충분한 것인지 정해야한다.

안그러면 하나의 테이블에는 값이 들어가고 하나의 테이블에는 값이 안들어가는 상황이 발생한다.

### 트랜잭션 매니저 사용하기

#### 스프링에서 트랜잭션을 사용하는 방법

1. **프로그래밍적인 방법**은 명시적으로 commit & rollback 선언을 통해 트랜잭션 처리를 하는 방법으로 , 메서드 단위보다 더 작은 단위로 트랜잭션 처리를 할 때 사용할 수 있다.
2. **선언적 방법**의 트랜잭션은 빈의 퍼블릭 메서드에 어노테이션을 이용하여 추가하는데, 미리 선언된 룰에 따라 트랜잭션을 제어하고 예외 발생 시 자동으로 롤백 , 그러므로 트랜잭션의 시작과 커밋,롤백 등의 일반적인 처리를 비즈니스 로직 안에서 기술할 필요가 없다

#### 트랜잭션 매니저 적용 예제 ( 프로그래밍적 방법)

##### 서비스 변경

```java
package com.study.springboot.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;

import com.study.springboot.dao.ITransaction1Dao;
import com.study.springboot.dao.ITransaction2Dao;

@Service
public class BuyTicketService implements IBuyTicketService{

	@Autowired
	ITransaction1Dao transaction1;
	@Autowired
	ITransaction2Dao transaction2;
	
	//트랜잭션 매니저 변수를 선언하고 스프링으로부터 자동 주입
	@Autowired
	PlatformTransactionManager transactionManager;
	
	//트랜잭션 매니저에서 사용할 설정을 만드는 데 설정값은 기본으로 제공되는 값을 변경 없이 그대로 사용
	@Autowired
	TransactionDefinition definition;
	
	@Override
	public int buy(String consumerId, int amount, String error) {
		//트랜잭션 설정 , 이 설정 이후의 데이터베이스 처리에 대해서 트랜잭션을 처리할 수 있게 된다.
		TransactionStatus status = transactionManager.getTransaction(definition);
		
		try {
			transaction1.pay(consumerId, amount);
			
			//의도적 에러 발생
			if(error.equals("1")) {
				int n = 10 / 0;
			}
			
			transaction2.pay(consumerId, amount);
			
			//커밋
			transactionManager.commit(status);;
			return 1;
		} catch (Exception e) {
			System.out.println("rollback");
			//롤백
			transactionManager.rollback(status);
			return 0;
		}
	}

}

```

### 트랜잭션 템플릿 사용하기 (프로그래밍적 방법)

#### 서비스 변경

```java
package com.study.springboot.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;

import com.study.springboot.dao.ITransaction1Dao;
import com.study.springboot.dao.ITransaction2Dao;

@Service
public class BuyTicketService implements IBuyTicketService{

	@Autowired
	ITransaction1Dao transaction1;
	@Autowired
	ITransaction2Dao transaction2;
	
	//트랙잭션 템플릿 변수를 자동주입
	@Autowired
	TransactionTemplate transactionTemplate;
	
	
	@Override
	public int buy(String consumerId, int amount, String error) {
		
		try {
			//트랜잭션을 적용할 부분을 트랜잭션 템플릿으로 감싼다.
			transactionTemplate.execute(new TransactionCallbackWithoutResult() {
				@Override
				protected void doInTransactionWithoutResult(TransactionStatus status) { //트랜잭션을 적용시킬 로직을 작성 , 익명클래스 사용
					transaction1.pay(consumerId, amount);
					
					//의도적 에러 발생
					if(error.equals("1")) {
						int n = 10 / 0;
					}
				
					transaction2.pay(consumerId, amount);
				}
			});
			return 1;
		} catch (Exception e) {
			System.out.println("rollback");
			return 0;
		}
	}

}

```

### 트랜잭션 전파 속성

#### 트랜잭션이 중첩된  상황의 이해

ex) [ 티켓 구입 서비스 ] 두 개의 DAO가 있어서 이 두 개를 트랙잭션 B로 묵음

[ 로그 작성 서비스 ] 한 개의 DAO가 있어서 트랜잭션 필요 없음

[ 티켓 구입 & 로그 작성 서비스]  둘 다 해야 하므로 이 두개의 서비스 호출을 트랜잭션A로 묶음

따라서 트랜잭션A안에 트랜잭션 B가 포함

#### 트랜잭션이 중첩된 예제

##### DTO 추가

```JAVA
package com.study.springboot.dto;

import lombok.Data;

@Data
public class Transaction3Dto {
	private String consumerId;
	private int amount;
}

```

##### 서비스 변경 , 추가

```JAVA
package com.study.springboot.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;

import com.study.springboot.dao.ITransaction1Dao;
import com.study.springboot.dao.ITransaction2Dao;

@Service
public class BuyTicketService{

	@Autowired
	ITransaction1Dao transaction1;
	@Autowired
	ITransaction2Dao transaction2;
	
	@Autowired
	TransactionTemplate transactionTemplate;
	
	//트랜잭션B
	//전파 속성 : 두 번째 트랜잭션이 첫 번째 트랜잭션에 어떤 방식으로 참여할 것이냐?
	// Propagation.REQUIRES_NEW : 나의 트랜잭션만 보겠다.다른것은 상관안한다.
	// Propagation.REQUIRED : 연관된 모든 트랜잭션을 보겠다. 트랜잭션이 합쳐짐
	@Transactional(propagation = Propagation.REQUIRES_NEW)
	public int buy(String consumerId, int amount, String error) {
	
		try {
			transactionTemplate.execute(new TransactionCallbackWithoutResult() {
				@Override
				protected void doInTransactionWithoutResult(TransactionStatus status) {
					
					
					transaction1.pay(consumerId, amount);
					
					//의도적 에러 발생
					if(error.equals("1")) {
						int n = 10 / 0;
					}
				
					transaction2.pay(consumerId, amount);
				}
			});
			
			return 1;
		} catch (Exception e) {
			System.out.println("rollback");
			return 0;
		}
	}

}

```

```JAVA
package com.study.springboot.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.study.springboot.dao.ITransaction3Dao;

@Service
public class LogWriteService {
	
	@Autowired
	ITransaction3Dao transaction3;
	
	public int write(String consumerId,int amount) {
		//dao를 호출하는 부분이 이 라인 하나라 별도의 트랜잭션 처리를 하지 않는다.
		try {
			transaction3.pay(consumerId, amount);
			return 1;
		}catch (Exception e) {
			return 0;
		}
	}
}

```

```java
package com.study.springboot.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;

import com.study.springboot.dao.ITransaction1Dao;
import com.study.springboot.dao.ITransaction2Dao;

@Service
public class BuyAndLogService{

	@Autowired
	BuyTicketService buyTicket;
	@Autowired
	LogWriteService logWrite;
	
	@Autowired
	TransactionTemplate transactionTemplate;
	
	
	//트랜잭션A
	public int buy(String consumerId, int amount, String error) {
		
		try {
			transactionTemplate.execute(new TransactionCallbackWithoutResult() {
				@Override
				protected void doInTransactionWithoutResult(TransactionStatus status) {
					
					//0을 넣으면 모두 커밋됨 
					//2를 넣을떄
					//					Propagation.REQUIRES_NEW 이면 위에것은 커밋되고 아래 것은 롤백됨
					//					Propagation.REQUIRED 둘 다 롤백됨
					//1를 넣으면
					//					Propagation.REQUIRES_NEW 둘다 롤백
					//					Propagation.REQUIRED 둘 다 롤백됨
					
					buyTicket.buy(consumerId, amount, error);
					
					//의도적 에러 발생
					if(error.equals("2")) {
						int n = 10 / 0;
					}
				
					logWrite.write(consumerId, amount);
				}
			});
			
			return 1;
		} catch (Exception e) {
			System.out.println("rollback");
			return 0;
		}
	}

}

```

##### 컨트롤러 변경

```java
package com.study.springboot;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.study.springboot.service.BuyAndLogService;

@Controller
public class MyController {
	
	@Autowired
	BuyAndLogService buyTicketLog;

	
	@RequestMapping("/")
	@ResponseBody
	public String root() throws Exception{
		return "buy_ticket";
	}
	
	@RequestMapping("/buy_ticket")
	public String buy_ticket(){
		return "buy_ticket";
	}
	
	@RequestMapping("/buy_ticket_card")
	public String buy_ticket_card(@RequestParam String consumerId,@RequestParam String amount , @RequestParam String error , Model model) {
		int nResult = buyTicketLog.buy(consumerId, Integer.parseInt(amount), error);
		
		
		model.addAttribute("consumerId",consumerId);
		model.addAttribute("amount",amount);
		
		if(nResult == 1) {
			return "buy_ticket_end";
		}else {
			return "buy_ticket_error";
		}
	}
}

```

##### 전파 속성 설정

![img](https://media.vlpt.us/images/cyhse7/post/10bb9d24-9946-4b34-b036-4d0604a45155/image.png)

## 스프링 입문을 위한 객체지향의 원리와 이해

### 스프링 삼각형과 설정 정보

![스프링 삼각형과 설정 정보(1) - IoC/DI(1)](https://media.vlpt.us/images/jsj3282/post/b43f8824-c037-40ea-8df6-50891075a3e3/image.png)

POJO(Plain Old Java Object)를 기반으로 스프링 삼각형이라는 애칭을 가진 IoC/DI , AOP , PSA 라고 하는 스프링의 3대 프로그래밍 모델에 대한 이해가 필수

### IoC/DI - 제어의 역전/의존성 주입

#### 프로그래밍에서 의존성이란?

- 의사코드
  - 운전자가 자동차를 생산한다
  - 자동차는 내부적으로 타이어를 생산한다
- JAVA로 표현
  - new Car()
  - Car 객체 생성자에서 new Tire();

**프로그래밍에서 의존 관계는 new 이다**

new를 실행하는 Car와 Tire 사이에서 Car가 Tire에 의존한다

결론적으로 **전체가 부분에 의존한다라고 표현**

![img](https://t1.daumcdn.net/cfile/tistory/1776C63650F3FFCB03)

![img](https://t1.daumcdn.net/cfile/tistory/154C703350AC8DC41D)

- 인터페이스 Tire

  ```
  package expert001_01;
  
  public interface Tire {
  	String getBrand();
  }
  
  ```

  - 인터페이스 구현

  ```java
  package expert001_01;
  
  public class KoreaTire implements Tire{
  
  	@Override
  	public String getBrand() {
  		return "한국타이어";
  	}
  
  }
  
  ```

  ```java
  package expert001_01;
  
  public class AmericaTire implements Tire{
  
  	@Override
  	public String getBrand() {
  		return "미국 타이어";
  	}
   
  }
  
  ```

```java
package expert001_01;

public class Car {
	Tire tire;
	public Car() {
        //의존 관계가일어남
        //자동차가 타이어를 생산
		tire = new KoreaTire(); 
		//tire = new AmericaTire(); 
	}
	
	public String getTireBrand() {
		return "장착된 타이어 "+tire.getBrand();
	}
}

```

```java
package expert001_01;

public class Drivr {
	public static void main(String[] args) {
		Car car = new Car();
		System.out.println(car.getTireBrand());
	}
}

```

###### 결론

자동차는 타이어에 의존한다.
운전자는 자동차를 사용한다(운전자가 자동차에 의존하다고 봐도 되겠지요)

자동차의 생성자 코드에서 tire 속성에 새로운 타이어를 생성해서 참조할 수 있도록 해준다.

#### 스프링 없이 의존성 주입하기1 - 생성자를 통한 의존성 주입

- 의사코드
  - 운전자가 타이어를 생상한다
  - 운전자가 자동차를 생산하며 타이어를 장착한다.
- 자바로 표현 - 생성자의 인자 이용
  - Tire tire = new KoreaTire();
  - Car car = new Car(tire)

##### 주입이란

외부에서라는 뜻을 내포

**자동차 내부에서 타이어를 생성하는 것이 아니라 외부에서 생상된 타이어를 자동차에 장착하는 작업**

![img](https://t1.daumcdn.net/cfile/tistory/031F5C3950AE4BCF23)

```java
package expert001_01;

public class Car {
	Tire tire;
	public Car(Tire tire) {
		this.tire = tire;
	}
	
	public String getTireBrand() {
		return "장착된 타이어 "+tire.getBrand();
	}
}

```

```java
package expert001_01;

public class Drivr {
	public static void main(String[] args) {
		Tire tire = new KoreaTire();
		//tire = new AmericaTire();
		Car car = new Car(tire);
		System.out.println(car.getTireBrand());
	}
}

```

##### 장점

기존 코드에서는 Car가 구체적으로 어떤 타이어를 생산할지 결정했었지만 그러면 **코드의 유연성이 떨어지기 때문에** 운전자가 차량을 생산할 때 운전자가 어떤 타이어를 장착할지 고민해서 장착하게 만듬 

##### 결론

기존 방식에서라면 Car 는 KoreaTire, AmericaTire 에 대해 정확히 알고 있어야만 그에 해당하는 객체를 생성할 수 있었다.

그러나 이렇게 의존성 주입을 통하게 되면 Car 는 그저 Tire 인터페이스를 구현한 어떤 객체가 들어오기만 하면 정상 작동, 그렇게 되면 확장성이 좋아지게 된다고 하는데 후에 ChinaTire, JapenTire, EnglandTire 등등 어떤 새로운 타이어 브랜드가 생겨도 각 타이어 브랜드들이 Tire 인터페이스를 구현하기만 했다면 Car.java 소스의 변경 없이(결국 다시 컴파일 할 필요가 없다는 말이겠죠) 사용할 수 있다.

#### 스프링 없이 의존성 주입하기 2 -속성을 통한 의존성 주입

- 의사코드
  - 운전자가 타이어를 생산
  - 운전자가 자동차를 생산
  - 운전자가 자동차에 타이어를 장착
- 자바 코드 - 속성 메서드 사용
  - Tire tire = new KoreaTire();
  - Car car = new Car();
  - car.setTire(tire);

실세계의 예로 들어보면 자동차를 생산(구입)할 때 한번 타이어를 장착하면 더 이상 타이어를 교체 장착할 방법이 없다. 

그러나 더 현실적인 방법으로 운전자가 원할 때 Car 의 Tire 를 교체하려면 생성자가 아닌 속성을 통한 의존성 주입이 필요

Spring 에서 어노테이션을 사용하는 경우 속성 방식을 사용

![img](https://t1.daumcdn.net/cfile/tistory/20659C3450B2111E07)

```java
package expert001_01;

public class Car {
	Tire tire;
	
	
	public Tire getTire() {
		return tire;
	}


	public void setTire(Tire tire) {
		this.tire = tire;
	}


	public String getTireBrand() {
		return "장착된 타이어 "+tire.getBrand();
	}
}

```

```java
package expert001_01;

public class Drivr {
	public static void main(String[] args) {
		Tire tire = new KoreaTire();
		//tire = new AmericaTire();
		Car car = new Car();
		car.setTire(tire);
        tire = new AmericaTire();
        car.setTire(tire)
		System.out.println(car.getTireBrand());
	}
}

```

