# E06.Interceptor , Logback 사용법

## 1. BaseHandlerInterceptor 추가

```JAVA
package kr.co.jisung.configuration.servlet.handler;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;

/**
 * @author jisung
 * preHandle
 * 		- Controller 실행 요청 전에 수행되는 메서드
 * 		- 클라이언트의 요청을 컨트롤러에 전달 하기 전에 호출
 * 		- return 값으로 boolean 값을 전달하는데 false 인 경우 controller를 실행 시키지 않고 요청 종료
 * 		- 보통 이곳에서 체크작업을 진행한다. (구현자의 취향대로 적용해도 된다.)
 * postHandle
 * 		- view(JSP, timeleaf) 단으로 forward 되기 전에 수행
 * 		- 컨트롤러 로직이 실행된 이후 호출
 * 		- 컨트롤러 단에서 에러 발생 시 해당 메서드는 수행되지 않는다. 
 * 		- request로 넘어온 데이터 가공 시 많이 사용된다.
 *
 */
public class BaseHandlerInterceptor extends HandlerInterceptorAdapter {
	Logger logger = LoggerFactory.getLogger(getClass());

	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
		logger.info("preHandle requestURI : {}", request.getRequestURI());
		return true;
	}
	
	@Override
	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
			ModelAndView modelAndView) throws Exception {
		logger.info("postHandle requestURI : {}", request.getRequestURI());
	}
}

```

## 2. WebConfiguration 클래스에 WebMvcConfigurer 인터페이스 구현

```java
package kr.co.jisung.configuration;

import java.util.Locale;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import kr.co.jisung.configuration.servlet.handler.BaseHandlerInterceptor;
/*
 * 다국어 지원 설정 + 인터셉터
 */
@Configuration
public class WebConfiguration implements WebMvcConfigurer {
	/*
	 * 메세지 소스를 생성한다.
	 */
	@Bean
	public ReloadableResourceBundleMessageSource messageSource() {
		ReloadableResourceBundleMessageSource source = new ReloadableResourceBundleMessageSource();
		//메세지 프로퍼티 파일의 위치와 이름을 지정
		source.setBasename("classpath:/messages/message");
		//기본 인코딩을 지정
		source.setDefaultEncoding("UTF-8");
		//프로퍼티 파일의 변경을 감지할 시간 간격을 지정
		source.setCacheSeconds(60);
		//기본값
		source.setDefaultLocale(Locale.KOREAN);
		//없는 메세지일 경우 예외를 발생시키는 대신 코드를 기본 메세지로 한다.
		source.setUseCodeAsDefaultMessage(true);
		return source;
	}
	
	/*인터셉터 생성*/
	@Bean
	public BaseHandlerInterceptor baseHandlerInterceptor() {
		return new BaseHandlerInterceptor();
	}
	
	/*인터셉터 등록*/
	@Override
	public void addInterceptors(InterceptorRegistry registry) {
		registry.addInterceptor(baseHandlerInterceptor());
	}
}

```



## 3. application.properties logback 설정

```properties
# logback 위치 지정
logging.config = classpath:logback/logback-default.xml
```



## 4. logback-default.xml 추가

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
	<property name="LOG_PATTERN"
		value="%d{yyyy-MM-dd HH:mm:ss} %p %c[%method:%line] - %msg%n" />

	<appender name="STDOUT"
		class="ch.qos.logback.core.ConsoleAppender">
		<layout class="ch.qos.logback.classic.PatternLayout">
			<Pattern>${LOG_PATTERN}</Pattern>
		</layout>
	</appender>
	
  <logger name="kr.co.songjava.mvc.repository">
    <level value="ERROR"/>
  </logger>	
	
  <logger name="org.springframework.boot">
    <level value="ERROR"/>
  </logger>
  <logger name="org.springframework.boot.devtools.restart">
    <level value="ERROR"/>
  </logger>
  <logger name="org.springframework">
    <level value="ERROR"/>
  </logger>
  <logger name="springfox">
    <level value="ERROR"/>
  </logger>  
  <logger name="org.hibernate">
    <level value="ERROR"/>
  </logger>  
  <logger name="org.apache">
    <level value="ERROR"/>
  </logger>     
  <logger name="org.apache.http.impl.conn">
    <level value="ERROR"/>
  </logger>    
  
  <logger name="log4jdbc">
    <level value="ERROR"/>
  </logger>
  
  <logger name="org.mybatis">
    <level value="ERROR"/>
  </logger> 
  
  <logger name="com.zaxxer">
    <level value="ERROR"/>
  </logger>      

  <!-- Query Loggers -->
  <logger name="jdbc" level="ERROR"/>
  <logger name="jdbc.connection" level="ERROR"/>
  <!-- SQL문만을 로그로 남기며, PreparedStatement일 경우 관련된 argument 값으로 대체된 SQL문이 보여진다. -->
  <logger name="jdbc.sqlonly" level="ERROR"/>
  <!-- SQL문과 해당 SQL을 실행시키는데 수행된 시간 정보(milliseconds)를 포함한다. -->
  <logger name="jdbc.sqltiming" level="ERROR"/>
  <!-- ResultSet을 포함한 모든 JDBC 호출 정보를 로그로 남기므로 매우 방대한 양의 로그가 생성된다. -->
  <logger name="jdbc.resultset" level="OFF"/>
  <logger name="jdbc.resultsettable" level="ERROR"/>
  <!-- ResultSet을 제외한 모든 JDBC 호출 정보를 로그로 남긴다. 많은 양의 로그가 생성되므로 특별히 JDBC 문제를 추적해야 할 필요가 있는 경우를 제외하고는 사용을 권장하지 않는다. -->
  <logger name="jdbc.audit" level="OFF"/> 
  		

	<root level="DEBUG">
		<appender-ref ref="STDOUT" />
	</root>
</configuration> 
```



## 5. DriverSpy 라이브러리 및 SQL 로그 보기

```xml
		<!-- DriverSpy -->
		<dependency>
			<groupId>org.bgee.log4jdbc-log4j2</groupId>
			<artifactId>log4jdbc-log4j2-jdbc4.1</artifactId>
			<version>1.16</version>
		</dependency>
```

```properties
#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
#spring.datasource.jdbc-url=jdbc:mysql://localhost:3306/test1?serverTimezone=UTC&characterEncoding=UTF-8
#DriverSpy
spring.datasource.driver-class-name=net.sf.log4jdbc.sql.jdbcapi.DriverSpy
spring.datasource.jdbc-url=jdbc:log4jdbc:mysql://localhost:3306/test1?serverTimezone=UTC&characterEncoding=UTF-8
spring.datasource.username=tester
spring.datasource.password=1234

# logback 위치 지정
logging.config = classpath:logback/logback-default.xml
```